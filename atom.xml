<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RossLin的数字花园</title>
  
  <subtitle>记录·思考·成长</subtitle>
  <link href="https://rosslin.xyz/atom.xml" rel="self"/>
  
  <link href="https://rosslin.xyz/"/>
  <updated>2026-01-30T16:26:05.484Z</updated>
  <id>https://rosslin.xyz/</id>
  
  <author>
    <name>RossLin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>导语</title>
    <link href="https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/%E5%AF%BC%E8%AF%AD/"/>
    <id>https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/%E5%AF%BC%E8%AF%AD/</id>
    <published>2026-01-16T02:00:00.000Z</published>
    <updated>2026-01-30T16:26:05.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>这里没有代码，只有我对生活的感悟、对世界的态度。。</p><p>这里不会涉及敏感话题，不会被流量裹挟，所有观点仅代表个人。它们或许稚嫩，甚至未必正确，但绝对真诚；如果有说得不对的地方，欢迎随时交流探讨。</p><p>专栏里唯一固定的内容是年终总结。说来惭愧，本来计划多写点，奈何人太懒，再加上想写出有深度的文章实在太难了。</p><p>很多想法只是简单的记录下来  没有深入写下去。</p><p>在这个时代，能保持独立思考，真的挺不容易的。</p><p><img src="https://5b9e583.webp.li/2026/01/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.png" alt="博客文章"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h1&gt;&lt;p&gt;这里没有代码，只有我对生活的感悟、对世界的态度。。&lt;/p&gt;
&lt;p&gt;这里不会涉及敏感话题，不会被流量裹挟，所有观点仅代表个人。它们或许稚嫩，甚</summary>
      
    
    
    
    <category term="闲言碎语" scheme="https://rosslin.xyz/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
    <category term="闲言碎语" scheme="https://rosslin.xyz/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    <category term="导语" scheme="https://rosslin.xyz/tags/%E5%AF%BC%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>导语</title>
    <link href="https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E6%A0%BC%E7%89%A9%E5%BF%97/%E5%AF%BC%E8%AF%AD/"/>
    <id>https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E6%A0%BC%E7%89%A9%E5%BF%97/%E5%AF%BC%E8%AF%AD/</id>
    <published>2026-01-16T02:00:00.000Z</published>
    <updated>2026-01-30T16:25:12.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>这个专栏既不像“嵌入式之旅”那么专注，也不似“闲言碎语”那么琐碎——它最大的特质就是杂。</p><p>记录的内容全凭我的兴趣爱好，也会随时间一直变话。例如现在，我正热衷于折腾计算机技术；后续也会更多偏向AI技术</p><p>或许等我到了中年，转而对理财上心了，这里就会多出很多关于金钱的思考。</p><p>始终如一的，只有这真实的记录。</p><p>关于这里记录的操作教程    网上一抓一大把  在这里很更多的从第一性原理出发，搞清楚背后的逻辑。比起单纯的“操作”，我更想记录“原理”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h1&gt;&lt;p&gt;这个专栏既不像“嵌入式之旅”那么专注，也不似“闲言碎语”那么琐碎——它最大的特质就是杂。&lt;/p&gt;
&lt;p&gt;记录的内容全凭我的兴趣爱好，也会随时</summary>
      
    
    
    
    <category term="格物志" scheme="https://rosslin.xyz/categories/%E6%A0%BC%E7%89%A9%E5%BF%97/"/>
    
    
    <category term="格物志" scheme="https://rosslin.xyz/tags/%E6%A0%BC%E7%89%A9%E5%BF%97/"/>
    
    <category term="导语" scheme="https://rosslin.xyz/tags/%E5%AF%BC%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>导语</title>
    <link href="https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%AF%BC%E8%AF%AD/"/>
    <id>https://rosslin.xyz/2026/01/16/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%AF%BC%E8%AF%AD/</id>
    <published>2026-01-16T02:00:00.000Z</published>
    <updated>2026-01-30T16:25:43.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>这里记录了我以大学嵌入式竞赛及实战项目为切入点整理的核心笔记。</p><p>笔记涵盖领域</p><p>1.电子竞赛系列</p><ul><li>蓝桥杯单片机</li><li>西门子杯</li><li>智能车竞赛</li><li>嵌赛</li></ul><p>2.实战项目系列</p><ul><li>智能门锁</li><li>平衡车</li></ul><p>3.操作系统与软件工程</p><ul><li>RT-Thread</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h1&gt;&lt;p&gt;这里记录了我以大学嵌入式竞赛及实战项目为切入点整理的核心笔记。&lt;/p&gt;
&lt;p&gt;笔记涵盖领域&lt;/p&gt;
&lt;p&gt;1.电子竞赛系列&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    
    <category term="导语" scheme="https://rosslin.xyz/tags/%E5%AF%BC%E8%AF%AD/"/>
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2025%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T16:11:26.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2025年终总结"><a href="#2025年终总结" class="headerlink" title="2025年终总结"></a>2025年终总结</h1><h2 id="关于家庭"><a href="#关于家庭" class="headerlink" title="关于家庭"></a>关于家庭</h2><p>每年的除夕，我们全家都会在我姐的张罗下拍全家福。但在2025年的开端，是个例外。</p><p>全家在低气压的状态中度过，我姐的工作面临变动，身体状况也亮起了红灯，这成了压在全家的一块巨石。</p><p>母亲的泪水留了又留，而作为家里最小的孩子，看着这一切，原来无能为力，才是最大的痛楚。在这</p><p>不过，好在这一切是短暂的，时间抚平了一切。</p><h2 id="大学生活"><a href="#大学生活" class="headerlink" title="大学生活"></a>大学生活</h2><p>大一的我，曾有个一段美好的志愿服务的时光，和小伙伴一起吃饭聊天 做游戏，做志愿，还有和舍友的爬山</p><p>不过美好的时光伴随着我转校区后戛然而止，所有的社会活动需要在新的环境下重新建立，也没有刚上大一时努力，开始渐渐迷上游戏、</p><p>后来我意识到不能再这样下去了。抱着空杯者的心态盲目目地去参加各种活动，我接触到了竞赛，进入了实验室，开始打各种各样的比赛</p><p>我很幸运，在2025年找到了自己的方向</p><h2 id="兼职"><a href="#兼职" class="headerlink" title="兼职"></a>兼职</h2><p>回看这一年，我是个身兼数职的牛马，食堂的早餐店，学校的器材室，在往前看，在小学门口发传单，寒暑假流水线上把一生都想明白的一天又一天，现在想想，我得给那个不知疲倦的自己敬个礼。，天生的牛马体。</p><p>不过，在明确了发展方向后，我开始意识到：单纯出卖体力的勤奋，失去了很多机会成本。</p><p>虽然这是一份没有报酬、仅包一餐的实习，但我心里的算盘打得很响：这既给了我正当理由在家休整，避开无效的体力劳动；又能申请“优秀个人”荣誉，成为我争取奖学金的重要筹码。</p><p>与其做些出卖体力的劳动 不如花时间投资自己去成长</p><h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>这一年我是幸福的</p><p>我去了香港研学。那五天是极限的：熬夜做PPT、维多利亚港的街头采访、港科大的调研。我也去了山西太原参加线下比赛，与其说是参加比赛，不如说是去旅游，完成了人生第一次租车自驾去到五台山，去了一些比较网红的商业街参加西门子杯全国总决赛。 </p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p> 但我记得最深的，不是风景，而是一个瞬间。 那是我留校参加比赛夜晚回宿舍的路上，没有路灯，漆黑一片。一个女生独自坐在路中间的石墩上，掩面哭泣。 在这个时代，每个人都在负重前行，每个人都有深夜里说不出口的苦。 这一幕让我明白，技术之外，人更需要悲悯。</p><p>我们除了选择努力 别无选择。</p><h2 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h2><p>回顾这一年，“孤独”似乎是我的高频词。但我并不讨厌它。</p><p>我慢慢发现，自己拥有一种“屏蔽力”。我不会因为没人陪而放弃我想考的证，也不会因为要去陌生的城市而退缩。</p><p>印象最深的是西门子杯的全国总决赛。队伍里10个人，9个是谈笑风生的大四学长，只有我是大三的“孤勇者”。 我到现在都还清晰地记得去山西的前一晚：实验室空荡荡的，只有我一个人守着电脑和还没打样的PCB板。为了赶最早的一班车，我甚至来不及回宿舍，天还没亮就要跑去校外的站点拿快递。</p><p>那时候天很黑，风很冷，心里说不慌是假的。但当我一个人搞定所有突发状况站在赛场上时，我突然觉得，这种“不容易”恰恰是我成长的勋章。原来，一个人也可以是一支队伍。</p><h2 id="展望2026"><a href="#展望2026" class="headerlink" title="展望2026"></a>展望2026</h2><p>如果要给 2026 年定一个关键词，我希望是——勇敢。</p><p>2025 年的经验证明：行动往往止步于过度的思考。 </p><p>很多时候，机会的窗口期极短，而我总在迟疑过后陷入遗憾。不推开门，答案就永远包裹在黑盒里。</p><p>对我而言，世界上最痛苦的莫过于“遗憾”。在“如果当初”与“确定的结果（成功或失败、甜蜜或苦涩）”之间，我更愿意选择后者。</p><p>过去这一年，那些真正让我获得成长的瞬间，其实都挺“莽”的。</p><p>展望 2026，这将是我至关重要的一年：上半年冲刺大学竞赛，下半年开启职场实习。</p><p>勇敢的人未必先享受世界，但勇敢的人一定拥有更多的机会与可能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2025年终总结&quot;&gt;&lt;a href=&quot;#2025年终总结&quot; class=&quot;headerlink&quot; title=&quot;2025年终总结&quot;&gt;&lt;/a&gt;2025年终总结&lt;/h1&gt;&lt;h2 id=&quot;关于家庭&quot;&gt;&lt;a href=&quot;#关于家庭&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="闲言碎语" scheme="https://rosslin.xyz/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    <category term="年终总结" scheme="https://rosslin.xyz/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="闲言碎语" scheme="https://rosslin.xyz/tags/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    <category term="年终总结" scheme="https://rosslin.xyz/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2.定时器应用（舵机控制）</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/2.%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%EF%BC%88%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%EF%BC%89/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/2.%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%EF%BC%88%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%EF%BC%89/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:51.304Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="定时器与舵机控制"><a href="#定时器与舵机控制" class="headerlink" title="定时器与舵机控制"></a>定时器与舵机控制</h1><p><strong><img src="https://5b9e583.webp.li/2026/01/2.%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="2.定时器的应用"></strong></p><h2 id="一、理论基础：PWM与舵机"><a href="#一、理论基础：PWM与舵机" class="headerlink" title="一、理论基础：PWM与舵机"></a>一、理论基础：PWM与舵机</h2><h3 id="1-PWM-脉冲宽度调制-核心概念"><a href="#1-PWM-脉冲宽度调制-核心概念" class="headerlink" title="1. PWM (脉冲宽度调制) 核心概念"></a>1. PWM (脉冲宽度调制) 核心概念</h3><p>PWM 是一种利用数字信号控制模拟电路的技术，通过改变脉冲的宽度（高电平时间）来调整输出的平均电压或信号特征。</p><table><thead><tr><th>参数</th><th>说明</th><th>计算公式</th></tr></thead><tbody><tr><td>周期</td><td>一个完整PWM波形的时间</td><td>T &#x3D; (ARR+1) × (PSC+1) &#x2F; 时钟频率</td></tr><tr><td>频率</td><td>每秒PWM波形个数</td><td>f &#x3D; 1&#x2F;T</td></tr><tr><td>占空比</td><td>高电平时间占比</td><td>占空比 &#x3D; CCR&#x2F;(ARR+1) × 100%</td></tr></tbody></table><h3 id="2-舵机控制原理"><a href="#2-舵机控制原理" class="headerlink" title="2. 舵机控制原理"></a>2. 舵机控制原理</h3><p>舵机通过接收 PWM 信号的脉冲宽度（高电平持续时间）来决定输出轴的旋转角度。它属于位置控制，而非简单的速度或方向控制。</p><ul><li>工作参数：<ul><li>电压：4.8V ~ 6V (推荐 5V)</li><li>周期：20ms (50Hz)</li><li>有效脉宽：0.5ms ~ 2.5ms</li></ul></li><li>脉宽与角度映射表：</li></ul><table><thead><tr><th>脉冲宽度 (高电平)</th><th>对应角度</th><th>说明</th><th>CCR值 (基于1MHz计数)</th></tr></thead><tbody><tr><td>0.5ms</td><td>0°</td><td>起始位置</td><td>500</td></tr><tr><td>1.0ms</td><td>45°</td><td>-</td><td>1000</td></tr><tr><td>1.5ms</td><td>90°</td><td>中位</td><td>1500</td></tr><tr><td>2.0ms</td><td>135°</td><td>-</td><td>2000</td></tr><tr><td>2.5ms</td><td>180°</td><td>结束位置</td><td>2500</td></tr></tbody></table><blockquote><p>计算公式：角度 &#x3D; (脉冲宽度-0.5) × 90</p></blockquote><hr><h2 id="二、硬件连接指南"><a href="#二、硬件连接指南" class="headerlink" title="二、硬件连接指南"></a>二、硬件连接指南</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">舵机</span><br><span class="line">5v  (红线) 连接到降压模块</span><br><span class="line">PA0 PWM信号线（黄线）连接到单片机</span><br><span class="line">GND (黑线) </span><br><span class="line">注意：减压模块和单片机需要公地</span><br></pre></td></tr></table></figure><p>**<img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20250921142637573.png" alt="舵机"></p><hr><h2 id="三、STM32-代码实现"><a href="#三、STM32-代码实现" class="headerlink" title="三、STM32 代码实现"></a>三、STM32 代码实现</h2><h3 id="1-核心配置思路"><a href="#1-核心配置思路" class="headerlink" title="1. 核心配置思路"></a>1. 核心配置思路</h3><p>要实现题目要求的 0° -&gt; 90° -&gt; 0° 模拟开门动作：</p><ol><li>时钟源：配置定时器预分频，使计数器频率为 1MHz (1us 跳变一次)，方便计算。</li><li>周期：设置 ARR 为 19999 (即 20000次计数 &#x3D; 20ms)。</li><li>动作：在 <code>main</code> 函数中修改 CCR 值（比较值）来改变占空比。</li></ol><h3 id="2-代码封装"><a href="#2-代码封装" class="headerlink" title="2. 代码封装"></a>2. 代码封装</h3><h4 id="宏定义与头文件"><a href="#宏定义与头文件" class="headerlink" title="宏定义与头文件"></a>宏定义与头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PERIOD 20000  <span class="comment">// PWM周期为20ms (20000us)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MIN 500       <span class="comment">// 最小脉宽为0.5ms (500us)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MAX 2500      <span class="comment">// 最大脉宽为2.5ms (2500us)</span></span></span><br></pre></td></tr></table></figure><h4 id="初始化函数-GPIO-Timer"><a href="#初始化函数-GPIO-Timer" class="headerlink" title="初始化函数 (GPIO + Timer)"></a>初始化函数 (GPIO + Timer)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Servo_PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 开启时钟：TIM2 和 GPIOA</span></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. GPIO配置 (PA0 复用推挽输出)</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; <span class="comment">// TIM2_CH1 对应 PA0</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">// 复用推挽是关键！</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定时器时基配置 (决定 PWM 频率)</span></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;</span><br><span class="line">    TIM_TimeBaseStructure.TIM_Period = PWM_PERIOD - <span class="number">1</span>;     <span class="comment">// ARR: 19999</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_Prescaler = PWM_PRESCALER;   <span class="comment">// PSC: 71 (1MHz计数频率)</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 输出比较通道配置 (决定 PWM 占空比)</span></span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;      <span class="comment">// PWM模式1</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">// 使能输出</span></span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = SERVO_0_DEG;           <span class="comment">// 初始位置 0度</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     <span class="comment">// 极性高</span></span><br><span class="line">    TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure); <span class="comment">// 初始化通道1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 使能预装载 (平滑切换)</span></span><br><span class="line">    TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);</span><br><span class="line">    TIM_ARRPreloadConfig(TIM2, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 开启定时器</span></span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数逻辑-实现开门模拟"><a href="#主函数逻辑-实现开门模拟" class="headerlink" title="主函数逻辑 (实现开门模拟)"></a>主函数逻辑 (实现开门模拟)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Lock</span><span class="params">(u8 enable)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(enable)  <span class="comment">//开锁</span></span><br><span class="line">         TIM_SetCompare1(TIM2, <span class="number">1500</span>);<span class="comment">//设置占空比   500/2000 =25%</span></span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//锁上的状态</span></span><br><span class="line">         TIM_SetCompare1(TIM2, <span class="number">500</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、核心疑难解析"><a href="#四、核心疑难解析" class="headerlink" title="四、核心疑难解析"></a>四、核心疑难解析</h2><h3 id="1-普通定时器-vs-PWM输出"><a href="#1-普通定时器-vs-PWM输出" class="headerlink" title="1. 普通定时器 vs PWM输出"></a>1. 普通定时器 vs PWM输出</h3><p>这两个概念是包含关系：</p><table><thead><tr><th>功能模块</th><th>关注点</th><th>关键结构体</th><th>作用</th></tr></thead><tbody><tr><td>时基单元 (TimeBase)</td><td>频率、周期</td><td><code>TIM_TimeBaseInitTypeDef</code></td><td>相当于”秒表”，决定数数的快慢和上限。</td></tr><tr><td>输出比较 (OutputCompare)</td><td>占空比、极性</td><td><code>TIM_OCInitTypeDef</code></td><td>相当于”裁判”，根据秒表的数值决定何时输出高&#x2F;低电平。</td></tr></tbody></table><ul><li>总结：配置 PWM 必须先配置时基单元（定频率），再配置输出比较单元（定占空比）。</li></ul><h3 id="2-GPIO-复用功能-AFIO"><a href="#2-GPIO-复用功能-AFIO" class="headerlink" title="2. GPIO 复用功能 (AFIO)"></a>2. GPIO 复用功能 (AFIO)</h3><p>为什么 PA0 要设为 <code>GPIO_Mode_AF_PP</code> (复用推挽)?</p><ul><li>普通模式：GPIO 的高低电平由 <code>ODR</code> 寄存器控制（即代码里的 <code>GPIO_SetBits</code>）。</li><li>复用模式：GPIO 的控制权移交给了片上外设（这里是 TIM2）。</li><li>流程：TIM2 内部产生 PWM 信号 -&gt; 传递给复用控制器 -&gt; PA0 引脚输出。如果不开启复用，TIM2 产生的信号就无法传送到引脚上。</li></ul><hr><h2 id="五、关键配置参数速查表"><a href="#五、关键配置参数速查表" class="headerlink" title="五、关键配置参数速查表"></a>五、关键配置参数速查表</h2><table><thead><tr><th>参数名</th><th>解释</th><th>典型配置 (舵机)</th></tr></thead><tbody><tr><td><code>TIM_Period</code> (ARR)</td><td>周期：决定 PWM 的总时长</td><td>19999 (对应20ms)</td></tr><tr><td><code>TIM_Prescaler</code> (PSC)</td><td>分频：决定计数的快慢</td><td>71 (使计数频率为1MHz)</td></tr><tr><td><code>TIM_Pulse</code> (CCR)</td><td>脉宽：决定高电平时间</td><td>500<del>2500 (对应0.5</del>2.5ms)</td></tr><tr><td><code>TIM_OCMode</code></td><td>模式：PWM1 vs PWM2</td><td><code>TIM_OCMode_PWM1</code> (计数值&lt;CCR时有效)</td></tr><tr><td><code>TIM_OCPolarity</code></td><td>极性：有效电平是高还是低</td><td><code>TIM_OCPolarity_High</code></td></tr></tbody></table><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;定时器与舵机控制&quot;&gt;&lt;a href=&quot;#定时器与舵机控制&quot; class=&quot;headerlink&quot; title=&quot;定时器与舵机控制&quot;&gt;&lt;/a&gt;定时器与舵机控制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://5b9e583.webp.li</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>1.GPIO、定时器与中断实战指南</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/1.GPIO%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/1.GPIO%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:44.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPIO、定时器与中断实战指南"><a href="#GPIO、定时器与中断实战指南" class="headerlink" title="GPIO、定时器与中断实战指南"></a>GPIO、定时器与中断实战指南</h1><p>简介： 本指南系统梳理了嵌入式开发中三大核心外设：GPIO、定时器与中断的原理与配置方法，并结合标准库提供实战代码。</p><hr><h2 id="一、GPIO-与-LED-操作"><a href="#一、GPIO-与-LED-操作" class="headerlink" title="一、GPIO 与 LED 操作"></a>一、GPIO 与 LED 操作</h2><h3 id="1-GPIO-基础概念"><a href="#1-GPIO-基础概念" class="headerlink" title="1. GPIO 基础概念"></a>1. GPIO 基础概念</h3><p><strong>GPIO (General Purpose Input&#x2F;Output)</strong> 是微控制器与外部世界交互的最基本方式。</p><ul><li><strong>输入模式：</strong> 读取外部信号电平（如按键状态、传感器数据）。</li><li><strong>输出模式：</strong> 主动输出高低电平（如驱动LED、控制继电器）。</li><li><strong>复用模式：</strong> 引脚功能被片上外设接管（如UART_TX、SPI_SCK）。</li></ul><h3 id="2-GPIO-八种工作模式详解"><a href="#2-GPIO-八种工作模式详解" class="headerlink" title="2. GPIO 八种工作模式详解"></a>2. GPIO 八种工作模式详解</h3><p>为了适应不同的电路需求，GPIO 提供了8种可配置模式：</p><h4 id="📥-输入模式-Input"><a href="#📥-输入模式-Input" class="headerlink" title="📥 输入模式 (Input)"></a>📥 输入模式 (Input)</h4><table><thead><tr><th><strong>模式名称</strong></th><th><strong>代码宏定义</strong></th><th><strong>特点</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td><strong>浮空输入</strong></td><td><code>GPIO_Mode_IN_FLOATING</code></td><td>电平完全由外部决定，无上下拉</td><td>外部已有确定电平的信号</td></tr><tr><td><strong>上拉输入</strong></td><td><code>GPIO_Mode_IPU</code></td><td>内部接上拉电阻，默认高电平</td><td><strong>按键检测</strong> (低电平有效)</td></tr><tr><td><strong>下拉输入</strong></td><td><code>GPIO_Mode_IPD</code></td><td>内部接下拉电阻，默认低电平</td><td>检测外部高电平信号</td></tr><tr><td><strong>模拟输入</strong></td><td><code>GPIO_Mode_AIN</code></td><td>关闭数字电路，通道直通ADC</td><td><strong>ADC采样</strong> (电压、温度)</td></tr></tbody></table><h4 id="📤-输出模式-Output"><a href="#📤-输出模式-Output" class="headerlink" title="📤 输出模式 (Output)"></a>📤 输出模式 (Output)</h4><table><thead><tr><th><strong>模式名称</strong></th><th><strong>代码宏定义</strong></th><th><strong>特点</strong></th><th><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td><strong>推挽输出</strong></td><td><code>GPIO_Mode_Out_PP</code></td><td>强驱动能力，可输出高&#x2F;低电平</td><td><strong>LED</strong>、蜂鸣器、一般数字控制</td></tr><tr><td><strong>开漏输出</strong></td><td><code>GPIO_Mode_Out_OD</code></td><td>只能输出低电平，高电平呈高阻态</td><td><strong>I2C总线</strong> (需外接上拉)、电平转换</td></tr><tr><td><strong>复用推挽</strong></td><td><code>GPIO_Mode_AF_PP</code></td><td>由内部外设控制输出</td><td>UART_TX、SPI_MOSI</td></tr><tr><td><strong>复用开漏</strong></td><td><code>GPIO_Mode_AF_OD</code></td><td>由内部外设控制输出</td><td>I2C_SCL&#x2F;SDA</td></tr></tbody></table><blockquote><p><strong>💡 核心原理解析：推挽 (Push-Pull)</strong>   Open-Drain，开漏（Open-Drain）</p><ul><li><strong>结构：</strong> 内部由两个互补的开关管（PMOS+NMOS）构成“上推下挽”结构。</li><li><strong>优势：</strong> 彻底解决了简单开关电路输出高电平时驱动能力弱的问题，使其成为一个主动的、强驱动力的信号源。</li></ul></blockquote><p><strong>复用功能 (AF) 模式</strong>（Alternate Function）：引脚的控制权交给芯片内部的<strong>外设</strong>（Peripheral）</p><h3 id="3-LED-硬件与代码实战"><a href="#3-LED-硬件与代码实战" class="headerlink" title="3. LED 硬件与代码实战"></a>3. LED 硬件与代码实战</h3><p>硬件原理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCU引脚 (High/1) → 限流电阻 → LED → GND (此时LED亮)</span><br></pre></td></tr></table></figure><p><strong>代码：GPIO初始化与控制</strong></p><p><img src="https://5b9e583.webp.li/2026/01/image-20251127205343512.png" alt="image-20251127205343512"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 系统基础配置</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); <span class="comment">// 设置中断优先级分组</span></span><br><span class="line">    SystemCoreClockUpdate(); <span class="comment">// 更新系统时钟频率变量</span></span><br><span class="line">    Delay_Init();            <span class="comment">// 初始化延时函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. GPIO 初始化结构体定义</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 开启外设时钟 (至关重要，否则引脚不工作)</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置参数</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; <span class="comment">// 推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 初始化 GPIOC</span></span><br><span class="line">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOC, GPIO_Pin_2);   <span class="comment">// 输出高电平 (LED亮)</span></span><br><span class="line">        Delay_Ms(<span class="number">500</span>);</span><br><span class="line">        GPIO_ResetBits(GPIOC, GPIO_Pin_2); <span class="comment">// 输出低电平 (LED灭)</span></span><br><span class="line">        Delay_Ms(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、定时器-Timer-配置"><a href="#二、定时器-Timer-配置" class="headerlink" title="二、定时器 (Timer) 配置"></a>二、定时器 (Timer) 配置</h2><h3 id="1-定时器工作原理"><a href="#1-定时器工作原理" class="headerlink" title="1. 定时器工作原理"></a>1. 定时器工作原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">时钟源(CK_PSC) → 预分频器 → 计数器时钟(CK_CNT) → 计数器(CNT) → 自动重装载寄存器(ARR)</span><br><span class="line">                      (PSC)                        (CNT)                (ARR)</span><br><span class="line">                        ↓                            ↓                      ↓</span><br><span class="line">                   对时钟进行N分频               对CK_CNT进行计数         计数到ARR值时产生更新事件(中断/DMA)</span><br></pre></td></tr></table></figure><p>定时器本质上是一个<strong>对脉冲进行计数的计数器</strong>。</p><p>核心流程：</p><p>$$<br>\text{时钟源} \xrightarrow{\text{PSC预分频}} \text{计数时钟} \xrightarrow{\text{CNT计数}} \text{达到ARR值} \xrightarrow{\text{产生更新事件&#x2F;中断}}<br>$$<br>⏱ 定时时间计算公式：</p><p>$$<br>Time &#x3D; \frac{(ARR + 1) \times (PSC + 1)}{T_{clk}}<br>$$</p><ul><li><p><code>ARR</code>: 自动重装载值 (数多少下)</p></li><li><p><code>PSC</code>: 预分频系数 (分频多少)</p></li><li><p>$$<br>T_{clk}: 定时器输入时钟频率<br>$$</p></li></ul><blockquote><p>示例计算：</p><p>假设系统时钟为 96MHz，需要实现 1ms 定时：</p><ul><li><p>设置 PSC &#x3D; 95 (即96分频)，计数频率 &#x3D;<br>$$<br>96MHz &#x2F; (95+1) &#x3D; 1MHz (每1us数一次)<br>$$</p></li><li><p>设置 ARR &#x3D; 999 (数1000次)，总时间 &#x3D;<br>$$<br>1us \times 1000 &#x3D; 1000us &#x3D; 1ms<br>$$<br>。</p></li></ul></blockquote><h3 id="2-标准库配置步骤-TIM2示例"><a href="#2-标准库配置步骤-TIM2示例" class="headerlink" title="2. 标准库配置步骤 (TIM2示例)"></a>2. 标准库配置步骤 (TIM2示例)</h3><p>配置一个定时器通常遵循 <strong>5步法</strong>：</p><ol><li><strong>RCC</strong>：开启定时器时钟。</li><li><strong>TIM_TimeBase</strong>：配置时基单元 (ARR, PSC, 计数模式)。</li><li><strong>TIM_ITConfig</strong>：使能更新中断。</li><li><strong>NVIC</strong>：配置中断优先级通道。</li><li><strong>TIM_Cmd</strong>：开启定时器。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM2_Init</span><span class="params">(u16 arr, u16 psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1. 使能定时器时钟 (TIM2 挂载在 APB1)</span></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. 定时器基本配置</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = arr;       <span class="comment">// ARR: 自动重装载值</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = psc;    <span class="comment">// PSC: 预分频系数</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">// 向上计数</span></span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 使能更新中断</span></span><br><span class="line">    TIM_ITConfig(TIM2, TIM_IT_Update | TIM_IT_Trigger, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置 NVIC</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>; <span class="comment">// 抢占优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;        <span class="comment">// 子优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 启动定时器</span></span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、中断系统-Interrupt-配置"><a href="#三、中断系统-Interrupt-配置" class="headerlink" title="三、中断系统 (Interrupt) 配置"></a>三、中断系统 (Interrupt) 配置</h2><h3 id="1-中断的核心逻辑"><a href="#1-中断的核心逻辑" class="headerlink" title="1. 中断的核心逻辑"></a>1. 中断的核心逻辑</h3><p>中断机制允许CPU暂停当前任务，处理紧急事件，具有<strong>实时性高、效率高、功耗低</strong>的特点。</p><h3 id="2-中断服务函数-ISR-编写规范"><a href="#2-中断服务函数-ISR-编写规范" class="headerlink" title="2. 中断服务函数 (ISR) 编写规范"></a>2. 中断服务函数 (ISR) 编写规范</h3><p><strong>注意：</strong> 对于 WCH (沁恒) 系列单片机，为了实现快速中断上下文切换，通常需要在函数声明后添加 <code>__attribute__((interrupt(&quot;WCH-Interrupt-fast&quot;)))</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main 中调用: TIM2_Init(999, 96-1); // 96MHz下实现1ms中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((interrupt(<span class="string">&quot;WCH-Interrupt-fast&quot;</span>)))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 检查中断标志位</span></span><br><span class="line">    <span class="keyword">if</span>(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 2. 执行用户逻辑 (示例: 1秒翻转一次LED)</span></span><br><span class="line">       <span class="keyword">if</span>(++Timer_1000MS == <span class="number">1000</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          Timer_1000MS = <span class="number">0</span>;</span><br><span class="line">          Led_Flag = !Led_Flag;</span><br><span class="line">          <span class="keyword">if</span>(Led_Flag)</span><br><span class="line">            GPIO_ResetBits(GPIOC, GPIO_Pin_2);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            GPIO_SetBits(GPIOC, GPIO_Pin_2);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 【重要】清除中断标志位 (否则会无限进入中断)</span></span><br><span class="line">    TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-中断配置避坑指南"><a href="#3-中断配置避坑指南" class="headerlink" title="3. 中断配置避坑指南"></a>3. 中断配置避坑指南</h3><ol><li><strong>忘记清除标志位：</strong> 这是新手最常犯的错误，导致程序死在中断里，主循环不执行。</li><li><strong>时钟未使能：</strong> 外设时钟未开启，配置代码无效。</li><li><strong>优先级分组冲突：</strong> 整个工程中 <code>NVIC_PriorityGroupConfig</code> 应该只在 <code>main</code> 开头设置一次，不要在每个模块初始化里重复设置。</li><li><strong>ISR命名错误：</strong> 中断服务函数名必须与启动文件（<code>.s</code>文件）中的向量表定义完全一致。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPIO、定时器与中断实战指南&quot;&gt;&lt;a href=&quot;#GPIO、定时器与中断实战指南&quot; class=&quot;headerlink&quot; title=&quot;GPIO、定时器与中断实战指南&quot;&gt;&lt;/a&gt;GPIO、定时器与中断实战指南&lt;/h1&gt;&lt;p&gt;简介： 本指南系统梳理了嵌入式开发中</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>0.计算机的组成部分与存储结构</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/0.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/0.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:36.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🖥️-嵌入式标准库开发入门"><a href="#🖥️-嵌入式标准库开发入门" class="headerlink" title="🖥️ 嵌入式标准库开发入门"></a>🖥️ 嵌入式标准库开发入门</h1><h2 id="一、计算机的组成部分与存储结构"><a href="#一、计算机的组成部分与存储结构" class="headerlink" title="一、计算机的组成部分与存储结构"></a>一、计算机的组成部分与存储结构</h2><p><img src="https://5b9e583.webp.li/2026/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="计算机组成部分"></p><h3 id="📦-1-计算机三大组成部分"><a href="#📦-1-计算机三大组成部分" class="headerlink" title="📦 1. 计算机三大组成部分"></a>📦 1. 计算机三大组成部分</h3><h4 id="1️⃣-处理器（CPU-MCU）"><a href="#1️⃣-处理器（CPU-MCU）" class="headerlink" title="1️⃣ 处理器（CPU&#x2F;MCU）"></a>1️⃣ <strong>处理器（CPU&#x2F;MCU）</strong></h4><ul><li><strong>作用</strong>：计算机的”大脑”，负责执行指令和处理数据</li><li><strong>组成</strong>：<ul><li>运算单元（ALU）：执行算术和逻辑运算</li><li>控制单元（CU）：控制指令执行流程</li><li>寄存器组：临时存储数据</li></ul></li></ul><h4 id="2️⃣-内存"><a href="#2️⃣-内存" class="headerlink" title="2️⃣ 内存"></a>2️⃣ <strong>内存</strong></h4><ul><li><strong>RAM（随机存储器）</strong>：断电数据丢失，速度快</li><li><strong>ROM（只读存储器）</strong>：断电数据保留，存储程序代码</li><li><strong>Flash</strong>：可擦写的ROM，常用于存储程序</li></ul><h4 id="3️⃣-输入输出设备（I-O）"><a href="#3️⃣-输入输出设备（I-O）" class="headerlink" title="3️⃣ 输入输出设备（I&#x2F;O）"></a>3️⃣ <strong>输入输出设备（I&#x2F;O）</strong></h4><ul><li><strong>输入设备</strong>：按键、传感器、串口接收等</li><li><strong>输出设备</strong>：LED、显示屏、蜂鸣器、串口发送等</li><li><strong>GPIO</strong>：通用输入输出端口，最基本的I&#x2F;O接口</li></ul><h3 id="🗂️-2-计算机存储结构（层次化）"><a href="#🗂️-2-计算机存储结构（层次化）" class="headerlink" title="🗂️ 2. 计算机存储结构（层次化）"></a>🗂️ 2. 计算机存储结构（层次化）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">速度快 ←→ 速度慢</span><br><span class="line">容量小 ←→ 容量大</span><br><span class="line">价格高 ←→ 价格低</span><br><span class="line"></span><br><span class="line">┌─────────────┐</span><br><span class="line">│   寄存器     │ ← 最快，容量最小（几十个字节） cpu直接访问</span><br><span class="line">├─────────────┤</span><br><span class="line">│   缓存Cache  │ ← 很快（KB级别）</span><br><span class="line">├─────────────┤</span><br><span class="line">│   内存RAM    │ ← 较快（MB-GB级别）</span><br><span class="line">├─────────────┤</span><br><span class="line">│  Flash/ROM   │ ← 较慢（MB-GB级别）</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure><hr><h2 id="二、寄存器与库开发方式"><a href="#二、寄存器与库开发方式" class="headerlink" title="二、寄存器与库开发方式"></a>二、寄存器与库开发方式</h2><h3 id="🔧-1-寄存器开发方式"><a href="#🔧-1-寄存器开发方式" class="headerlink" title="🔧 1. 寄存器开发方式"></a>🔧 1. 寄存器开发方式</h3><p><strong>寄存器</strong>是CPU内部的特殊存储单元，直接控制硬件功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Init(void)//1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F;//定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0xF0;//设置定时器模式</span><br><span class="line">TL0 = 0x18;//设置定时初值</span><br><span class="line">TH0 = 0xFC;//设置定时初值</span><br><span class="line">TF0 = 0;//清除TF0标志</span><br><span class="line">TR0 = 1;//定时器0开始计时</span><br><span class="line"></span><br><span class="line">ET0 =1;</span><br><span class="line">EA =1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接操作寄存器示例（以STM32为例）</span></span><br><span class="line"><span class="comment">// 点亮PC13引脚的LED</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x40011010</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">13</span>);  <span class="comment">// 直接操作GPIOC的ODR寄存器</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>✅ 执行效率最高</li><li>✅ 代码体积小</li><li>❌ 可读性差</li><li>❌ 移植性差</li></ul><h3 id="📚-2-标准库开发方式"><a href="#📚-2-标准库开发方式" class="headerlink" title="📚 2. 标准库开发方式"></a>📚 2. 标准库开发方式</h3><p>厂商提供的函数库，封装了寄存器操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准库点亮LED</span></span><br><span class="line">GPIO_SetBits(GPIOC, GPIO_Pin_13);  <span class="comment">// 通过函数操作</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>✅ 可读性好</li><li>✅ 开发效率高</li><li>✅ 易于维护</li><li>❌ 代码体积较大</li><li>❌ 执行效率略低</li></ul><h3 id="🆚-开发方式对比"><a href="#🆚-开发方式对比" class="headerlink" title="🆚 开发方式对比"></a>🆚 开发方式对比</h3><table><thead><tr><th align="center">特性</th><th align="center">寄存器开发</th><th align="center">标准库开发</th></tr></thead><tbody><tr><td align="center">学习难度</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">开发速度</td><td align="center">慢</td><td align="center">快</td></tr><tr><td align="center">代码可读性</td><td align="center">差</td><td align="center">好</td></tr><tr><td align="center">执行效率</td><td align="center">最高</td><td align="center">较高</td></tr><tr><td align="center">适用场景</td><td align="center">资源受限&#x2F;高性能要求</td><td align="center">一般应用开发</td></tr></tbody></table><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🖥️-嵌入式标准库开发入门&quot;&gt;&lt;a href=&quot;#🖥️-嵌入式标准库开发入门&quot; class=&quot;headerlink&quot; title=&quot;🖥️ 嵌入式标准库开发入门&quot;&gt;&lt;/a&gt;🖥️ 嵌入式标准库开发入门&lt;/h1&gt;&lt;h2 id=&quot;一、计算机的组成部分与存储结构&quot;&gt;</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>3.按键原理与消抖实现</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/3.%E6%8C%89%E9%94%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B6%88%E6%8A%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/3.%E6%8C%89%E9%94%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B6%88%E6%8A%96%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:59.528Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="按键原理与消抖实现"><a href="#按键原理与消抖实现" class="headerlink" title="按键原理与消抖实现"></a>按键原理与消抖实现</h1><h2 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h2><p><strong>稳定、准确、高效</strong>地检测按键操作，消除机械抖动，实现复杂的交互逻辑。</p><hr><h2 id="一、-按键物理特性：抖动与电气"><a href="#一、-按键物理特性：抖动与电气" class="headerlink" title="一、 按键物理特性：抖动与电气"></a>一、 按键物理特性：抖动与电气</h2><h3 id="1-机械抖动-Key-Bounce"><a href="#1-机械抖动-Key-Bounce" class="headerlink" title="1. 机械抖动 (Key Bounce)"></a>1. 机械抖动 (Key Bounce)</h3><p>按键在按下和释放瞬间，金属触点由于弹性会产生 <strong>5ms ~ 50ms</strong> 的震荡波形。</p><ul><li><p><strong>后果：</strong> 若不处理，一次按压会被 MCU 误判为多次。</p></li><li><p><strong>对策：</strong> 软件延时消抖 或 状态机&#x2F;边沿检测。</p><p><img src="https://5b9e583.webp.li/2026/01/%E6%8A%96%E5%8A%A8%E5%8E%9F%E7%90%86.png" alt="抖动原理"></p></li></ul><h3 id="2-连接方式"><a href="#2-连接方式" class="headerlink" title="2. 连接方式"></a>2. 连接方式</h3><table><thead><tr><th><strong>方式</strong></th><th><strong>原理</strong></th><th><strong>默认状态</strong></th><th><strong>按下状态</strong></th><th><strong>优点</strong></th></tr></thead><tbody><tr><td><strong>上拉输入</strong></td><td>GPIO 通过电阻接 VCC</td><td>高电平 (1)</td><td>低电平 (0)</td><td><strong>推荐。</strong> 常用，且 MCU 多内置上拉。</td></tr><tr><td><strong>下拉输入</strong></td><td>GPIO 通过电阻接 GND</td><td>低电平 (0)</td><td>高电平 (1)</td><td>较少使用，视电路需求而定。</td></tr></tbody></table><hr><h2 id="二、-核心算法：从延时到三行代码消抖"><a href="#二、-核心算法：从延时到三行代码消抖" class="headerlink" title="二、 核心算法：从延时到三行代码消抖"></a>二、 核心算法：从延时到三行代码消抖</h2><h3 id="1-基础延时消抖（阻塞式）"><a href="#1-基础延时消抖（阻塞式）" class="headerlink" title="1. 基础延时消抖（阻塞式）"></a>1. 基础延时消抖（阻塞式）</h3><p><strong>原理：</strong> 发现电平变化 -&gt; 延时 10ms -&gt; 再次确认。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key_down == <span class="number">0</span>) &#123; </span><br><span class="line">    Delay_ms(<span class="number">10</span>); <span class="comment">// 避开抖动区</span></span><br><span class="line">    <span class="keyword">if</span> (key_down == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 确认按下，执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>缺点：</strong> <code>Delay</code> 会卡死 CPU，无法处理多任务，无法识别长按。</li></ul><h3 id="2-边沿检测（三行代码算法）"><a href="#2-边沿检测（三行代码算法）" class="headerlink" title="2. 边沿检测（三行代码算法）"></a>2. 边沿检测（三行代码算法）</h3><p><strong>核心公式：</strong> 利用异或 (<code>^</code>) 捕捉电平跳变，利用与 (<code>&amp;</code>) 区分方向。</p><h4 id="核心思想：只在电平跳变时触发一次动作"><a href="#核心思想：只在电平跳变时触发一次动作" class="headerlink" title="核心思想：只在电平跳变时触发一次动作"></a>核心思想：<strong>只在电平跳变时触发一次动作</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key_val  = key_read();</span><br><span class="line">key_val ^ key_old  //这里只是捕获边沿 0000 0000  ^ 0000 0101 = 0000 0101</span><br><span class="line">key_old =  key_val;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量：当前值, 上次值, 下降沿(按下), 上升沿(释放)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key_val, key_old, key_down, key_up;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">key_proc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    key_val = key_read();              <span class="comment">// 1. 读取当前键值</span></span><br><span class="line">    key_down = key_val &amp; (key_val ^ key_old); <span class="comment">// 2. 检测下降沿（0-&gt;1）</span></span><br><span class="line">    key_up = ~key_val &amp; (key_val ^ key_old);  <span class="comment">// 3. 检测上升沿（1-&gt;0）</span></span><br><span class="line">    key_old = key_val;                 <span class="comment">// 4. 更新旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong> 公式中的逻辑（0&#x2F;1）取决于你的 <code>key_read()</code> 返回值。若按下为 1，则上述公式适用。</p></blockquote><hr><h2 id="三、-实战演练：蓝桥杯（51单片机）"><a href="#三、-实战演练：蓝桥杯（51单片机）" class="headerlink" title="三、 实战演练：蓝桥杯（51单片机）"></a>三、 实战演练：蓝桥杯（51单片机）</h2><p>蓝桥杯 CT117E 开发板常涉及 <strong>4x4 矩阵键盘</strong>。</p><h3 id="1-矩阵扫描逻辑"><a href="#1-矩阵扫描逻辑" class="headerlink" title="1. 矩阵扫描逻辑"></a>1. 矩阵扫描逻辑</h3><p>通过“行扫描”法：依次拉低每一行，检测列线电平。</p><p><img src="https://5b9e583.webp.li/2026/01/image-20251002121006962.png" alt="image-20251002121006962"></p><p><strong>原理图说明</strong>（4×4 矩阵键盘）：</p><ul><li>行线（P44, P42, P35, P34）逐个输出低电平</li><li>列线（P30~P33）读取输入电平</li><li>通过行扫描识别具体按键</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 示例：拉低第1行 (P44)，其余拉高</span></span><br><span class="line">    P44 = <span class="number">0</span>; P42 = <span class="number">1</span>; P35 = <span class="number">1</span>; P34 = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (P33 == <span class="number">0</span>) temp = <span class="number">4</span>; <span class="comment">// 第一行第一列</span></span><br><span class="line">    <span class="keyword">if</span> (P32 == <span class="number">0</span>) temp = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// ... 依次类推扫描其他行 ...</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、-实战演练：智能门锁（STM32）"><a href="#四、-实战演练：智能门锁（STM32）" class="headerlink" title="四、 实战演练：智能门锁（STM32）"></a>四、 实战演练：智能门锁（STM32）</h2><p>在 STM32 中，通常使用 HAL 库或标准库进行 GPIO 操作。</p><p><img src="https://5b9e583.webp.li/2026/01/%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="原理图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> *  OUT PP  输入</span><br><span class="line">R4  PD11</span><br><span class="line">R3  PD9</span><br><span class="line">R2  PE15</span><br><span class="line">R1  PE13</span><br><span class="line"></span><br><span class="line"> *  IPU  输出</span><br><span class="line">C1 PE11</span><br><span class="line">C2 PE9</span><br><span class="line">C3 PE7</span><br><span class="line">C4 PC5</span><br></pre></td></tr></table></figure><h3 id="1-GPIO-初始化（上拉输入）"><a href="#1-GPIO-初始化（上拉输入）" class="headerlink" title="1. GPIO 初始化（上拉输入）"></a>1. GPIO 初始化（上拉输入）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_9 | GPIO_Pin_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">// 上拉输入</span></span><br><span class="line">    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp = <span class="number">0</span>;</span><br><span class="line">   GPIO_ResetBits(GPIOD, GPIO_Pin_11);GPIO_SetBits(GPIOD, GPIO_Pin_9);GPIO_SetBits(GPIOE, GPIO_Pin_15);GPIO_SetBits(GPIOE, GPIO_Pin_13);</span><br><span class="line">   <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_11) == <span class="number">0</span>)  temp = <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_9) == <span class="number">0</span>)   temp = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_7) == <span class="number">0</span>)   temp = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5) == <span class="number">0</span>)   temp = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*省略部分代码*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-密码校验逻辑"><a href="#2-密码校验逻辑" class="headerlink" title="2. 密码校验逻辑"></a>2. 密码校验逻辑</h3><p>通过数组对比实现密码比对。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">u8 password[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//原始密码</span></span><br><span class="line">u8 password_cmd[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;<span class="comment">//管理员密码</span></span><br><span class="line">u8 key_temp[<span class="number">6</span>]= &#123;<span class="number">0</span>&#125;;<span class="comment">//密码暂存区</span></span><br><span class="line">u8 key_index;<span class="comment">//密码索引值</span></span><br><span class="line">u8 key_index_old;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串/数组比对函数</span></span><br><span class="line">u8 <span class="title function_">string_check</span><span class="params">(u8* str1, u8* str2, u8 len)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[len] != str2[len]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只要有一位不等则返回失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 全相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认键逻辑 (Case 16)</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">    <span class="keyword">if</span>(string_check(key_temp, password, <span class="number">6</span>)) &#123;</span><br><span class="line">        Lock(<span class="number">0</span>);          <span class="comment">// 开锁</span></span><br><span class="line">        audio_play(SUCCESS_VOICE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Lock(<span class="number">1</span>);          <span class="comment">// 锁定/报警</span></span><br><span class="line">        audio_play(FAIL_VOICE);</span><br><span class="line">    &#125;</span><br><span class="line">    key_index = <span class="number">0</span>;        <span class="comment">// 清空输入索引</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="五、-经验总结与-API-避坑"><a href="#五、-经验总结与-API-避坑" class="headerlink" title="五、 经验总结与 API 避坑"></a>五、 经验总结与 API 避坑</h2><ol><li><strong>解耦思想：</strong> 在 <code>lcd_proc</code> 中使用中间变量 <code>i = key_index</code> 进行显示，防止在显示过程中 <code>key_index</code> 被中断或快速按键修改导致花屏。</li><li><strong>API 迁移：</strong> * <strong>旧库：</strong> <code>GPIO_ReadInputDataBit</code><ul><li><strong>新 HAL 库：</strong> <code>HAL_GPIO_ReadPin</code></li></ul></li><li><strong>硬件常识：</strong> 51 单片机（如 STC15）IO 口默认是弱上拉模式，按键通常一端接地，一端接 IO。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;按键原理与消抖实现&quot;&gt;&lt;a href=&quot;#按键原理与消抖实现&quot; class=&quot;headerlink&quot; title=&quot;按键原理与消抖实现&quot;&gt;&lt;/a&gt;按键原理与消抖实现&lt;/h1&gt;&lt;h2 id=&quot;核心目标&quot;&gt;&lt;a href=&quot;#核心目标&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>5.串口通信（音频控制+刷卡模块）</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/5.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(%E9%9F%B3%E9%A2%91%E6%8E%A7%E5%88%B6+%E5%88%B7%E5%8D%A1%E6%A8%A1%E5%9D%97)/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/5.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(%E9%9F%B3%E9%A2%91%E6%8E%A7%E5%88%B6+%E5%88%B7%E5%8D%A1%E6%A8%A1%E5%9D%97)/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:44:46.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32-串口通信-USART-学习笔记"><a href="#STM32-串口通信-USART-学习笔记" class="headerlink" title="STM32 串口通信 (USART) 学习笔记"></a>STM32 串口通信 (USART) 学习笔记</h1><h2 id="1-串口-USART-基础概念"><a href="#1-串口-USART-基础概念" class="headerlink" title="1. 串口 (USART) 基础概念"></a>1. 串口 (USART) 基础概念</h2><p>串口是一种<strong>异步串行通信协议</strong>，用于点对点设备间通信。STM32中的USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）比标准UART功能更强大，支持同步和异步模式。</p><h3 id="STM32-USART-与-8051-UART-对比"><a href="#STM32-USART-与-8051-UART-对比" class="headerlink" title="STM32 USART 与 8051 UART 对比"></a>STM32 USART 与 8051 UART 对比</h3><table><thead><tr><th>特性</th><th>STM32 USART</th><th>8051 UART</th></tr></thead><tbody><tr><td><strong>时钟源</strong></td><td>多种时钟源可选(PCLK1&#x2F;2, HSI, LSE等)</td><td>通常使用定时器2作为波特率发生器</td></tr><tr><td><strong>波特率</strong></td><td>硬件自动计算，配置灵活</td><td>需要手动计算定时器初值</td></tr><tr><td><strong>DMA支持</strong></td><td>完整支持DMA传输</td><td>高级型号才支持</td></tr><tr><td><strong>多串口支持</strong></td><td>通常有多个USART&#x2F;UART接口</td><td>通常只有一个UART</td></tr><tr><td><strong>中断向量</strong></td><td>每个USART有独立的中断向量</td><td>所有串口共享一个中断向量</td></tr><tr><td><strong>配置方式</strong></td><td>通过结构体配置，HAL库&#x2F;标准库支持</td><td>直接操作寄存器</td></tr><tr><td><strong>流控制</strong></td><td>支持硬件流控制(RTS&#x2F;CTS)</td><td>通常不支持</td></tr></tbody></table><h2 id="2-STM32-USART-初始化详解"><a href="#2-STM32-USART-初始化详解" class="headerlink" title="2. STM32 USART 初始化详解"></a>2. STM32 USART 初始化详解</h2><h3 id="硬件初始化流程"><a href="#硬件初始化流程" class="headerlink" title="硬件初始化流程"></a>硬件初始化流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[使能时钟] --&gt; B[配置GPIO]</span><br><span class="line">    B --&gt; C[配置USART参数]</span><br><span class="line">    C --&gt; D[配置中断]</span><br><span class="line">    D --&gt; E[使能USART]</span><br></pre></td></tr></table></figure><p><img src="https://5b9e583.webp.li/2025/12/20251230112518949.png"></p><p>使用这个语音模块的目标 只需要向他发送数据 然后发出相应的语音即可</p><p>使用刷卡模块时 只需要接收数据 然后单片机对于接收的数据进行处理</p><h3 id="代码实现与解析"><a href="#代码实现与解析" class="headerlink" title="代码实现与解析"></a>代码实现与解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usart3_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef  GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    USART_InitTypeDef USART_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    NVIC_InitTypeDef  NVIC_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 1. 使能外设时钟</span></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">    <span class="comment">// 2. 配置USART3的GPIO引脚 (TX: PB10, RX: PB11)</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; <span class="comment">// 复用推挽输出</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">// 浮空输入</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">    <span class="comment">// 3. 配置USART3工作参数</span></span><br><span class="line">    USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">    USART_Init(USART3, &amp;USART_InitStructure);</span><br><span class="line">    <span class="comment">// 4. 配置USART3接收中断</span></span><br><span class="line">    USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">    <span class="comment">// 5. 使能USART3并清除发送完成标志</span></span><br><span class="line">    USART_Cmd(USART3, ENABLE);</span><br><span class="line">    USART_ClearFlag(USART3, USART_FLAG_TC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除发送完成标志(USART_FLAG_TC)防止首次发送数据丢失</p><h2 id="3-中断服务函数实现"><a href="#3-中断服务函数实现" class="headerlink" title="3. 中断服务函数实现"></a>3. 中断服务函数实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> data = USART_ReceiveData(USART3);</span><br><span class="line">        <span class="comment">// 处理接收数据...</span></span><br><span class="line">        USART_ClearITPendingBit(USART3, USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART3, USART_IT_TC) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 发送完成处理</span></span><br><span class="line">        USART_ClearITPendingBit(USART3, USART_FLAG_TC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断类型说明"><a href="#中断类型说明" class="headerlink" title="中断类型说明"></a>中断类型说明</h3><ol><li><strong>接收中断 (RXNE)</strong>：接收数据寄存器非空</li><li><strong>发送中断 (TC)</strong>：发送完成</li><li><strong>发送中断 (TXE)</strong>：发送数据寄存器空</li></ol><p>不管数据接收还是数据发送都有三种方式   1.轮询方式 2.中断方式 3.DMA方式</p><h2 id="4-数据发送与接收方式"><a href="#4-数据发送与接收方式" class="headerlink" title="4. 数据发送与接收方式"></a>4. 数据发送与接收方式</h2><h3 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h3><h3 id="音频模块控制（串口发送）"><a href="#音频模块控制（串口发送）" class="headerlink" title="音频模块控制（串口发送）"></a>音频模块控制（串口发送）</h3><p><img src="https://5b9e583.webp.li/2026/01/%E4%B8%B2%E5%8F%A3%E5%8D%8F%E8%AE%AE.png" alt="串口协议"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">audio_play</span><span class="params">(u8 num)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 <span class="built_in">array</span>[] = &#123;<span class="number">0x7e</span>,<span class="number">0x05</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,num,<span class="number">0x05</span>^<span class="number">0x41</span>^<span class="number">0x00</span>^num,<span class="number">0xef</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(u8 i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        USART_SendData(USART3, <span class="built_in">array</span>[i]);<span class="comment">// 写入数据寄存器</span></span><br><span class="line">        <span class="keyword">while</span>(USART_GetFlagStatus(USART3, USART_FLAG_TC) == <span class="number">0</span>); <span class="comment">// 等待发送完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1按键音效：</span><br><span class="line">2门已上锁，请刷卡或输入密码解锁</span><br><span class="line">3密码正确，门已打开，欢迎回家</span><br><span class="line">4密码错误，请重新输入</span><br><span class="line">5连续三次输入密码错误，已锁定，请等待30秒后重新输入</span><br><span class="line">6修改开锁密码，请输入管理员密码</span><br><span class="line">7管理员密码验证成功，请输入新密码</span><br><span class="line">8新密码设置成功</span><br><span class="line">9管理员密码错误，请重新输入</span><br><span class="line">10连续三次输入管理员密码错误，已锁定，请等待30秒后重新输入</span><br><span class="line">11刷卡成功，门已开启，欢迎回家</span><br><span class="line">12刷卡失败，请重试</span><br><span class="line">13录入卡片，请输入管理员密码</span><br><span class="line">14管理员密码验证成功，请将卡片平放在传感器上</span><br><span class="line">15卡片添加成功</span><br><span class="line">16指纹验证成功，门已开启，欢迎回家</span><br><span class="line">17指纹验证失败，请重试</span><br><span class="line">18录入指纹，请输入管理员密码</span><br><span class="line">19管理员密码验证成功，请将手指平放在传感器上</span><br></pre></td></tr></table></figure><h2 id="6-常见问题与解决方案"><a href="#6-常见问题与解决方案" class="headerlink" title="6. 常见问题与解决方案"></a>6. 常见问题与解决方案</h2><h3 id="问题1语音模块接到单片机上-没有声音，猜测数据发送错误，然后把单片机接到USB转TTL模块-看他发出什么数据，"><a href="#问题1语音模块接到单片机上-没有声音，猜测数据发送错误，然后把单片机接到USB转TTL模块-看他发出什么数据，" class="headerlink" title="问题1语音模块接到单片机上 没有声音，猜测数据发送错误，然后把单片机接到USB转TTL模块 看他发出什么数据，"></a>问题1语音模块接到单片机上 没有声音，猜测数据发送错误，然后把单片机接到USB转TTL模块 看他发出什么数据，</h3><h3 id="首次发送数据丢失"><a href="#首次发送数据丢失" class="headerlink" title="首次发送数据丢失"></a>首次发送数据丢失</h3><p><strong>原因</strong>：发送完成标志(USART_FLAG_TC)未被清除<br><strong>解决方案</strong>：在初始化后清除TC标志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USART_ClearFlag(USART3, USART_FLAG_TC);</span><br></pre></td></tr></table></figure><h2 id="7-与8051串口的实现差异"><a href="#7-与8051串口的实现差异" class="headerlink" title="7. 与8051串口的实现差异"></a>7. 与8051串口的实现差异</h2><table><thead><tr><th>方面</th><th>STM32实现</th><th>8051实现</th></tr></thead><tbody><tr><td><strong>初始化</strong></td><td>结构体配置，库函数封装</td><td>直接操作寄存器</td></tr><tr><td><strong>中断处理</strong></td><td>每个USART有独立中断向量</td><td>共享中断向量</td></tr><tr><td><strong>数据收发</strong></td><td>专用函数</td><td>直接读写SBUF寄存器</td></tr><tr><td><strong>波特率</strong></td><td>硬件自动计算</td><td>手动计算定时器初值</td></tr><tr><td><strong>多串口</strong></td><td>天然支持多串口</td><td>通常只有一个UART</td></tr></tbody></table><p>在这里语音模块用的是串口发送  而刷卡模块用的是串口接收 本来是可以一个串口使用两个模块</p><p>但是两个的波特率不一样 所以就换一个串口 换成串口2</p><p>刷卡模块</p><p><img src="C:\Users\RoseLin\AppData\Roaming\Typora\typora-user-images\刷卡模块参数.png" alt="刷卡模块参数"></p><p><img src="C:\Users\RoseLin\AppData\Roaming\Typora\typora-user-images\卡号.png" alt="卡号"></p><p>思路是先直接连接USB转TTL 看实际发出来的数据 然后在找到数据手册进行分析</p><p><img src="C:\Users\RoseLin\AppData\Roaming\Typora\typora-user-images\读卡模式.png" alt="读卡模式"></p><p>配置是一样的</p><p><img src="https://5b9e583.webp.li/2025/12/20251230111256028.png"></p><p><img src="C:\Users\RoseLin\AppData\Roaming\Typora\typora-user-images\image-20260107155336561.png" alt="image-20260107155336561">g)</p><p>数据包该如何接收？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hellow/r/n&quot;</span>)<span class="comment">//一定要加上/r/n才能打印</span></span><br></pre></td></tr></table></figure><p>每次使用中断都需要声明一下这个函数 为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void USART3_IRQHandler(void) __attribute__((interrupt(&quot;WCH-Interrupt-fast&quot;)));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32-串口通信-USART-学习笔记&quot;&gt;&lt;a href=&quot;#STM32-串口通信-USART-学习笔记&quot; class=&quot;headerlink&quot; title=&quot;STM32 串口通信 (USART) 学习笔记&quot;&gt;&lt;/a&gt;STM32 串口通信 (USART) 学习</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>4.spi协议（LCD驱动）</title>
    <link href="https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/4.SPI%20%E5%8D%8F%E8%AE%AE%EF%BC%88LCD%20%E9%A9%B1%E5%8A%A8%EF%BC%89/"/>
    <id>https://rosslin.xyz/2025/12/22/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/4.SPI%20%E5%8D%8F%E8%AE%AE%EF%BC%88LCD%20%E9%A9%B1%E5%8A%A8%EF%BC%89/</id>
    <published>2025-12-22T02:00:00.000Z</published>
    <updated>2026-01-27T15:44:07.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPI-协议（LCD-驱动）"><a href="#SPI-协议（LCD-驱动）" class="headerlink" title="SPI 协议（LCD 驱动）"></a>SPI 协议（LCD 驱动）</h1><p>本文档记录了 SPI 通信协议的基础知识，并结合 WCH 单片机实际代码，深入剖析如何利用 SPI 接口驱动 ST7735S LCD 显示屏。</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>驱动开发采用分层架构思想，将应用逻辑与硬件实现解耦。</p><h3 id="三层关系图"><a href="#三层关系图" class="headerlink" title="三层关系图"></a>三层关系图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────┐</span><br><span class="line">│  应用层：LCD显示功能 (LCD_Fill, LCD_ShowString) │</span><br><span class="line">│  ├─ 硬件功能：填充、画点、显示字符/汉字/数字  │</span><br><span class="line">│  ├─ 控制逻辑：调用协议层函数实现复杂绘图      │</span><br><span class="line">│  └─ 数据源：字库、图片数组                  │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  通信层：SPI协议与LCD指令集封装             │</span><br><span class="line">│  ├─ 核心函数：LCD_WR_REG, LCD_WR_DATA      │</span><br><span class="line">│  ├─ 地址设置：LCD_Address_Set (关键适配点)    │</span><br><span class="line">│  └─ 初始化序列：LCD_Init (完全依赖芯片手册)    │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  硬件层：WCH单片机GPIO与SPI3外设             │</span><br><span class="line">│  ├─ SPI外设：spi_readwrite (核心读写函数)    │</span><br><span class="line">│  ├─ 控制引脚：PA15(CS), PD4(DC), PD5(BL)    │</span><br><span class="line">│  └─ SPI引脚：PB3(SCK), PB5(MOSI)           │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="架构类比"><a href="#架构类比" class="headerlink" title="架构类比"></a>架构类比</h3><table><thead><tr><th><strong>层次</strong></th><th><strong>负责内容</strong></th><th><strong>实际代码实例</strong></th></tr></thead><tbody><tr><td><strong>应用层</strong></td><td>实现最终用户可见的显示效果</td><td><code>LCD_Fill()</code>, <code>LCD_ShowString()</code>, <code>LCD_DrawLine()</code></td></tr><tr><td><strong>通信层</strong></td><td>封装与 LCD 驱动芯片的交互逻辑，是移植的关键</td><td><code>LCD_WR_REG()</code>, <code>LCD_WR_DATA()</code>, <code>LCD_Init()</code></td></tr><tr><td><strong>硬件层</strong></td><td>驱动单片机的 SPI 硬件外设，高度可复用</td><td><code>SPI_LCD_Init()</code>, <code>spi_readwrite()</code></td></tr></tbody></table><hr><h2 id="1-SPI-通信协议基础"><a href="#1-SPI-通信协议基础" class="headerlink" title="1. SPI 通信协议基础"></a>1. SPI 通信协议基础</h2><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/spi%E5%8D%8F%E8%AE%AE.png" alt="spi协议"></p><p>SPI (Serial Peripheral Interface) 是一种同步、全双工、主从架构的高速串行通信总线。</p><h3 id="核心信号线"><a href="#核心信号线" class="headerlink" title="核心信号线"></a>核心信号线</h3><ul><li><strong>SCK (Serial Clock)</strong>: 串行时钟线，由主设备产生，同步数据传输。</li><li><strong>MOSI (Master Out Slave In)</strong>: 主设备输出，从设备输入。</li><li><strong>MISO (Master In Slave Out)</strong>: 主设备输入，从设备输出（驱动 LCD 时通常不接或只用于读 ID）。</li><li><strong>CS&#x2F;SS (Chip Select)</strong>: 片选信号，低电平有效。</li></ul><h3 id="通信模式-CPOL-CPHA"><a href="#通信模式-CPOL-CPHA" class="headerlink" title="通信模式 (CPOL &amp; CPHA)"></a>通信模式 (CPOL &amp; CPHA)</h3><p>SPI 的关键在于时钟极性 (CPOL) 和相位 (CPHA) 的配置。</p><table><thead><tr><th><strong>模式</strong></th><th><strong>CPOL (空闲电平)</strong></th><th><strong>CPHA (采样边沿)</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>Mode 0</strong></td><td><strong>0 (Low)</strong></td><td><strong>0 (1st Edge)</strong></td><td><strong>SCK 低电平空闲，第一个边沿（上升沿）采样</strong></td></tr><tr><td>Mode 1</td><td>0 (Low)</td><td>1 (2nd Edge)</td><td>SCK 低电平空闲，第二个边沿采样</td></tr><tr><td>Mode 2</td><td>1 (High)</td><td>0 (1st Edge)</td><td>SCK 高电平空闲，第一个边沿采样</td></tr><tr><td>Mode 3</td><td>1 (High)</td><td>1 (2nd Edge)</td><td>SCK 高电平空闲，第二个边沿采样</td></tr></tbody></table><blockquote><p><strong>注意</strong>：实际代码必须配置为 <code>SPI_CPOL_Low</code> 和 <code>SPI_CPHA_1Edge</code> (Mode 0) 以匹配 ST7735S 芯片手册。</p></blockquote><hr><h2 id="2-🔌-硬件层实现-WCH-STM32"><a href="#2-🔌-硬件层实现-WCH-STM32" class="headerlink" title="2. 🔌 硬件层实现 (WCH&#x2F;STM32)"></a>2. 🔌 硬件层实现 (WCH&#x2F;STM32)</h2><h3 id="2-1-硬件连接与引脚定义"><a href="#2-1-硬件连接与引脚定义" class="headerlink" title="2.1 硬件连接与引脚定义"></a>2.1 硬件连接与引脚定义</h3><p>WCH 单片机作为主机，ST7735S 为从机。</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20250921161037976.png" alt="image-20250921161037976"></p><p>硬件连接： RES接到了PB4  BLK接3.3V</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251219205217382.png"></p><table><thead><tr><th><strong>功能</strong></th><th><strong>符号</strong></th><th><strong>单片机引脚</strong></th><th><strong>模式配置</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>片选</td><td><strong>CS</strong></td><td>PD4</td><td>推挽输出</td><td>低电平选中 LCD</td></tr><tr><td>数据&#x2F;命令</td><td><strong>DC</strong></td><td>PD3</td><td>推挽输出</td><td><strong>0: 写命令, 1: 写数据</strong> (核心控制位)</td></tr><tr><td>背光</td><td><strong>BL</strong></td><td>PD5(GND)</td><td>推挽输出</td><td>高电平亮，低电平灭</td></tr><tr><td>时钟</td><td><strong>SCL</strong></td><td>PB3</td><td><strong>复用</strong>推挽输出</td><td>SPI 硬件时钟</td></tr><tr><td>主出从入</td><td><strong>MOSI</strong>(SDA)</td><td>PB5</td><td><strong>复用</strong>推挽输出</td><td>SPI 数据发送</td></tr><tr><td>复位</td><td><strong>RES</strong></td><td>PB4</td><td>推挽输出</td><td>硬件复位引脚</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 SPI_LCD_Init() 中</span></span><br><span class="line"><span class="comment">// CS  -&gt; PA15 (GPIO_Mode_Out_PP)</span></span><br><span class="line"><span class="comment">// DC  -&gt; PD3  (GPIO_Mode_Out_PP)</span></span><br><span class="line"><span class="comment">// BL  -&gt; PD5  (GPIO_Mode_Out_PP)</span></span><br><span class="line"><span class="comment">// SCK -&gt; PB3  (GPIO_Mode_AF_PP)</span></span><br><span class="line"><span class="comment">// MISO-&gt; PB4  (GPIO_Mode_Out_PP) // 注意：实际代码MISO配置为输出，对于只写LCD是可行的</span></span><br><span class="line"><span class="comment">// MOSI-&gt; PB5  (GPIO_Mode_AF_PP)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化代码-SPI-LCD-Init"><a href="#2-2-初始化代码-SPI-LCD-Init" class="headerlink" title="2.2 初始化代码 (SPI_LCD_Init)"></a>2.2 初始化代码 (SPI_LCD_Init)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPI_LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    SPI_InitTypeDef  SPI_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD, ENABLE );</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. CS DC BL 端口初始化 (普通推挽输出)</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5; </span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   </span><br><span class="line">    GPIO_Init(GPIOD, &amp;GPIO_InitStructure);              </span><br><span class="line">    GPIO_SetBits(GPIOD, GPIO_Pin_3);   <span class="comment">// DC</span></span><br><span class="line">    GPIO_SetBits(GPIOD, GPIO_Pin_4);   <span class="comment">// CS (默认拉高，不选中)</span></span><br><span class="line">    GPIO_SetBits(GPIOD, GPIO_Pin_5);   <span class="comment">// BL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. SPI 引脚初始化 (SCK, MOSI 使用复用推挽)</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; <span class="comment">// SCK</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; </span><br><span class="line">    GPIO_Init( GPIOB, &amp;GPIO_InitStructure );</span><br><span class="line"></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; <span class="comment">// MOSI</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; </span><br><span class="line">    GPIO_Init( GPIOB, &amp;GPIO_InitStructure );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MISO (PB4) 和 PA15 (原有代码残留) 可根据实际需求配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. SPI3 参数配置</span></span><br><span class="line">    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; <span class="comment">// 双线全双工</span></span><br><span class="line">    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;                      <span class="comment">// 主机模式</span></span><br><span class="line">    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                  <span class="comment">// 8位数据</span></span><br><span class="line">    SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;                         <span class="comment">// 时钟极性低</span></span><br><span class="line">    SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;                       <span class="comment">// 第1个边沿采样</span></span><br><span class="line">    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;                          <span class="comment">// 软件片选</span></span><br><span class="line">    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4; <span class="comment">// 4分频</span></span><br><span class="line">    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;                 <span class="comment">// 高位在前</span></span><br><span class="line">    SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI3, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">    SPI_Cmd(SPI3, ENABLE); <span class="comment">// 使能 SPI3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-底层读写函数-spi-readwrite"><a href="#2-3-底层读写函数-spi-readwrite" class="headerlink" title="2.3 底层读写函数 (spi_readwrite)"></a>2.3 底层读写函数 (spi_readwrite)</h3><p><strong>【授人以渔】</strong>：这是硬件层的核心，增加了超时机制，防止程序死锁，增强鲁棒性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">spi_readwrite</span><span class="params">(u8 TxData)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待发送缓冲区空</span></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) == RESET) &#123; </span><br><span class="line">        i++; <span class="keyword">if</span>(i&gt;<span class="number">200</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 超时处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    SPI_I2S_SendData(SPI3, TxData);</span><br><span class="line">    </span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 等待接收缓冲区非空</span></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE) == RESET) &#123; </span><br><span class="line">        i++; <span class="keyword">if</span>(i&gt;<span class="number">200</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 超时处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-通信驱动层-LCD-Driver"><a href="#3-通信驱动层-LCD-Driver" class="headerlink" title="3. 通信驱动层 (LCD Driver)"></a>3. 通信驱动层 (LCD Driver)</h2><h3 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h3><p>通过 <strong>DC (Data&#x2F;Command)</strong> 引脚区分 SPI 发送的是指令还是数据。</p><ul><li><code>DC = 0</code>: 发送指令</li><li><code>DC = 1</code>: 发送数据</li></ul><h3 id="核心写函数"><a href="#核心写函数" class="headerlink" title="核心写函数"></a>核心写函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写指令</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_REG</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;</span><br><span class="line">    LCD_CS_Clr();</span><br><span class="line">    LCD_DC_Clr(); <span class="comment">// ⭐ 核心：DC=0</span></span><br><span class="line">    spi_readwrite(dat);</span><br><span class="line">    LCD_CS_Set();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写16位数据 (像素颜色通常为16位 RGB565)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span> </span><br><span class="line">&#123;</span><br><span class="line">    LCD_CS_Clr();</span><br><span class="line">    LCD_DC_Set(); <span class="comment">// ⭐ 核心：DC=1</span></span><br><span class="line">    spi_readwrite(dat&gt;&gt;<span class="number">8</span>); <span class="comment">// ⭐ 关键：分两次发送，高8位在前</span></span><br><span class="line">    spi_readwrite(dat);    <span class="comment">// 低8位在后</span></span><br><span class="line">    LCD_CS_Set();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-应用层与-UI-实战"><a href="#4-应用层与-UI-实战" class="headerlink" title="4.  应用层与 UI 实战"></a>4.  应用层与 UI 实战</h2><h3 id="4-1-字符串显示封装"><a href="#4-1-字符串显示封装" class="headerlink" title="4.1 字符串显示封装"></a>4.1 字符串显示封装</h3><p>原厂驱动通常只提供单个汉字显示 (<code>LCD_ShowChinese</code>)。为了方便开发，封装了支持自动换行的字符串显示函数。</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251219215915518.png" alt="文字取模"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">      函数说明：显示多个汉字 (支持自动换行)</span></span><br><span class="line"><span class="comment">      入口数据：x, y 坐标, *s 字符串, fc 前景色, bc 背景色, sizey 字号, mode 模式</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LcdShowTest</span><span class="params">(u16 x, u16 y, u8 *s, u16 fc, u16 bc, u8 sizey, u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s)</span><br><span class="line">    &#123;</span><br><span class="line">        LCD_ShowChinese(x, y, s, fc, bc, sizey, mode);</span><br><span class="line">        x += <span class="number">16</span>; <span class="comment">// 假设字宽16</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">127</span>)&#123; <span class="comment">// 到达行尾 (128像素宽度)，换行</span></span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y += <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="number">2</span>; <span class="comment">// 汉字占2字节 (GBK)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-效果演示：开机进度条"><a href="#4-2-效果演示：开机进度条" class="headerlink" title="4.2 效果演示：开机进度条"></a>4.2 效果演示：开机进度条</h3><p>利用画线函数 (<code>LCD_DrawLine</code>) 实现动态进度条。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LcdShowTest(<span class="number">35</span>, <span class="number">56</span>, <span class="string">&quot;正在启动&quot;</span>, BLUE, WHITE, <span class="number">16</span>, <span class="number">0</span>); <span class="comment">// 显示提示</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">128</span>) <span class="comment">// 循环划线</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD_DrawLine(i, <span class="number">100</span>, i, <span class="number">127</span>, RED);</span><br><span class="line">    Delay_Ms(<span class="number">10</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">LcdShowTest(<span class="number">35</span>, <span class="number">56</span>, <span class="string">&quot;启动成功&quot;</span>, BLUE, WHITE, <span class="number">16</span>, <span class="number">0</span>); <span class="comment">// 成功提示</span></span><br><span class="line">Delay_Ms(<span class="number">500</span>);</span><br></pre></td></tr></table></figure><h3 id="4-3-图片显示注意事项"><a href="#4-3-图片显示注意事项" class="headerlink" title="4.3 图片显示注意事项"></a>4.3 图片显示注意事项</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251219220643064.png" alt="图片取模"> </p><ol><li><p><strong>设置</strong>:</p><ul><li>输出数据类型：C 语言数组</li><li>扫描模式：水平扫描&#x2F;垂直扫描需与 <code>LCD_Address_Set</code> 匹配</li><li><strong>重要</strong>: 不要勾选“包含图像头数据”，否则数据冗余会导致花屏。</li><li>只支持GIF格式   在ps上操作成为GIF</li></ul></li><li><p><strong>头文件</strong>: 新建 <code>picture.h</code> 存放数组，主程序中引用。</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251219220300671.png" alt="效果图"></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例调用</span></span><br><span class="line">LCD_ShowPicture(<span class="number">0</span>, <span class="number">0</span>, <span class="number">128</span>, <span class="number">128</span>, gImage_1111);</span><br></pre></td></tr></table></figure><hr><h2 id="关键移植点总结"><a href="#关键移植点总结" class="headerlink" title="关键移植点总结"></a>关键移植点总结</h2><p>从一套代码移植到新硬件时的检查清单：</p><p>移植需要注意添加路径</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251219213212006.png" alt="添加路径"></p><table><thead><tr><th><strong>代码模块</strong></th><th><strong>层次</strong></th><th><strong>移植属性</strong></th><th><strong>修改要点 (“渔”)</strong></th></tr></thead><tbody><tr><td><strong>SPI_LCD_Init</strong></td><td>硬件层</td><td><strong>基本公用</strong></td><td>1. 检查 <code>CPOL/CPHA</code> 是否匹配新芯片手册。 2. 修改 GPIO 引脚以匹配实际电路。</td></tr><tr><td><strong>spi_readwrite</strong></td><td>硬件层</td><td><strong>完全公用</strong></td><td>无需修改，这是硬件 SPI 的标准模板。</td></tr><tr><td><strong>LCD_WR_REG&#x2F;DATA</strong></td><td>通信层</td><td><strong>半专用</strong></td><td>框架不变。需注意 <code>LCD_WR_DATA</code> 的位宽 (8位&#x2F;16位) 需根据新屏幕像素格式调整。</td></tr><tr><td><strong>LCD_Address_Set</strong></td><td>通信层</td><td><strong>完全专用</strong></td><td><strong>高频易错点！</strong> 指令 (0x2a, 0x2b) 和 <strong>坐标偏移量</strong> (+2, +1, +26等) 完全取决于屏幕批次。显示错位&#x2F;花边首先查这里。</td></tr><tr><td><strong>LCD_Init</strong></td><td>通信层</td><td><strong>完全专用</strong></td><td><strong>必须重写！</strong> 参照新驱动芯片手册的 “Initialization Sequence” (Power, Gamma, FrameRate)。</td></tr><tr><td><strong>LCD_ShowString</strong></td><td>应用层</td><td><strong>逻辑公用</strong></td><td>只要底层接口正确，上层绘图函数通常无需修改。</td></tr></tbody></table><h3 id="常见故障排查"><a href="#常见故障排查" class="headerlink" title="常见故障排查"></a>常见故障排查</h3><ol><li><strong>无反应</strong>: 检查 <code>DC</code> 引脚逻辑是否反了（指令被当成数据）。</li><li><strong>花屏&#x2F;乱码</strong>: 检查 SPI 模式 (<code>Mode 0</code> vs <code>Mode 3</code>)。</li><li><strong>图像错位</strong>: 检查 <code>LCD_Address_Set</code> 中的 <code>x</code>, <code>y</code> 偏移量</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SPI-协议（LCD-驱动）&quot;&gt;&lt;a href=&quot;#SPI-协议（LCD-驱动）&quot; class=&quot;headerlink&quot; title=&quot;SPI 协议（LCD 驱动）&quot;&gt;&lt;/a&gt;SPI 协议（LCD 驱动）&lt;/h1&gt;&lt;p&gt;本文档记录了 SPI 通信协议的基础知识，并</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="智能门锁" scheme="https://rosslin.xyz/tags/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>Cloudflare R2 + WebP Cloud + PicList 配置图床</title>
    <link href="https://rosslin.xyz/2025/12/17/%E6%96%87%E7%AB%A0/%E6%A0%BC%E7%89%A9%E5%BF%97/Cloudflare%20R2%20+%20WebP%20Cloud%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/"/>
    <id>https://rosslin.xyz/2025/12/17/%E6%96%87%E7%AB%A0/%E6%A0%BC%E7%89%A9%E5%BF%97/Cloudflare%20R2%20+%20WebP%20Cloud%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/</id>
    <published>2025-12-17T02:00:00.000Z</published>
    <updated>2026-01-31T06:16:31.299Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="Cloudflare-R2-WebP-Cloud-PicList-配置图床"><a href="#Cloudflare-R2-WebP-Cloud-PicList-配置图床" class="headerlink" title="Cloudflare R2 + WebP Cloud + PicList 配置图床"></a>Cloudflare R2 + WebP Cloud + PicList 配置图床</h1><h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p>(<a href="https://linux.do/t/topic/193442">参考教程</a>)   </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://piclist.cn/">PicList</a></p><p><a href="https://webp.se/">WebP 云服务</a>  需要注册Github  登陆</p><p>如有侵权，请联系删除</p><hr><p>当我们在博客文章中插入图片时，如果图片只存在本地，读者是无法看到的。为了让图片在互联网上“安家”，我们需要<strong>图床</strong>——本质上就是一台存放图片并允许他人访问的服务器。</p><p>当发布的文章插入图片时，图片是存储在本地，读者是无法看到的，为了能让大家看到图片，我们需要图床——本质上就是一台存放图片并允许他人访问的服务器。</p><p>最根本的方法就是，搭建自己的服务器，但维护成本和门槛都太高。好在许多厂商提供了带免费额度的对象存储服务。</p><p>配置图床的方法很多，</p><ul><li><p>国内厂商的免费额度 ，访问速度快，缺点额度不够大，七牛云的额度最大，但是域名得备案，门槛高</p></li><li><p>GitHub 图床：近乎零成本、容量大，但在国内访问极慢，担忧违规封号风险。</p></li><li><p>Cloudflare R2：由CF 大善人”提供，免费额度慷慨，且能集成 CF 域名生态，</p></li></ul><hr><h3 id="一、-前置条件"><a href="#一、-前置条件" class="headerlink" title="一、 前置条件"></a>一、 前置条件</h3><ol><li>订阅 CF R2 服务需绑定信用卡或 PayPal（仅验证身份，只要没超过额度不扣费）。</li><li>域名：建议拥有自己的域名（需托管在 Cloudflare）。</li></ol><hr><h3 id="二、-核心参数详解"><a href="#二、-核心参数详解" class="headerlink" title="二、 核心参数详解"></a>二、 核心参数详解</h3><p>无论用什么工具配置图床，方法都大同小异，</p><p>这里以目的为导向，在配置图床时需要获取的参数有如下</p><p><img src="https://image.rosslin.xyz/2025/12/%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="配置参数"></p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>应用密钥 ID (Access Key ID)</strong></td><td>这个是账户ID，是系统固定的</td></tr><tr><td><strong>应用密钥 (Secret Access Key)</strong></td><td>相当于密码，切勿泄露。有了它才能上传  修改  删除文件。</td></tr><tr><td><strong>桶名 (Bucket Name)</strong></td><td>存放图片的“文件夹”名称，自定义。</td></tr><tr><td><strong>自定义节点 (Endpoint)</strong></td><td>PicList 通过该地址将图片定向上传至 R2。</td></tr><tr><td><strong>自定义域名</strong></td><td>如果没有自备域名，可使用 CF 提供的公共 URL：<code>https://&lt;桶名&gt;.&lt;Account ID&gt;.r2.dev</code>。</td></tr></tbody></table><blockquote><p>注意：若要绑定自己的域名，需在 CF 的 DNS 设置中添加一条 <strong>CNAME</strong> 记录，指向 R2 的公共链接。</p></blockquote><hr><p><img src="https://image.rosslin.xyz/2025/12/8ddb16f3af74a73a926f882c2384d56c.png"></p><p>需要先测试<code>PicList</code> + Cloudflare R2能否正常访问图片。</p><h3 id="三、WebP-Cloud"><a href="#三、WebP-Cloud" class="headerlink" title="三、WebP Cloud"></a>三、WebP Cloud</h3><p>![WebP Cloud](<a href="https://5b9e583.webp.li/2026/01/WebP">https://5b9e583.webp.li/2026/01/WebP</a> Cloud.png)</p><p>为什么要使用 WebP Cloud？</p><p>单纯使用 R2 的缺点在于：国内访问速度速度慢，且原图体积较大，网页加载缓慢。</p><p>WebP Cloud作为云端图片代理，能自动将原图压缩并转换为 WebP 格式，实现加速和瘦身。</p><p>配置参数：</p><ul><li>Proxy Region：选择服务器代理区域，建议选距离最近的节点以提升加载速度。</li><li>Proxy Name：自定义名称，方便自己管理。</li><li>Proxy Origin URL：源站地址，有了这个   WebP Cloud 会去这个地址拉原图然后优化</li></ul><hr><h3 id="四、-整体工作流"><a href="#四、-整体工作流" class="headerlink" title="四、 整体工作流"></a>四、 整体工作流</h3><p>$$<br>\text{本地电脑} \xrightarrow{\text{上传}} \text{R2 仓库} \xrightarrow{\text{源站}} \text{WebP Cloud (加工&#x2F;加速&#x2F;缓存)} \xrightarrow{\text{展示}} \text{读者}<br>$$</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;Cloudflare-R2-WebP-Cloud-PicList-配置图床&quot;&gt;&lt;a href=&quot;#Cloudflare-R2-WebP-Cloud-PicList-配置图床&quot; class=&quot;headerlink&quot; title=&quot;Cloudflare R2</summary>
      
    
    
    
    <category term="格物志" scheme="https://rosslin.xyz/categories/%E6%A0%BC%E7%89%A9%E5%BF%97/"/>
    
    
    <category term="格物志" scheme="https://rosslin.xyz/tags/%E6%A0%BC%E7%89%A9%E5%BF%97/"/>
    
    <category term="实践手册" scheme="https://rosslin.xyz/tags/%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>11.内存管理</title>
    <link href="https://rosslin.xyz/2025/11/27/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/11.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://rosslin.xyz/2025/11/27/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/11.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2025-11-27T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:18.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📝-内存管理"><a href="#📝-内存管理" class="headerlink" title="📝 内存管理"></a>📝 内存管理</h1><h2 id="一、什么是-RAM？（随机存取存储器）"><a href="#一、什么是-RAM？（随机存取存储器）" class="headerlink" title="一、什么是 RAM？（随机存取存储器）"></a>一、什么是 RAM？（随机存取存储器）</h2><ul><li><strong>RAM (Random Access Memory)</strong>：掉电丢失的数据存储区。</li><li>8051 系列的 <strong>片内 RAM</strong> 只有 <strong>128 字节 或 256 字节</strong>（极度珍贵！）。</li><li>所有变量、栈、缓冲区都必须放在这 256 字节以内，因此 <strong>必须手动管理内存</strong>！</li></ul><h2 id="二、Keil-C51-各种存储类型对比（超级重点）"><a href="#二、Keil-C51-各种存储类型对比（超级重点）" class="headerlink" title="二、Keil C51 各种存储类型对比（超级重点）"></a>二、Keil C51 各种存储类型对比（超级重点）</h2><table><thead><tr><th><strong>关键字</strong></th><th><strong>存放位置</strong></th><th><strong>地址范围</strong></th><th><strong>访问方式</strong></th><th><strong>访问速度</strong></th><th><strong>空间大小</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><code>data</code></td><td>片内 RAM <strong>低 128 字节</strong></td><td><code>00H ~ 7FH</code></td><td>直接寻址 &#x2F; 间接寻址</td><td>★★★★★</td><td>~100 字节可用</td><td><strong>频繁访问的小变量</strong>、函数参数、栈</td></tr><tr><td><code>idata</code></td><td>片内 RAM <strong>高 128 字节</strong></td><td><code>80H ~ FFH</code></td><td><strong>只能间接寻址</strong> (<code>@R0</code>&#x2F;<code>@R1</code>)</td><td>★★★★</td><td>128 字节</td><td>数组、缓冲区、不太频繁访问的变量</td></tr><tr><td><code>xdata</code></td><td><strong>片外扩展 RAM</strong>（如 6264）</td><td><code>0000H ~ FFFFH</code></td><td><code>MOVX</code> 指令</td><td>★★</td><td>最大 64KB</td><td><strong>大数组</strong>、LCD 缓冲区、FAT 文件系统等</td></tr><tr><td><code>pdata</code></td><td>片外 RAM <strong>低 256 字节</strong></td><td><code>0000H ~ 00FFH</code></td><td><code>MOVX @Ri</code></td><td>★★</td><td>256 字节</td><td>很少用（旧系统兼容）</td></tr><tr><td><code>code</code></td><td><strong>程序存储区</strong>（Flash&#x2F;ROM）</td><td><code>0000H ~ FFFFH</code></td><td><code>MOVC</code> 指令</td><td>★★★</td><td>最大 64KB</td><td><strong>常量、字符串、查找表</strong>（如字模）</td></tr><tr><td><strong>无关键字</strong></td><td>默认等同于 <code>data</code></td><td>同 <code>data</code></td><td>同 <code>data</code></td><td>★★★★★</td><td>同 <code>data</code></td><td>小项目最常用</td></tr></tbody></table><blockquote><p><strong>💡 注意：</strong></p><ul><li>老芯片（如 AT89C51）只有 128 字节 RAM，<code>80H~FFH</code> 与 SFR 重叠，但仍可通过间接寻址访问，所以 <code>idata</code> 仍然可用！</li><li>新芯片（如 AT89S52、STC89C52）真正有 256 字节 RAM，<code>idata</code> 空间更宽裕。</li></ul></blockquote><h2 id="三、8051-片内-RAM-结构图（经典-256-字节版）"><a href="#三、8051-片内-RAM-结构图（经典-256-字节版）" class="headerlink" title="三、8051 片内 RAM 结构图（经典 256 字节版）"></a>三、8051 片内 RAM 结构图（经典 256 字节版）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">地址      内容</span><br><span class="line">FFH ┌─────────────────┐  ← 二楼结束</span><br><span class="line">    │     idata 区域      │  ← 你代码里的大数组放这里</span><br><span class="line">80H ├─────────────────┤  ← 二楼开始（只能用指针 @R0/@R1 访问）</span><br><span class="line">7FH ┌─────────────────┐  ← 一楼结束</span><br><span class="line">    │     data 区域       │  ← 小变量、栈、频繁使用的放这里</span><br><span class="line">30H ├─────────────────┤</span><br><span class="line">    │   位寻址区          │</span><br><span class="line">20H ├─────────────────┤</span><br><span class="line">    │   寄存器组 R0~R7    │</span><br><span class="line">00H └─────────────────┘  ← 一楼开始</span><br></pre></td></tr></table></figure><h2 id="🔑-总结（背下来一辈子不忘）"><a href="#🔑-总结（背下来一辈子不忘）" class="headerlink" title="🔑 总结（背下来一辈子不忘）"></a>🔑 总结（背下来一辈子不忘）</h2><ul><li>RAM 只有 256 字节，宝贝得像金子一样省着用！</li><li>小变量、栈 → 扔 <strong><code>data</code></strong>（一楼，速度快）</li><li>大数组、缓冲区 → 扔 <strong><code>idata</code></strong>（二楼，空间大）</li><li>更大东西 → 扔 <strong><code>xdata</code></strong>（外面仓库）</li><li>常量、字模 → 扔 <strong><code>code</code></strong>（Flash 里）</li><li><strong>不写关键字 &#x3D; 默认 <code>data</code></strong>，一不小心就溢出！</li></ul><blockquote><p>📌 <strong>写 51 程序的第一生存技能：会数 RAM 字节！</strong></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📝-内存管理&quot;&gt;&lt;a href=&quot;#📝-内存管理&quot; class=&quot;headerlink&quot; title=&quot;📝 内存管理&quot;&gt;&lt;/a&gt;📝 内存管理&lt;/h1&gt;&lt;h2 id=&quot;一、什么是-RAM？（随机存取存储器）&quot;&gt;&lt;a href=&quot;#一、什么是-RAM？（随机存</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>10.超声波测距</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/10.%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/10.%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:11.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="超声波测距"><a href="#超声波测距" class="headerlink" title="超声波测距"></a>超声波测距</h1><h2 id="一、超声波测距原理与实现"><a href="#一、超声波测距原理与实现" class="headerlink" title="一、超声波测距原理与实现"></a>一、超声波测距原理与实现</h2><h3 id="1-测距原理"><a href="#1-测距原理" class="headerlink" title="1. 测距原理"></a>1. 测距原理</h3><p>超声波测距的原理是利用超声波在空气中的传播速度为已知，测量声波在发射后遇到障碍物反射回来的时间，根据发射和接收的时间差计算出发射点到障碍物的实际距离。由此可见，超声波测距原理与雷达原理是一样的。</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127143229081.png" alt="image-20251127143229081"></p><h3 id="2-测距公式推导"><a href="#2-测距公式推导" class="headerlink" title="2. 测距公式推导"></a>2. 测距公式推导</h3><p>测距的公式表示为：</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251127182824215.png"></p><h3 id="3-超声波发送细节"><a href="#3-超声波发送细节" class="headerlink" title="3. 超声波发送细节"></a>3. 超声波发送细节</h3><p>根据我们上方的分析，我们可以知道我们首先需要进行发送，我们在这里发送 8 个 40kHz 的方波进行测量。</p><ul><li><strong>周期计算</strong>: 周期<br>$$<br>T &#x3D; \frac{1}{40 , \text{kHz}} &#x3D; 25 , \text{us}<br>$$<br>。</li><li><strong>电平反转时间</strong>: 也就是我们需要 12us 将发送的电平进行反转（约为半个周期）。</li></ul><h3 id="4-代码实现概述-基于-STC89C-系列单片机"><a href="#4-代码实现概述-基于-STC89C-系列单片机" class="headerlink" title="4. 代码实现概述 (基于 STC89C 系列单片机)"></a>4. 代码实现概述 (基于 STC89C 系列单片机)</h3><p>这里需要注意的是要正确使用系统频率为 12MHz，并且使用 <code>y1/stc89</code> 指令集。</p><h4 id="4-1-延时函数-Delay12us-void"><a href="#4-1-延时函数-Delay12us-void" class="headerlink" title="4.1 延时函数 Delay12us(void)"></a>4.1 延时函数 <code>Delay12us(void)</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127124721571.png" alt="image-20251127124721571"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ul.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span> <span class="comment">// 标准头文件</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  延时12微秒</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> * @note   基于12MHz系统时钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line">    _nop_(); <span class="comment">// 使用标准库函数 _nop_()</span></span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-超声波发送初始化-Ut-Wave-Init"><a href="#4-2-超声波发送初始化-Ut-Wave-Init" class="headerlink" title="4.2 超声波发送初始化 Ut_Wave_Init()"></a>4.2 超声波发送初始化 <code>Ut_Wave_Init()</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127122447909.png" alt="image-20251127122447909"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义超声波模块的引脚</span></span><br><span class="line">sbit Tx = P1^<span class="number">0</span>; <span class="comment">// 发送引脚</span></span><br><span class="line">sbit Rx = P1^<span class="number">1</span>; <span class="comment">// 接收引脚</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  发送8个40kHz的超声波脉冲</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tx = <span class="number">1</span>; <span class="comment">// 拉高电平</span></span><br><span class="line">        Delay12us(); <span class="comment">// 延时12us</span></span><br><span class="line">        Tx = <span class="number">0</span>; <span class="comment">// 拉低电平</span></span><br><span class="line">        Delay12us(); <span class="comment">// 延时12us</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-超声波数据采集与距离计算-Ut-Wave-Data"><a href="#4-3-超声波数据采集与距离计算-Ut-Wave-Data" class="headerlink" title="4.3 超声波数据采集与距离计算 Ut_Wave_Data()"></a>4.3 超声波数据采集与距离计算 <code>Ut_Wave_Data()</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127134433921.png" alt="image-20251127134433921"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  触发测量并计算距离</span></span><br><span class="line"><span class="comment"> * @return unsigned char 返回测得的距离值</span></span><br><span class="line"><span class="comment"> * @note   此函数存在一个潜在的bug：返回值类型为 unsigned char，</span></span><br><span class="line"><span class="comment"> *         当距离超过255cm时会发生数据溢出。建议返回 unsigned int。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    <span class="comment">// 配置定时器/计数器</span></span><br><span class="line">    <span class="comment">// 注意: CH, CL, CMOD, CR, CF 是特定于STC系列PCA/PWM模块的寄存器，</span></span><br><span class="line">    <span class="comment">// 并非标准8051的定时器寄存器。此处代码是基于PCA模块实现。</span></span><br><span class="line">    CH = <span class="number">0</span>; <span class="comment">// 清空PCA计数器高字节</span></span><br><span class="line">    CL = <span class="number">0</span>; <span class="comment">// 清空PCA计数器低字节</span></span><br><span class="line">    CMOD = <span class="number">0x00</span>; <span class="comment">// 设置PCA时钟源为系统时钟/12，并禁止PCA中断</span></span><br><span class="line">    EA = <span class="number">0</span>; <span class="comment">// 关闭总中断，防止发送脉冲时被打断</span></span><br><span class="line">    Ut_Wave_Init(); <span class="comment">// 发送超声波脉冲</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">// 立即开启总中断</span></span><br><span class="line">    CR = <span class="number">1</span>; <span class="comment">// 启动PCA计数器</span></span><br><span class="line">    <span class="comment">// 等待接收引脚Rx变为高电平（回波信号），或者PCA计数器溢出(CF=1)</span></span><br><span class="line">    <span class="keyword">while</span> (Rx &amp;&amp; !CF);</span><br><span class="line">    CR = <span class="number">0</span>; <span class="comment">// 停止PCA计数器</span></span><br><span class="line">    <span class="keyword">if</span> (!CF) <span class="comment">// 如果未溢出，说明收到了回波</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算时间</span></span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL; <span class="comment">// 合并PCA计数器值</span></span><br><span class="line">        <span class="comment">// 距离计算: d = 0.017 * time</span></span><br><span class="line">        <span class="comment">// us -&gt; s 10^(-6)</span></span><br><span class="line">        <span class="comment">// m -&gt; cm 10^2</span></span><br><span class="line">        <span class="comment">// L = V*T/2 = 340 * time / 2 = 170 * 10^(-4) * time = 0.017 * time</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0.017</span> * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果溢出，说明超出测量范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        CF = <span class="number">0</span>; <span class="comment">// 清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示测量失败或超出范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码注解</strong>:</p><ol><li><strong>寄存器</strong>: <code>CH</code>, <code>CL</code>, <code>CMOD</code>, <code>CR</code>, <code>CF</code> 看起来是 STC 单片机特有的 <strong>PCA (可编程计数器阵列)</strong> 模块的寄存器，而不是标准的定时器0&#x2F;1的 <code>TH0</code>, <code>TL0</code>, <code>TF0</code>。这需要根据具体的单片机型号和定时器配置进行适配。</li><li><strong>返回值类型</strong>: <code>return (0.017 * time);</code> 的返回值类型为 <code>unsigned char</code>，这意味着最大只能返回 255。如果距离超过 255cm，将会发生截断，导致数据不准确。通常距离值会使用 <code>unsigned int</code> 类型存储。</li></ol></blockquote><h4 id="4-4-读取距离值-Get-Distance"><a href="#4-4-读取距离值-Get-Distance" class="headerlink" title="4.4 读取距离值 Get_Distance()"></a>4.4 读取距离值 <code>Get_Distance()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的全局变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Distance_Slow_Down = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Distance_Val = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  读取距离值</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> * @note   通过一个延时变量来控制测量的频率，避免过于频繁地测量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_Distance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查延时是否到达</span></span><br><span class="line">    <span class="keyword">if</span> (Distance_Slow_Down &lt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Distance_Slow_Down = <span class="number">0</span>; <span class="comment">// 重置延时计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取超声波模块测量的距离</span></span><br><span class="line">    Distance_Val = Ut_Wave_Data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要注意事项</strong>：在 <code>Ut_Wave_Data()</code> 函数中，我们使用了 <code>EA = 0;</code> 来关闭总中断，以确保发送8个脉冲的精确时序。<strong>在发送完毕后，必须立即使用 <code>EA = 1;</code> 重新开启中断</strong>，否则程序中依赖中断的部分（如数码管动态扫描、按键检测等）将停止工作，导致系统无响应。</p><h2 id="二、核心知识补充：PCA-vs-普通定时器"><a href="#二、核心知识补充：PCA-vs-普通定时器" class="headerlink" title="二、核心知识补充：PCA vs. 普通定时器"></a>二、核心知识补充：PCA vs. 普通定时器</h2><p>代码中使用了STC单片机特有的PCA模块来实现计时，这是一个非常好的实践。为了更深入地理解，我们将其与最常见的普通定时器（如Timer 0）进行详细对比。</p><h3 id="1-核心思想：瑞士军刀-vs-专用扳手"><a href="#1-核心思想：瑞士军刀-vs-专用扳手" class="headerlink" title="1. 核心思想：瑞士军刀 vs. 专用扳手"></a>1. 核心思想：瑞士军刀 vs. 专用扳手</h3><p>这是一个非常形象的比喻：</p><ul><li><strong>普通定时器</strong>：就像一把<strong>专用扳手</strong>。它非常擅长做一件事：<strong>定时&#x2F;计数</strong>。当你需要一个周期性的中断来执行任务时（如每隔1ms刷新数码管），它就是最直接、最高效的选择。</li><li><strong>PCA（<strong>P</strong>rogrammable <strong>C</strong>ounter <strong>A</strong>rray）</strong>：就像一把<strong>瑞士军刀</strong>。它的核心也是一个定时器（主计数器），但它还集成了多个“小工具”（比较&#x2F;捕获模块），使得它能实现更复杂的功能。</li><li>两者本质都是<strong>计数器</strong>。</li></ul><h3 id="2-功能对比"><a href="#2-功能对比" class="headerlink" title="2. 功能对比"></a>2. 功能对比</h3><table><thead><tr><th align="left">功能特性</th><th align="left">普通定时器 (Timer 0&#x2F;1)</th><th align="left">PCA (可编程计数器阵列)</th></tr></thead><tbody><tr><td align="left"><strong>基本定时&#x2F;计数</strong></td><td align="left">✅ <strong>核心功能</strong></td><td align="left">✅ <strong>核心功能</strong></td></tr><tr><td align="left"><strong>周期性中断</strong></td><td align="left">✅ <strong>直接支持</strong>。设置初值，溢出后触发中断。</td><td align="left">✅ <strong>支持</strong>。通过溢出标志<code>CF</code>触发中断。</td></tr><tr><td align="left"><strong>PWM输出</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需用软件在中断中模拟，占用CPU，精度差。</td><td align="left">✅ <strong>硬件自动实现</strong>。配置后，硬件自动输出PWM波形，不占CPU。</td></tr><tr><td align="left"><strong>输入捕获</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需用外部中断+定时器组合，逻辑复杂。</td><td align="left">✅ <strong>硬件自动实现</strong>。可自动捕获引脚电平跳变时刻的计数值，响应快。</td></tr><tr><td align="left"><strong>软件定时器</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需在主程序或中断中维护变量。</td><td align="left">✅ <strong>支持</strong>。每个比较模块都可设为独立的软件定时器。</td></tr></tbody></table><h3 id="3-寄存器对比"><a href="#3-寄存器对比" class="headerlink" title="3. 寄存器对比"></a>3. 寄存器对比</h3><p>你的代码中，两种定时器使用了完全不同的寄存器集，这证明了它们是独立的硬件模块。</p><table><thead><tr><th align="left">作用</th><th align="left">普通定时器 (以Timer 0为例)</th><th align="left">PCA</th></tr></thead><tbody><tr><td align="left"><strong>模式配置</strong></td><td align="left"><code>TMOD</code> (设置16位&#x2F;8位模式) <code>AUXR</code> (设置12T&#x2F;1T时钟)</td><td align="left"><code>CMOD</code> (设置时钟源、中断使能)</td></tr><tr><td align="left"><strong>计数器值</strong></td><td align="left"><code>TH0</code>, <code>TL0</code> (高&#x2F;低字节)</td><td align="left"><code>CH</code>, <code>CL</code> (高&#x2F;低字节)</td></tr><tr><td align="left"><strong>启停控制</strong></td><td align="left"><code>TR0</code> (Run control bit)</td><td align="left"><code>CR</code> (Run control bit)</td></tr><tr><td align="left"><strong>溢出标志</strong></td><td align="left"><code>TF0</code> (Overflow Flag)</td><td align="left"><code>CF</code> (Counter Overflow Flag)</td></tr><tr><td align="left"><strong>中断控制</strong></td><td align="left"><code>ET0</code> (Timer 0 Interrupt Enable)</td><td align="left">PCA有独立的中断使能位</td></tr></tbody></table><h3 id="4-在你的超声波测距代码中的应用分析"><a href="#4-在你的超声波测距代码中的应用分析" class="headerlink" title="4. 在你的超声波测距代码中的应用分析"></a>4. 在你的超声波测距代码中的应用分析</h3><p>现在我们回头看你的 <code>Ut_Wave_Data()</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">CH = 0; CL = 0;   // 清空PCA计数器</span><br><span class="line">CMOD = 0x00;      // 配置PCA</span><br><span class="line">CR = 1;           // 启动PCA</span><br><span class="line">while (Rx &amp;&amp; !CF); // 轮询等待</span><br><span class="line">CR = 0;           // 停止PCA</span><br><span class="line">time = CH &lt;&lt; 8 | CL; // 读取计数值</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><ul><li><strong>代码中用到了PCA的什么功能？</strong><br>你只用了PCA最基础的功能：<strong>把它当作一个16位的、从0开始计时的秒表</strong>。你通过轮询<code>CF</code>标志位来实现超时检测。</li><li><strong>能用普通定时器实现吗？</strong><br><strong>完全可以！</strong> 而且这是更常规的做法。使用Timer 0的代码逻辑几乎完全一样，只是换一套寄存器而已：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用Timer 0的伪代码</span><br><span class="line">TMOD = 0x01;    // 16位定时器模式</span><br><span class="line">TH0 = 0; TL0 = 0; // 从0开始计时</span><br><span class="line">TF0 = 0;        // 清除溢出标志</span><br><span class="line">TR0 = 1;        // 启动Timer 0</span><br><span class="line">while (Rx &amp;&amp; !TF0); // 轮询等待</span><br><span class="line">TR0 = 0;        // 停止Timer 0</span><br><span class="line">time = TH0 &lt;&lt; 8 | TL0; // 读取计数值</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h3 id="5-如何选择？"><a href="#5-如何选择？" class="headerlink" title="5. 如何选择？"></a>5. 如何选择？</h3><ul><li><strong>选择普通定时器</strong>：当你的需求仅仅是<strong>定时、延时、或者测量一个时间长度</strong>时，使用Timer 0或Timer 1是首选。它更简单、通用，代码移植性也更好。</li><li><strong>选择PCA</strong>：当你的项目需要<strong>同时实现多种功能</strong>时，PCA的优势就体现出来了。例如，你的项目既要超声波测距，又要用PWM控制电机转速，这时用PCA的捕获模块测距，用另一个模块输出PWM，就能高效地完成任务，而把普通的Timer 0留给系统时钟节拍等关键任务。</li></ul><p><strong>结论</strong>：在你的超声波测距代码中，你使用了PCA的“瑞士军刀”来切苹果（做基本计时），这是完全可行的。但了解普通定时器这把“专用扳手”同样能胜任，并且知道它们之间的区别，能帮助你在未来的项目中做出更合理的设计选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;超声波测距&quot;&gt;&lt;a href=&quot;#超声波测距&quot; class=&quot;headerlink&quot; title=&quot;超声波测距&quot;&gt;&lt;/a&gt;超声波测距&lt;/h1&gt;&lt;h2 id=&quot;一、超声波测距原理与实现&quot;&gt;&lt;a href=&quot;#一、超声波测距原理与实现&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>2.数码管和定时器</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/2.%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/2.%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:08.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数码管和定时器"><a href="#数码管和定时器" class="headerlink" title="**数码管和定时器 **"></a>**数码管和定时器 **</h1><h2 id="一、数码管基本原理"><a href="#一、数码管基本原理" class="headerlink" title="一、数码管基本原理"></a>一、数码管基本原理</h2><h3 id="1-数码管结构"><a href="#1-数码管结构" class="headerlink" title="1. 数码管结构"></a>1. 数码管结构</h3><p>数码管本质上是由<strong>8个LED段</strong>（a<del>g + 小数点dp）组合而成的显示器件，用于显示数字0</del>9及部分字母。</p><p>根据内部连接方式，可分为两种类型：</p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230550029.png" style="zoom: 67%;" /><table><thead><tr><th>类型</th><th>阳极连接</th><th>阴极连接</th><th>控制方式</th><th>亮灭逻辑</th></tr></thead><tbody><tr><td><strong>共阳极数码管</strong></td><td>所有LED阳极连在一起接VCC</td><td>每段独立接驱动电路</td><td>控制<strong>阴极电平</strong></td><td><strong>0亮，1灭</strong></td></tr><tr><td><strong>共阴极数码管</strong></td><td>每段独立接驱动电路</td><td>所有LED阴极连在一起接地</td><td>控制<strong>阳极电平</strong></td><td><strong>1亮，0灭</strong></td></tr></tbody></table><blockquote><p>✅ <strong>本系统使用的是共阳极数码管</strong>（根据电路图与代码中<code>0xc0, 0xf9...</code>推断）<br>因此：<strong>输出低电平 → 段点亮；输出高电平 → 段熄灭</strong></p></blockquote><h3 id="2-段码表（共阳极数码管）"><a href="#2-段码表（共阳极数码管）" class="headerlink" title="2. 段码表（共阳极数码管）"></a>2. 段码表（共阳极数码管）</h3><h3 id="3-什么是“消影”？如何解决？"><a href="#3-什么是“消影”？如何解决？" class="headerlink" title="3. 什么是“消影”？如何解决？"></a>3. 什么是“消影”？如何解决？</h3><h4 id="❓-什么是消影？"><a href="#❓-什么是消影？" class="headerlink" title="❓ 什么是消影？"></a>❓ 什么是消影？</h4><p>在<strong>动态扫描显示</strong>中，当从一个数码管切换到另一个时，由于<strong>段码数据提前加载</strong>或<strong>位选信号延迟关闭</strong>，会导致前一个数码管在切换瞬间仍有残影（部分段微亮），这种现象称为**“消影”**（或“鬼影”）。</p><h4 id="✅-消影产生的原因："><a href="#✅-消影产生的原因：" class="headerlink" title="✅ 消影产生的原因："></a>✅ 消影产生的原因：</h4><ul><li>位选（选中哪个数码管）与段选（显示什么数字）未严格同步；</li><li>段码数据写入后，未先关闭所有位选就切换，造成短暂重叠。</li></ul><h4 id="🔧-解决方法："><a href="#🔧-解决方法：" class="headerlink" title="🔧 解决方法："></a>🔧 解决方法：</h4><blockquote><p><strong>“先关位选 → 再送段码 → 再开位选”</strong><br>即：<strong>消影三步法</strong></p><ol><li>先关闭所有数码管（P0 &#x3D; 0xFF，段码全灭）</li><li>再进行位选（选中要显示的数码管）</li><li>最后写入段码并锁存</li></ol></blockquote><blockquote><p>✅ 本系统通过在每次显示前先执行一次**“全灭”操作**，有效消除鬼影。</p></blockquote><hr><h2 id="二、数码管动态显示原理"><a href="#二、数码管动态显示原理" class="headerlink" title="二、数码管动态显示原理"></a>二、数码管动态显示原理</h2><h3 id="🎯-原理概述"><a href="#🎯-原理概述" class="headerlink" title="🎯 原理概述"></a>🎯 原理概述</h3><p>动态显示是指<strong>多个数码管轮流点亮</strong>，利用人眼的<strong>视觉暂留效应</strong>（约10~40ms），在快速切换下产生“同时点亮”的错觉。</p><ul><li><p><strong>刷新频率建议</strong>：&gt; 50Hz（即每50ms刷新一次），人眼无闪烁。</p></li><li><p><strong>每个数码管点亮时间</strong>：约 1~5ms</p></li><li><p><strong>优点</strong>：节省IO口、功耗低、电路简单</p></li><li><p><strong>缺点</strong>：需程序定时刷新，占用CPU资源</p></li></ul><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230743404.png"></p><h3 id="✅-动态扫描实现步骤"><a href="#✅-动态扫描实现步骤" class="headerlink" title="✅ 动态扫描实现步骤"></a>✅ 动态扫描实现步骤</h3><blockquote><p><strong>“消影 → 位选 → 段选”</strong></p></blockquote><table><thead><tr><th>步骤</th><th>操作</th><th>目的</th></tr></thead><tbody><tr><td>1. 消影</td><td>P0 &#x3D; 0xFF + 锁存</td><td>关闭所有段，避免残影</td></tr><tr><td>2. 位选</td><td>选中某个数码管（如第3位）</td><td>让电流只流过该数码管</td></tr><tr><td>3. 段选</td><td>写入对应数字的段码</td><td>显示所需数字</td></tr></tbody></table><blockquote><p>💡 <strong>注意</strong>：位选与段选需分别通过<strong>不同的锁存器</strong>控制（本系统使用两个锁存器：一个控制位选、一个控制段选）</p></blockquote><hr><h2 id="三、硬件连接说明"><a href="#三、硬件连接说明" class="headerlink" title="三、硬件连接说明"></a>三、硬件连接说明</h2><ul><li><strong>P0口</strong>：输出段码与位选信号（共用）</li><li>P2口:控制锁存器使能端<ul><li><code>P2.5</code> 控制<strong>段选锁存器</strong>（LE &#x3D; Y6C （110），由Y6选通）  </li><li><code>P2.7</code> 控制<strong>位选锁存器</strong>（LE &#x3D; Y7C（111），由Y7选通）</li></ul></li><li><strong>Y4~Y7</strong>：由74HC138译码器输出，用于选通不同锁存器</li></ul><blockquote><p>✅ <strong>段选锁存器使能</strong>：选中 Y6 → Y6&#x3D;0 → Y6C&#x3D;1 → 段选锁存器打开<br>✅ <strong>位选锁存器使能</strong>：选中 Y7 → Y7&#x3D;0 → Y7C&#x3D;1 → 位选锁存器打开</p></blockquote><hr><h2 id="四、完整代码实现（带详细注释）"><a href="#四、完整代码实现（带详细注释）" class="headerlink" title="四、完整代码实现（带详细注释）"></a>四、完整代码实现（带详细注释）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_dula[] = &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0xc6&#125;;</span><br><span class="line">unsigned char seg_wela[] = &#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;</span><br><span class="line"></span><br><span class="line">// 函数名：数码管动态显示函数</span><br><span class="line">// 入口参数：</span><br><span class="line">//   wela：位选索引（0~7），表示第几个数码管（从右到左）</span><br><span class="line">//   dula：段选数字（0~9），表示要显示的数字</span><br><span class="line">//   point：是否点亮小数点（1=点亮，0=不点亮）</span><br><span class="line">// 返回值：无</span><br><span class="line">// 功能：通过动态扫描显示一个数字，支持小数点，自动消影</span><br><span class="line"></span><br><span class="line">void seg_disp(unsigned char wela, unsigned char dula, unsigned char point)</span><br><span class="line">&#123;</span><br><span class="line">    // 第一步：消影 —— 先关闭所有数码管（避免残影）</span><br><span class="line">    // 将P0设为全高（0xFF）→ 所有段灭</span><br><span class="line">    P0 = 0xFF;</span><br><span class="line"></span><br><span class="line">    // 锁存器使能：选中Y7（P2.7=1, P2.6=1, P2.5=1, P2.4=0 → Y7=0，使能位选锁存器）</span><br><span class="line">    // P2 = P2 &amp; 0x1F | 0xE0; → 保留低5位，高三位设为111 → 1110 0000 = 0xE0</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xE0;</span><br><span class="line">    </span><br><span class="line">    // 锁存：拉低LE → 保持全灭状态</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">    // 第二步：位选 —— 选中要显示的数码管（如第3位）</span><br><span class="line">    P0 = seg_wela[wela];  // 写入位选码（低电平有效）</span><br><span class="line"></span><br><span class="line">    // 使能位选锁存器（Y7选通）→ Y7=0 → Y7C=1 → 打开锁存器</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xE0;</span><br><span class="line">    </span><br><span class="line">    // 锁存位选信号</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">    // 第三步：段选 —— 设置要显示的数字</span><br><span class="line">    P0 = seg_dula[dula];  // 写入段码</span><br><span class="line"></span><br><span class="line">    // 如果需要显示小数点</span><br><span class="line">    if(point)</span><br><span class="line">        P0 &amp;= 0x7F;  // 将dp位（第7位）置0，点亮小数点（共阳极：0亮）</span><br><span class="line"></span><br><span class="line">    // 使能段选锁存器（选中Y6 → P2.5=1, P2.6=1, P2.7=1 → Y6=0 → Y6C=1）</span><br><span class="line">    // 注意：此时P2.7仍为1，但锁存器是Y6控制的，不影响</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xC0;  // 0xC0 = 1100 0000 → 设置P2.7=1, P2.6=1, P2.5=0 → 选Y6</span><br><span class="line">    P2 &amp;= 0x1F;  // 锁存段码</span><br><span class="line"></span><br><span class="line">    // ✅ 完成一次显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器</p><p>1.在STC-ISP上生成初始化函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Init(void)</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F;</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TL0 = 0x18;</span><br><span class="line">TH0 = 0xFC;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ET0 = 1; //打开定时器0中断 （Enable Timer 0 Interrupt）</span><br><span class="line">EA = 1; //打开总中断  （Enable All interrupts）</span><br></pre></td></tr></table></figure><p>2.编写中断服务函数:</p><p>只需要在普通函数后加 interrupt num<br>num越大，中断优先级越低，当中断同时发生，优先级高的先进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_pos;</span><br><span class="line">unsigned char seg_buf[8] =&#123;10,10,10,10,10,10,10,10&#125;;</span><br><span class="line">unsigned char seg_point[8] =&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Timer0Init interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> if(++seg_pos == 8) seg_pos = 0;</span><br><span class="line"> Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、定时器0中断系统（实现自动动态扫描）"><a href="#五、定时器0中断系统（实现自动动态扫描）" class="headerlink" title="五、定时器0中断系统（实现自动动态扫描）"></a>五、定时器0中断系统（实现自动动态扫描）</h2><h3 id="1-定时器0初始化（1ms定时，用于刷新数码管）"><a href="#1-定时器0初始化（1ms定时，用于刷新数码管）" class="headerlink" title="1. 定时器0初始化（1ms定时，用于刷新数码管）"></a><strong>1. 定时器0初始化（1ms定时，用于刷新数码管）</strong></h3><p>(**易错点)**<strong>定义时间变量 常用 <code>unsigned int</code></strong> </p><p>int（ <strong>integer</strong>（整数））：<strong>16 位</strong>（2 字节）</p><p>取值范围：2^16&#x3D;65535</p><p><code>char</code> （ <strong>character（字符）</strong>）：是 <strong>1 字节（8 位）</strong> </p><p>取值范围：2^8 &#x3D;255</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230848799.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数名：定时器0初始化</span><br><span class="line">// 功能：配置定时器0为模式1（16位定时），每1ms产生一次中断</span><br><span class="line">// 晶振：12MHz → 机器周期：1μs</span><br><span class="line">// 定时1ms → 计数值 = 1000</span><br><span class="line">// 定时器计数 = 65536 - 1000 = 64536 = 0xFC18</span><br><span class="line">// TH0 = 0xFC, TL0 = 0x18</span><br><span class="line"></span><br><span class="line">void Timer0Init(void)</span><br><span class="line">&#123;</span><br><span class="line">    AUXR &amp;= 0x7F;     // 设置定时器0为1T模式（STC专用，加速）</span><br><span class="line">    TMOD &amp;= 0xF0;     // 清除T0模式位，保留T1</span><br><span class="line">    TL0 = 0x18;       // 低8位初值</span><br><span class="line">    TH0 = 0xFC;       // 高8位初值</span><br><span class="line">    TF0 = 0;          // 清除溢出标志</span><br><span class="line">    TR0 = 1;          // 启动定时器0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔔 <strong>注意</strong>：</p><ul><li>若使用12T模式（默认），初值为 <code>TH0=0x3C, TL0=0xB0</code></li><li>本代码使用 <strong>1T模式</strong>（STC增强型），精度更高，推荐使用！</li></ul></blockquote><h3 id="2-打开中断"><a href="#2-打开中断" class="headerlink" title="2. 打开中断"></a>2. 打开中断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ET0 = 1; //打开定时器0中断 （Enable Timer 0 Interrupt）</span><br><span class="line">EA = 1; //打开总中断  （Enable All interrupts）</span><br></pre></td></tr></table></figure><h3 id="3-定时器0中断服务函数（核心！动态扫描在此完成）"><a href="#3-定时器0中断服务函数（核心！动态扫描在此完成）" class="headerlink" title="3. 定时器0中断服务函数（核心！动态扫描在此完成）"></a>3. 定时器0中断服务函数（核心！动态扫描在此完成）</h3><p><strong>只需要在普通函数后加 interrupt num</strong><br><strong>。num越大，中断优先级越低，当中断同时发生，优先级高的先进行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_pos;</span><br><span class="line">unsigned char seg_buf[8] =&#123;10,10,10,10,10,10,10,10&#125;;</span><br><span class="line">unsigned char seg_point[8] =&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Timer0Init interrupt 1  //void Function_Name() interrupt num  num取决于数据手册</span><br><span class="line">&#123;</span><br><span class="line"> if(++seg_pos == 8) seg_pos = 0;</span><br><span class="line"> Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>关键说明</strong>：</p><ul><li>中断服务函数<strong>必须重载初值</strong>（1T模式下TH0&#x2F;TL0不自动重载）</li><li><code>seg_disp()</code> 会自动执行“消影→位选→段选”三步，无需额外处理</li><li>所有显示数据由 <code>seg_buf[]</code> 和 <code>seg_point[]</code> 提供，<strong>主程序只需修改这两数组</strong></li></ul></blockquote><h3 id="8051单片机定时器相关寄存器总结"><a href="#8051单片机定时器相关寄存器总结" class="headerlink" title="8051单片机定时器相关寄存器总结"></a><strong>8051单片机定时器相关寄存器总结</strong></h3><table><thead><tr><th align="left">缩写</th><th align="left">全称</th><th align="left">说明</th><th align="left">相关代码示例及解释</th></tr></thead><tbody><tr><td align="left"><strong>AUXR</strong></td><td align="left">Auxiliary Register (辅助寄存器)</td><td align="left">某些增强型8051单片机（如STC系列）特有的寄存器，用于控制定时器的工作模式。</td><td align="left"><code>AUXR &amp;= 0x7F;</code> 将第7位（通常为T0x12位）清零，选择12T模式（即12个时钟周期为一个机器周期，传统8051模式）。</td></tr><tr><td align="left"><strong>TMOD</strong></td><td align="left">Timer Mode Register (定时器模式寄存器)</td><td align="left">用于设置定时器0和定时器1的工作模式（如方式0~3）。</td><td align="left"><code>TMOD &amp;= 0xF0;</code> 表示清除低4位，即定时器0的模式被设为方式0（13位定时器）或方式1（16位定时器）。具体取决于后续是否设置M1&#x2F;M0位。</td></tr><tr><td align="left"><strong>TL0</strong></td><td align="left">Timer 0 Low-byte (定时器0低8位)</td><td align="left">定时器0的低字节计数寄存器。与TH0共同组成一个16位的计数器。</td><td align="left">(无直接代码示例，通常与TH0一起赋值)</td></tr><tr><td align="left"><strong>TH0</strong></td><td align="left">Timer 0 High-byte (定时器0高8位)</td><td align="left">定时器0的高字节计数寄存器。与TL0共同组成一个16位的计数器。</td><td align="left">(无直接代码示例，通常与TL0一起赋值)</td></tr><tr><td align="left"><strong>TF0</strong></td><td align="left">Timer 0 Overflow Flag (定时器0溢出标志位)</td><td align="left">当定时器0计数溢出时，硬件自动置1；需软件清零。</td><td align="left"><code>TF0 = 0;</code> 手动清除溢出标志。虽然上电后通常为0，但显式清零是良好习惯。</td></tr><tr><td align="left"><strong>TR0</strong></td><td align="left">Timer 0 Run control bit (定时器0运行控制位)</td><td align="left">位于TCON寄存器中，用于控制定时器0的启停。</td><td align="left"><code>TR0 = 1;</code> 启动定时器0开始计数。 <code>TR0 = 0;</code> 停止定时器0计数。</td></tr><tr><td align="left"><strong>ET0</strong></td><td align="left">Enable Timer 0 Interrupt (使能定时器0中断)</td><td align="left">位于IE（Interrupt Enable）寄存器中，用于允许或禁止定时器0中断。</td><td align="left"><code>ET0 = 1;</code> 允许定时器0溢出时产生中断。</td></tr><tr><td align="left"><strong>EA</strong></td><td align="left">Enable All interrupts (全局中断使能位)</td><td align="left">位于IE（Interrupt Enable）寄存器中，用于全局开启或关闭所有中断。</td><td align="left"><code>EA = 1;</code> 开启CPU总中断允许，否则所有中断都被屏蔽。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数码管和定时器&quot;&gt;&lt;a href=&quot;#数码管和定时器&quot; class=&quot;headerlink&quot; title=&quot;**数码管和定时器 **&quot;&gt;&lt;/a&gt;**数码管和定时器 **&lt;/h1&gt;&lt;h2 id=&quot;一、数码管基本原理&quot;&gt;&lt;a href=&quot;#一、数码管基本原理&quot; cla</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>4.I2C协议（PCF8591）</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/4.I2C%E5%8D%8F%E8%AE%AE(PCF8591)/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/4.I2C%E5%8D%8F%E8%AE%AE(PCF8591)/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:22.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I2C-协议（PCF8591）"><a href="#I2C-协议（PCF8591）" class="headerlink" title="I2C 协议（PCF8591）"></a>I2C 协议（PCF8591）</h1><p>本文档记录了 I2C 通信协议的基础知识以及 PCF8591 芯片（8位AD&#x2F;DA转换器）的应用细节。</p><h2 id="🏗️-整体架构"><a href="#🏗️-整体架构" class="headerlink" title="🏗️ 整体架构"></a>🏗️ 整体架构</h2><h3 id="三层关系图"><a href="#三层关系图" class="headerlink" title="三层关系图"></a>三层关系图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TEXT┌─────────────────────────────────────────┐</span><br><span class="line">│  应用层：PCF8591芯片                     │</span><br><span class="line">│  ├─ 硬件功能：4路AD + 1路DA              │</span><br><span class="line">│  ├─ 设备地址：0x90/0x91                 │</span><br><span class="line">│  └─ 控制逻辑：寄存器/控制字节            │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  通信层：I2C协议                         │</span><br><span class="line">│  ├─ 7个基础函数（通用所有I2C设备）       │</span><br><span class="line">│  └─ 时序：Start/Stop/应答/数据传输       │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  硬件层：51单片机GPIO                    │</span><br><span class="line">│  ├─ SCL：P2.1（时钟线）                 │</span><br><span class="line">│  └─ SDA：P2.0（数据线）                 │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="整体架构与类比"><a href="#整体架构与类比" class="headerlink" title="整体架构与类比"></a>整体架构与类比</h2><p>I2C 相关的开发可以理解为分层结构：</p><table><thead><tr><th align="left">层次</th><th align="left">负责内容</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><strong>应用层</strong></td><td align="left">PCF8591 芯片功能逻辑、地址、控制字节。</td><td align="left">读取 AIN1，设置 DA 输出 150。</td></tr><tr><td align="left"><strong>通信层</strong></td><td align="left">I2C 协议的通用实现（Start&#x2F;Stop、应答、数据发送）。</td><td align="left"><strong>7个</strong>基础 I2C 函数（与设备无关）。</td></tr><tr><td align="left"><strong>硬件层</strong></td><td align="left">51单片机与 SCL&#x2F;SDA 引脚的 GPIO 操作。</td><td align="left">控制 P2.1 (SCL) 和 P2.0 (SDA) 的高低电平。</td></tr></tbody></table><h2 id="1-I2C-通信协议基础-Inter-Integrated-Circuit"><a href="#1-I2C-通信协议基础-Inter-Integrated-Circuit" class="headerlink" title="1. I2C 通信协议基础 (Inter-Integrated Circuit)"></a>1. I2C 通信协议基础 (Inter-Integrated Circuit)</h2><p>I2C 是一种由飞利浦（NXP）开发的<strong>同步、多主&#x2F;从、两线同步串行通信协议</strong>，主要用于短距离内连接低速外设。</p><ul><li><p>**SCL (Serial Clock Line，串行时钟线)**由主设备（Master）产生，用于同步数据传输。</p></li><li><p><strong>SDA (Serial Data Line，串行数据线):</strong> 用于传输数据。</p></li></ul><h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><table><thead><tr><th align="left">特点</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>线路</strong></td><td align="left">仅需 <strong>SCL</strong> (时钟线) 和 <strong>SDA</strong> (数据线) 两条线，均需<strong>上拉电阻</strong>。</td></tr><tr><td align="left"><strong>同步性</strong></td><td align="left"><strong>SCL</strong> 线上的时钟信号同步所有数据位传输。</td></tr><tr><td align="left"><strong>主从架构</strong></td><td align="left"><strong>主设备 (Master)</strong> 控制通信时序，<strong>从设备 (Slave)</strong> 响应请求，每个从设备有唯一的地址。</td></tr></tbody></table><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/i2c%E5%8D%8F%E8%AE%AE.png"></p><p>一个标准的 I2C 通信包括以下步骤：</p><ol><li><p><strong>起始条件 (Start):</strong> SCL 为高电平，SDA 从高电平拉低。</p></li><li><p><strong>发送地址:</strong> 主设备发送 7 位地址 + 1 位 <strong>R&#x2F;W</strong> 位（0&#x3D;写，1&#x3D;读）。</p></li><li><p><strong>应答 (ACK&#x2F;NACK):</strong> 被寻址的从设备必须将 SDA 拉低（ACK）。</p></li><li><p><strong>数据传输:</strong> 以 **8 位（1字节）**为单位进行交换，每字节后都需要应答。</p></li><li><p><strong>停止条件 (Stop):</strong> SCL 为高电平，SDA 从低电平拉高，释放总线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iic.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line"></span><br><span class="line">#define DELAY_TIME 5 //原来是10</span><br><span class="line"></span><br><span class="line">#define Photo_Res_Channel 0x41</span><br><span class="line">#define Adj_Res_Channel 0x43</span><br><span class="line"></span><br><span class="line">//总线引脚定义</span><br><span class="line">sbit SDA = P2^1;  /* 数据线 */</span><br><span class="line">sbit SCL = P2^0;  /* 时钟线 */</span><br><span class="line"></span><br><span class="line">void IIC_Delay(unsigned char i)</span><br><span class="line">&#123;</span><br><span class="line">    do&#123;_nop_();&#125;</span><br><span class="line">    while(i--);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//总线启动条件</span><br><span class="line">void IIC_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA = 1;</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = 0;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//总线停止条件</span><br><span class="line">void IIC_Stop(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA = 0;</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送应答</span><br><span class="line">void IIC_SendAck(bit ackbit)</span><br><span class="line">&#123;</span><br><span class="line">    SCL = 0;</span><br><span class="line">    SDA = ackbit;  // 0：应答，1：非应答</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 0; </span><br><span class="line">    SDA = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待应答</span><br><span class="line">bit IIC_WaitAck(void)</span><br><span class="line">&#123;</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL  = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = 0;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    return ackbit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过I2C总线发送数据</span><br><span class="line">void IIC_SendByte(unsigned char byt)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i;</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SCL  = 0;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        if(byt &amp; 0x80) SDA  = 1;</span><br><span class="line">        else SDA  = 0;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = 1;</span><br><span class="line">        byt &lt;&lt;= 1;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    SCL  = 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从I2C总线上接收数据</span><br><span class="line">unsigned char IIC_RecByte(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i, da;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">    SCL = 1;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">da &lt;&lt;= 1;</span><br><span class="line">if(SDA) da |= 1;</span><br><span class="line">SCL = 0;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    return da;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="2-AD-DA-转换功能层"><a href="#2-AD-DA-转换功能层" class="headerlink" title="2. AD&#x2F;DA 转换功能层"></a>2. AD&#x2F;DA 转换功能层</h2><h3 id="什么是-AD-DA？"><a href="#什么是-AD-DA？" class="headerlink" title="什么是 AD&#x2F;DA？"></a>什么是 AD&#x2F;DA？</h3><h4 id="A-D-转换-Analog-to-Digital-ADC"><a href="#A-D-转换-Analog-to-Digital-ADC" class="headerlink" title="A&#x2F;D 转换 (Analog to Digital - ADC)"></a>A&#x2F;D 转换 (Analog to Digital - ADC)</h4><p>将连续的**模拟信号（电压）**转换为离散的**数字信号（0-255，8位）**。</p><p>模拟信号(0−5V)→ADC数字信号(0−255)模拟信号(0−5<em>V</em>)ADC数字信号(0−255)</p><ul><li><strong>示例:</strong> 输入 2.5V→2.5V→ 输出 127127 (约一半)。</li></ul><h4 id="D-A-转换-Digital-to-Analog-DAC"><a href="#D-A-转换-Digital-to-Analog-DAC" class="headerlink" title="D&#x2F;A 转换 (Digital to Analog - DAC)"></a>D&#x2F;A 转换 (Digital to Analog - DAC)</h4><p>将**数字信号（0-255）**转换为**模拟信号（电压）**。</p><p>数字信号(0−255)→DAC模拟信号(0−5V)数字信号(0−255)DAC模拟信号(0−5<em>V</em>)</p><ul><li><strong>示例:</strong> 输入 127→127→ 输出 ≈2.5V≈2.5V。</li></ul><h3 id="51单片机的局限与-PCF8591-的补充"><a href="#51单片机的局限与-PCF8591-的补充" class="headerlink" title="51单片机的局限与 PCF8591 的补充"></a>51单片机的局限与 PCF8591 的补充</h3><table><thead><tr><th align="left">设备</th><th align="left">限制&#x2F;能力</th></tr></thead><tbody><tr><td align="left"><strong>51单片机</strong></td><td align="left">只能识别和输出数字信号（0&#x2F;1）。</td></tr><tr><td align="left"><strong>PCF8591</strong></td><td align="left"><strong>4路AD</strong> (读取传感器) + <strong>1路DA</strong> (输出控制电压)。</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><table><thead><tr><th align="center">功能</th><th align="center">输入类型</th><th align="center">输出类型</th><th align="center">应用实例</th></tr></thead><tbody><tr><td align="center"><strong>AD</strong></td><td align="center">模拟传感器</td><td align="center">数字值</td><td align="center">温度检测、光照检测</td></tr><tr><td align="center"><strong>DA</strong></td><td align="center">数字值</td><td align="center">模拟电压</td><td align="center">LED调光、声音输出</td></tr></tbody></table><h2 id="🔧-PCF8591应用层"><a href="#🔧-PCF8591应用层" class="headerlink" title="🔧 PCF8591应用层"></a>🔧 PCF8591应用层</h2><h3 id="1-芯片概述"><a href="#1-芯片概述" class="headerlink" title="1. 芯片概述"></a>1. 芯片概述</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105134801.png"></p><p><strong>PCF8591 &#x3D; 8位AD&#x2F;DA转换器 + I2C接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEXT芯片引脚：</span><br><span class="line">  AIN0-AIN3：4路模拟输入（AD）</span><br><span class="line">  AOUT：     1路模拟输出（DA）</span><br><span class="line">  SCL/SDA：  I2C通信接口</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105211035.png"></p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105343352.png"></p><h3 id="2-设备地址（来自数据手册"><a href="#2-设备地址（来自数据手册" class="headerlink" title="2. 设备地址（来自数据手册)"></a>2. 设备地址（来自数据手册)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C// 地址格式：1001 A2 A1 A0 R/W</span><br><span class="line">// A2/A1/A0由硬件引脚决定（通常接地）</span><br><span class="line"></span><br><span class="line">#define PCF8591_ADDR_W  0x90  // 1001 0000 (写)</span><br><span class="line">#define PCF8591_ADDR_R  0x91  // 1001 0001 (读)</span><br></pre></td></tr></table></figure><p><strong>地址推导</strong>：</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105438501.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT基础地址：1001 000X</span><br><span class="line">         ││││ │││└─ R/W位</span><br><span class="line">         ││││ │└─── A0引脚（0=GND）</span><br><span class="line">         ││││ └──── A1引脚（0=GND）</span><br><span class="line">         │││└────── A2引脚（0=GND）</span><br><span class="line">         └┴┴─────── 固定标识</span><br><span class="line"></span><br><span class="line">写地址：1001 0000 = 0x90</span><br><span class="line">读地址：1001 0001 = 0x91</span><br></pre></td></tr></table></figure><hr><h3 id="3-控制字节（来自数据手册）"><a href="#3-控制字节（来自数据手册）" class="headerlink" title="3. 控制字节（来自数据手册）"></a>3. 控制字节（来自数据手册）</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105510306.png">]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 控制字节格式：</span><br><span class="line">// bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0</span><br><span class="line">//  0   | DAC  | AIN2 | AIN1 | AIN0 |  0   | Auto | Auto</span><br><span class="line">//        使能   通道选择(0-3)         自动增量模式</span><br><span class="line"></span><br><span class="line">//滑动变阻器 0000 1000</span><br><span class="line">#define PCF8591_DAC_OFF  0x00  // 0000 0000</span><br><span class="line">#define PCF8591_DAC_ON   0x40  // 0100 0000</span><br></pre></td></tr></table></figure><h3 id="AD-读取函数"><a href="#AD-读取函数" class="headerlink" title="AD 读取函数"></a>AD 读取函数</h3><p><strong>PCF8591 读取特点:</strong> 每次使用读地址 <code>0x91</code> 通信时，它会返回<strong>两个字节</strong>：第一个是状态&#x2F;控制字，第二个才是我们需要的 AD 数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Ad_Read(unsigned char addr)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char temp;</span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_SendByte(0x90);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line">IIC_SendByte(addr);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_SendByte(0x91);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line">temp = IIC_RecByte();</span><br><span class="line">IIC_SendAck(1);//应带信号  只有主机接收信号才需要发送</span><br><span class="line">IIC_Stop();</span><br><span class="line">return temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DA-输出函数"><a href="#DA-输出函数" class="headerlink" title="DA 输出函数"></a>DA 输出函数</h3><p>要通过 DA 输出一个数字值 <code>dat</code> (0-255)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Da_Write(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_Start();                   // 1. START信号</span><br><span class="line">    IIC_SendByte(0x90);            // 2. 发送写地址 (0x90)</span><br><span class="line">    IIC_WaitAck();                 // 3. 等待应答</span><br><span class="line">    IIC_SendByte(0x40);            // 4. 发送控制字节 (DAC使能)</span><br><span class="line">    IIC_WaitAck();                 // 5. 等待应答</span><br><span class="line">    IIC_SendByte(dat);             // 6. 发送DA值 (0-255)</span><br><span class="line">    IIC_WaitAck();                 // 7. 等待应答</span><br><span class="line">    IIC_Stop();                    // 8. STOP信号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p> <strong>易错点</strong>：混淆<code>IIC_SendByte</code>和<code>IIC_SendAck</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I2C-协议（PCF8591）&quot;&gt;&lt;a href=&quot;#I2C-协议（PCF8591）&quot; class=&quot;headerlink&quot; title=&quot;I2C 协议（PCF8591）&quot;&gt;&lt;/a&gt;I2C 协议（PCF8591）&lt;/h1&gt;&lt;p&gt;本文档记录了 I2C 通信协议的基础</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>6.DS1302实时时钟</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/6.DS1302/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/6.DS1302/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:37.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🕰️-DS1302-实时钟芯片学习笔记"><a href="#🕰️-DS1302-实时钟芯片学习笔记" class="headerlink" title="🕰️ DS1302 实时钟芯片学习笔记"></a>🕰️ DS1302 实时钟芯片学习笔记</h1><h2 id="一、DS1302-通讯协议"><a href="#一、DS1302-通讯协议" class="headerlink" title="一、DS1302 通讯协议"></a>一、DS1302 通讯协议</h2><p>DS1302 采用 <strong>Dallas&#x2F;Maxim 三线同步串行接口</strong>（专有协议）。</p><h3 id="1-信号线"><a href="#1-信号线" class="headerlink" title="1. 信号线"></a>1. 信号线</h3><p>芯片仅需 3 根信号线进行通信：</p><ul><li><strong>SCLK</strong>：串行时钟（<strong>主机输出</strong>）</li><li><strong>I&#x2F;O</strong>：双向数据线（<strong>开漏输出</strong>，必须外接上拉电阻）</li><li><strong>RST</strong>：片选&#x2F;复位（高电平有效，<strong>通信开始&#x2F;结束标志</strong>）</li></ul><h3 id="2-通信规则"><a href="#2-通信规则" class="headerlink" title="2. 通信规则"></a>2. 通信规则</h3><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>开始</strong></td><td>必须先拉高 <strong>RST</strong></td></tr><tr><td><strong>流程</strong></td><td>先发送 <strong>1 字节命令</strong> → 再读&#x2F;写 <strong>1 字节或多个字节数据</strong></td></tr><tr><td><strong>数据顺序</strong></td><td>数据传输时，<strong>低位在前 (LSB first)</strong></td></tr><tr><td><strong>结束</strong></td><td>必须拉低 <strong>RST</strong></td></tr></tbody></table><h2 id="二、程序中常用命令"><a href="#二、程序中常用命令" class="headerlink" title="二、程序中常用命令"></a>二、程序中常用命令</h2><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251120213917095.png" alt="image-20251120213917095"></p><h3 id="⚠️-编程重要提醒"><a href="#⚠️-编程重要提醒" class="headerlink" title="⚠️ 编程重要提醒"></a>⚠️ 编程重要提醒</h3><ol><li><strong>写保护控制：</strong><ul><li><strong>关闭写保护</strong>（允许写入）：<code>Write_Ds1302_Byte(0x8E, 0x00);</code></li><li><strong>打开写保护</strong>（禁止写入）：<code>Write_Ds1302_Byte(0x8E, 0x80);</code></li></ul></li><li><strong>时间启动：</strong><ul><li>在写入<strong>秒寄存器</strong> (<code>0x80</code>) 的值时，必须确保其 <strong>CH 位 (bit7) 为 0</strong>，即需要对写入值进行 <code>&amp; 0x7F</code> 操作，否则时间将停止。</li></ul></li></ol><h2 id="三、程序中的数据转换：十进制-↔-BCD-码"><a href="#三、程序中的数据转换：十进制-↔-BCD-码" class="headerlink" title="三、程序中的数据转换：十进制 ↔ BCD 码"></a>三、程序中的数据转换：十进制 ↔ BCD 码</h2><p>DS1302 的所有时间&#x2F;日期<strong>寄存器</strong>都使用<strong>BCD (Binary-Coded Decimal) 码</strong> 存储数据，而不是纯二进制。</p><h3 id="1-十进制-→-BCD-码（写入时使用）"><a href="#1-十进制-→-BCD-码（写入时使用）" class="headerlink" title="1. 十进制 → BCD 码（写入时使用）"></a>1. 十进制 → BCD 码（写入时使用）</h3><p>将十进制数拆分为“十位”和“个位”，并分别放入 BCD 字节的高 4 位和低 4 位。<br>$$<br>BCD &#x3D; \left(\frac{十进制}{10} \ll 4\right) ; \mid ; \left(十进制 \bmod 10\right)<br>$$<br>或使用加法：<br>$$<br>BCD &#x3D; \left(\left(\frac{十进制}{10}\right) \ll 4\right) + \left(十进制 \bmod 10\right)<br>$$<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23 → (2&lt;&lt;4)|3 = 0x23</span><br><span class="line">09 → (0&lt;&lt;4)|9 = 0x09</span><br><span class="line">58 → 0x58</span><br></pre></td></tr></table></figure><h3 id="2-BCD-码-→-十进制（读取时使用）"><a href="#2-BCD-码-→-十进制（读取时使用）" class="headerlink" title="2. BCD 码 → 十进制（读取时使用）"></a>2. BCD 码 → 十进制（读取时使用）</h3><p>将 BCD 字节的高 4 位乘以 10，然后加上低 4 位。<br>$$<br>十进制 &#x3D; \left(\frac{BCD}{16}\right) \times 10 + \left(BCD \bmod 16\right)<br>$$<br>或使用移位操作：<br>$$<br>十进制 &#x3D; \left(BCD \gg 4\right) \times 10 + \left(BCD \land 0x0F\right)<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x23 → (2)*10 + 3 = 23</span><br><span class="line">0x59 → 5*10 + 9 = 59</span><br></pre></td></tr></table></figure><h3 id="3-完整写入年月日时分秒"><a href="#3-完整写入年月日时分秒" class="headerlink" title="3. 完整写入年月日时分秒"></a>3. 完整写入年月日时分秒</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251120221158940.png" alt="image-20251120221158940"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit SDA = P2 ^ 3;</span><br><span class="line">sbit RST = P1 ^ 3;</span><br><span class="line">sbit SCK = P1 ^ 7;</span><br><span class="line"></span><br><span class="line">// Write_Ds1302_Byte(addr,dat)</span><br><span class="line">void Set_Rtc(unsigned char *ucRtc)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char i;</span><br><span class="line">  Write_Ds1302_Byte(0x8e, 0x00); // 禁止写保护 控制寄存器 bit7 是 WP 位，0=允许写入所有寄存器</span><br><span class="line">  Write_Ds1302_Byte(0x80, 0x80); // 暂停设备运行</span><br><span class="line">  for (i = 0; i &lt; 3; i++)</span><br><span class="line">    Write_Ds1302_Byte(0x84 - 2 * i, ucRtc[i] / 10 % 10 &lt;&lt; 4 | ucRtc[i] % 10);//十进制整数转换为BCD码 时分秒顺序</span><br><span class="line">    // 这行代码把一个十进制数（比如23）转换成了BCD码（`0010 0011`，即0x23）。</span><br><span class="line">  Write_Ds1302_Byte(0x8e, 0x80);//写保护</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Read_Rtc(unsigned char *ucRtc)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char i;</span><br><span class="line">  unsigned temp;</span><br><span class="line">  EA = 0; // 关闭总中断，防止时序错误</span><br><span class="line">  for (i = 0; i &lt; 3; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = Read_Ds1302_Byte(0x85 - 2 * i);</span><br><span class="line">    ucRtc[i] = temp / 16 * 10 + temp % 16;//BCD码到十进制数的转换。</span><br><span class="line">    //这行代码把BCD码（比如0x23）转换回了十进制数23。</span><br><span class="line">  &#125;</span><br><span class="line">  EA = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🕰️-DS1302-实时钟芯片学习笔记&quot;&gt;&lt;a href=&quot;#🕰️-DS1302-实时钟芯片学习笔记&quot; class=&quot;headerlink&quot; title=&quot;🕰️ DS1302 实时钟芯片学习笔记&quot;&gt;&lt;/a&gt;🕰️ DS1302 实时钟芯片学习笔记&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>3.单总线协议详解（DS18B20 ）</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/3.one_wire%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88DS18B20%EF%BC%89/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/3.one_wire%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88DS18B20%EF%BC%89/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:15.828Z</updated>
    
    <content type="html"><![CDATA[<p>​</p><h1 id="单总线协议详解（DS18B20-）"><a href="#单总线协议详解（DS18B20-）" class="headerlink" title="单总线协议详解（DS18B20 ）"></a>单总线协议详解（DS18B20 ）</h1><hr><h2 id="一、单总线协议基础"><a href="#一、单总线协议基础" class="headerlink" title="一、单总线协议基础"></a>一、单总线协议基础</h2><h3 id="1-1-什么是单总线？"><a href="#1-1-什么是单总线？" class="headerlink" title="1.1 什么是单总线？"></a>1.1 什么是单总线？</h3><p><strong>单总线（1-Wire）</strong> 是 Dallas&#x2F;Maxim 公司开发的一种串行通信协议。</p><p><strong>核心特点：</strong></p><ul><li>✅ 只需 1 根数据线 <strong>Data Queue</strong> （DQ）+ 1 根地线（GND）</li><li>✅ 支持多设备挂载（每个设备有唯一 64 位 ROM 码）</li><li>✅ 半双工通信（同一时刻只能单向传输）</li><li>✅ 主从架构（MCU 是主机，传感器是从机）</li></ul><p><strong>硬件连接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT        VCC (3.3V/5V)</span><br><span class="line">         |</span><br><span class="line">        [R] 4.7kΩ 上拉电阻</span><br><span class="line">         |</span><br><span class="line">MCU -----+-------- DS18B20 (DQ)</span><br><span class="line">         |</span><br><span class="line">        GND</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-开漏输出原理（重要！）"><a href="#1-2-开漏输出原理（重要！）" class="headerlink" title="1.2 开漏输出原理（重要！）"></a>1.2 开漏输出原理（重要！）</h3><p>单总线使用 <strong>开漏输出（Open-Drain）</strong> 模式：</p><table><thead><tr><th align="left">MCU 操作</th><th align="left">DQ 引脚状态</th><th align="left">实际电平</th></tr></thead><tbody><tr><td align="left"><code>DQ = 0</code></td><td align="left">强制拉低</td><td align="left">低电平（0V）</td></tr><tr><td align="left"><code>DQ = 1</code></td><td align="left"><strong>释放总线</strong>（高阻态）</td><td align="left">高电平（由上拉电阻决定）</td></tr></tbody></table><p><strong>关键理解：</strong></p><ul><li><code>DQ = 1</code> <strong>不是</strong>主动输出高电平，而是”松手”让上拉电阻把总线拉高</li><li>从机可以在总线被释放后拉低总线（实现数据传输）</li></ul><hr><h2 id="二、单总线时序（通用规则）"><a href="#二、单总线时序（通用规则）" class="headerlink" title="二、单总线时序（通用规则）"></a>二、单总线时序（通用规则）</h2><h3 id="2-1-初始化时序（复位-应答）"><a href="#2-1-初始化时序（复位-应答）" class="headerlink" title="2.1 初始化时序（复位 + 应答）"></a>2.1 初始化时序（复位 + 应答）</h3><p><strong>目的：</strong> 确认设备在线</p><p><strong>流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT主机动作：</span><br><span class="line">1. 拉低总线 ≥480μs（发送复位脉冲）</span><br><span class="line">2. 释放总线</span><br><span class="line">3. 等待 15~60μs</span><br><span class="line">4. 读取总线电平</span><br><span class="line"></span><br><span class="line">从机响应：</span><br><span class="line">- 检测到复位脉冲后，拉低总线 60~240μs（应答脉冲）</span><br><span class="line">- 返回 0 = 在线，返回 1 = 无响应</span><br></pre></td></tr></table></figure><p><strong>波形图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXTMCU:  ────┐     ┌─────────────</span><br><span class="line">          │ 480μs│</span><br><span class="line">          └─────┘</span><br><span class="line"></span><br><span class="line">DS:   ─────────┐   ┌─────────</span><br><span class="line">               │60~│240μs</span><br><span class="line">               └───┘ 应答脉冲</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bit init_ds18b20(void)</span><br><span class="line">   &#123;</span><br><span class="line">       bit initflag = 0;</span><br><span class="line">       </span><br><span class="line">       DQ = 1;         // 拉高总线，准备</span><br><span class="line">       Delay_OneWire(12);</span><br><span class="line">       DQ = 0;         // 产生复位脉冲 (拉低 &gt; 480us)</span><br><span class="line">       Delay_OneWire(80);</span><br><span class="line">       DQ = 1;         // 释放总线，等待DS18B20响应</span><br><span class="line">       Delay_OneWire(10); </span><br><span class="line">       initflag = DQ;  // 检测应答脉冲 (低电平表示存在)</span><br><span class="line">       Delay_OneWire(5);</span><br><span class="line">       </span><br><span class="line">       return initflag; // 返回0表示存在，1表示不存在</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-写时序（主机发送数据）"><a href="#2-2-写时序（主机发送数据）" class="headerlink" title="2.2 写时序（主机发送数据）"></a>2.2 写时序（主机发送数据）</h3><p><strong>原则：</strong> 通过 <strong>拉低时间长短</strong> 区分 0 和 1</p><h4 id="写-0"><a href="#写-0" class="headerlink" title="写 0"></a>写 0</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 拉低 60~120μs</span><br><span class="line">2. 释放总线</span><br><span class="line">TEXTDQ: ────┐           ┌───</span><br><span class="line">        │  60~120μs │</span><br><span class="line">        └───────────┘</span><br></pre></td></tr></table></figure><h4 id="写-1"><a href="#写-1" class="headerlink" title="写 1"></a>写 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 拉低 1~15μs（短脉冲）</span><br><span class="line">2. 立即释放总线</span><br><span class="line">3. 保持高电平至时间槽结束</span><br><span class="line">TEXTDQ: ────┐┌──────────</span><br><span class="line">        ││ &lt;15μs</span><br><span class="line">        └┘</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Write_DS18B20(unsigned char dat)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char i;</span><br><span class="line">        for(i=0; i&lt;8; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DQ = 0;             // 开始写时序，拉低总线</span><br><span class="line">            DQ = dat &amp; 0x01;    // 写入数据位 (0或1)</span><br><span class="line">            Delay_OneWire(5);   // 保持 &gt; 60us</span><br><span class="line">            DQ = 1;             // 释放总线</span><br><span class="line">            dat &gt;&gt;= 1;          // 准备下一位数据</span><br><span class="line">        &#125;</span><br><span class="line">        Delay_OneWire(5);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-读时序（从机发送数据）"><a href="#2-3-读时序（从机发送数据）" class="headerlink" title="2.3 读时序（从机发送数据）"></a>2.3 读时序（从机发送数据）</h3><p><strong>原则：</strong> 主机触发，从机控制总线电平</p><p><strong>流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 主机拉低总线 1μs（触发信号）</span><br><span class="line">2. 主机释放总线</span><br><span class="line">3. 等待 10~15μs 后采样总线电平</span><br><span class="line">   - 低电平 = 0</span><br><span class="line">   - 高电平 = 1</span><br></pre></td></tr></table></figure><p><strong>波形图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TEXT读到 0:</span><br><span class="line">MCU:  ───┐┌────────</span><br><span class="line">         ││ 1μs</span><br><span class="line">         └┘</span><br><span class="line">DS:   ────┐        ┌───</span><br><span class="line">          │ 从机拉低 │</span><br><span class="line">          └────────┘</span><br><span class="line"></span><br><span class="line">读到 1:</span><br><span class="line">MCU:  ───┐┌────────</span><br><span class="line">         └┘</span><br><span class="line">DS:   ──────────────  (从机不拉低，保持高电平)</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Read_DS18B20(void)</span><br><span class="line">   &#123;</span><br><span class="line">       unsigned char i;</span><br><span class="line">       unsigned char dat = 0; // 初始化为0</span><br><span class="line">       </span><br><span class="line">       for(i=0; i&lt;8; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           DQ = 0;             // 开始读时序，拉低总线</span><br><span class="line">           dat &gt;&gt;= 1;          // 右移一位，准备接收新数据</span><br><span class="line">           DQ = 1;             // 释放总线，让DS18B20控制</span><br><span class="line">           if(DQ)              // 在15us内读取总线电平</span><br><span class="line">           &#123;</span><br><span class="line">               dat |= 0x80;    // 如果为高电平，则最高位置1</span><br><span class="line">           &#125;    </span><br><span class="line">           Delay_OneWire(5);   // 等待读周期结束</span><br><span class="line">       &#125;</span><br><span class="line">       return dat;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、单总线通信流程"><a href="#三、单总线通信流程" class="headerlink" title="三、单总线通信流程"></a>三、单总线通信流程</h2><h3 id="3-1-标准流程（固定顺序）"><a href="#3-1-标准流程（固定顺序）" class="headerlink" title="3.1 标准流程（固定顺序）"></a>3.1 标准流程（固定顺序）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 初始化        ← 握手确认设备在线</span><br><span class="line">   ↓</span><br><span class="line">2. ROM 操作      ← 选择/跳过设备</span><br><span class="line">   ↓</span><br><span class="line">3. 功能指令      ← 发送设备特定命令</span><br><span class="line">   ↓</span><br><span class="line">4. 数据传输      ← 读取或写入数据</span><br></pre></td></tr></table></figure><p><strong>每次通信必须从初始化开始！</strong></p><hr><h3 id="3-2-ROM-操作指令（所有单总线设备通用）"><a href="#3-2-ROM-操作指令（所有单总线设备通用）" class="headerlink" title="3.2 ROM 操作指令（所有单总线设备通用）"></a>3.2 ROM 操作指令（所有单总线设备通用）</h3><table><thead><tr><th align="center">指令码</th><th align="left">名称</th><th align="left">功能</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="center"><code>0xCC</code></td><td align="left">Skip ROM</td><td align="left">跳过 ROM 匹配</td><td align="left"><strong>单设备</strong>系统（最常用）</td></tr><tr><td align="center"><code>0x55</code></td><td align="left">Match ROM</td><td align="left">选择特定设备</td><td align="left">多设备总线</td></tr><tr><td align="center"><code>0x33</code></td><td align="left">Read ROM</td><td align="left">读取 64 位 ROM 码</td><td align="left">获取设备 ID</td></tr><tr><td align="center"><code>0xF0</code></td><td align="left">Search ROM</td><td align="left">搜索所有设备</td><td align="left">设备枚举</td></tr></tbody></table><hr><h2 id="四、DS18B20-专属内容"><a href="#四、DS18B20-专属内容" class="headerlink" title="四、DS18B20 专属内容"></a>四、DS18B20 专属内容</h2><h3 id="4-1-功能指令（DS18B20-特定）"><a href="#4-1-功能指令（DS18B20-特定）" class="headerlink" title="4.1 功能指令（DS18B20 特定）"></a>4.1 功能指令（DS18B20 特定）</h3><table><thead><tr><th align="center">指令码</th><th align="left">名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center"><code>0x44</code></td><td align="left">Convert T</td><td align="left">启动温度转换（耗时 750ms）</td></tr><tr><td align="center"><code>0xBE</code></td><td align="left">Read Scratchpad</td><td align="left">读取暂存器（含温度数据）</td></tr><tr><td align="center"><code>0x4E</code></td><td align="left">Write Scratchpad</td><td align="left">写入配置（精度、报警阈值）</td></tr></tbody></table><hr><h3 id="4-2-暂存器结构（9-字节）"><a href="#4-2-暂存器结构（9-字节）" class="headerlink" title="4.2 暂存器结构（9 字节）"></a>4.2 暂存器结构（9 字节）</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111104128787.png"></p><p>调用 <code>0xBE</code> 后，DS18B20 按顺序发送：</p><table><thead><tr><th align="center">字节索引</th><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">Byte 0</td><td align="left">温度低 8 位（LSB）</td><td align="left">第1次 <code>Read_DS18B20()</code></td></tr><tr><td align="center">Byte 1</td><td align="left">温度高 8 位（MSB）</td><td align="left">第2次 <code>Read_DS18B20()</code></td></tr><tr><td align="center">Byte 2</td><td align="left">TH 寄存器</td><td align="left">高温报警阈值</td></tr><tr><td align="center">Byte 3</td><td align="left">TL 寄存器</td><td align="left">低温报警阈值</td></tr><tr><td align="center">Byte 4</td><td align="left">配置寄存器</td><td align="left">精度设置（9&#x2F;10&#x2F;11&#x2F;12位）</td></tr><tr><td align="center">Byte 5-7</td><td align="left">保留</td><td align="left">固定 0xFF</td></tr><tr><td align="center">Byte 8</td><td align="left">CRC 校验</td><td align="left">数据完整性校验</td></tr></tbody></table><hr><h3 id="4-3-温度数据格式"><a href="#4-3-温度数据格式" class="headerlink" title="4.3 温度数据格式"></a>4.3 温度数据格式</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111104239787.png"></p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105018620.png"></p><p><strong>16 位补码表示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEXT高字节 (MSB)              低字节 (LSB)</span><br><span class="line">S S S S S 2⁶ 2⁵ 2⁴   2³ 2² 2¹ 2⁰ 2⁻¹ 2⁻² 2⁻³ 2⁻⁴</span><br><span class="line">└─符号位─┘  └─整数部分─┘  └─────小数部分─────┘</span><br></pre></td></tr></table></figure><ul><li><strong>分辨率</strong>：0.0625°C（1&#x2F;16）</li><li><strong>范围</strong>：-55°C ~ +125°C</li></ul><p><strong>计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">温度 = (high &lt;&lt; 8 | low) / 16.0</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXT+25.0625°C:  0x0191 = 401 → 401/16 = 25.0625</span><br><span class="line">-10.125°C:   0xFF5E（补码）→ -162/16 = -10.125</span><br></pre></td></tr></table></figure><hr><h3 id="4-4-完整读取温度代码"><a href="#4-4-完整读取温度代码" class="headerlink" title="4.4 完整读取温度代码"></a>4.4 完整读取温度代码</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251114104523084.png" alt="image-20251114104523084"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;onewire.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit DQ = P1 ^ 4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float rd_temperature(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char low, high; // 用于存储温度的低位和高位字节</span><br><span class="line">   </span><br><span class="line">    init_ds18b20();         // 初始化DS18B20</span><br><span class="line">    Write_DS18B20(0xcc);    // 跳过ROM操作（适用于单总线只有一个设备的情况）</span><br><span class="line">    Write_DS18B20(0x44);    // 发送启动温度转换命令</span><br><span class="line"></span><br><span class="line">    init_ds18b20();         // 再次初始化DS18B20，准备读取</span><br><span class="line">    Write_DS18B20(0xcc);    // 跳过ROM操作</span><br><span class="line">    Write_DS18B20(0xbe);    // 发送读取暂存器命令</span><br><span class="line">    </span><br><span class="line">    low = Read_DS18B20();   // 读取温度值的低位字节</span><br><span class="line">    high = Read_DS18B20();  // 读取温度值的高位字节</span><br><span class="line">    </span><br><span class="line">    return ((high &lt;&lt; 8) | low) / 16.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Intrinsic Function（内嵌函数/固有函数）是一种特殊的函数。</span><br><span class="line">_nop_()：空操作（No Operation）。它会插入一个精确的机器周期延时，用于产生非常短的延时。</span><br><span class="line">_cror_()：循环右移（Circular Rotate Right）。</span><br><span class="line">_crol_()：循环左移（Circular Rotate Left）。</span><br><span class="line">_iror_()：带进位循环右移。</span><br><span class="line">_irol_()：带进位循环左移。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│         单总线 (One-Wire)            │  ← 通信协议（抽象规则）</span><br><span class="line">│   - 一种通信标准/协议                 │</span><br><span class="line">│   - 定义了时序规则                    │</span><br><span class="line">│   - 定义了通信流程                    │</span><br><span class="line">└──────────────┬──────────────────────┘</span><br><span class="line">               │ 遵循/实现</span><br><span class="line">               ▼</span><br><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│          DS18B20                    │  ← 具体芯片（实现者）</span><br><span class="line">│   - 一款温度传感器芯片                │</span><br><span class="line">│   - 使用单总线协议通信                │</span><br><span class="line">│   - 有自己特定的指令集                │</span><br><span class="line">└─────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		&lt;/p&gt;
&lt;h1 id=&quot;单总线协议详解（DS18B20-）&quot;&gt;&lt;a href=&quot;#单总线协议详解（DS18B20-）&quot; class=&quot;headerlink&quot; title=&quot;单总线协议详解（DS18B20 ）&quot;&gt;&lt;/a&gt;单总线协议详解（DS18B20 ）&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>7.NE555频率测量系统设计</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/7.NE555/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/7.NE555/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:49.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NE555频率测量系统设计"><a href="#NE555频率测量系统设计" class="headerlink" title="NE555频率测量系统设计"></a>NE555频率测量系统设计</h1><h2 id="📋-系统概述"><a href="#📋-系统概述" class="headerlink" title="📋 系统概述"></a>📋 系统概述</h2><p>基于NE555方波发生器和51单片机的频率测量系统，通过计数器模式精确测量外部脉冲频率。</p><hr><h2 id="🔧-硬件设计"><a href="#🔧-硬件设计" class="headerlink" title="🔧 硬件设计"></a>🔧 硬件设计</h2><h3 id="NE555原理图"><a href="#NE555原理图" class="headerlink" title="NE555原理图"></a>NE555原理图</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251121221438634.png" alt="NE555原理图"></p><h3 id="定时器数据手册"><a href="#定时器数据手册" class="headerlink" title="定时器数据手册"></a>定时器数据手册</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251121222129653.png" alt="定时器数据手册"></p><hr><h2 id="🏗️-系统整体框图"><a href="#🏗️-系统整体框图" class="headerlink" title="🏗️ 系统整体框图"></a>🏗️ 系统整体框图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  NE555方波发生器   |  ← 用来产生已知/可调频率的方波（相当于信号源）</span><br><span class="line">|  输出引脚3 (OUT)   |</span><br><span class="line">+--------+---------+</span><br><span class="line">         ↓ (一根信号线)</span><br><span class="line">   单片机 P3.4 (T0引脚)</span><br><span class="line">         ↓</span><br><span class="line">+--------v---------+</span><br><span class="line">|    51单片机内部    |</span><br><span class="line">|                   |</span><br><span class="line">|  T0：计数器模式    | ← 专门负责数外部脉冲个数（16位）</span><br><span class="line">|  T1：定时器模式    | ← 产生精确的1秒“闸门时间”</span><br><span class="line">|                   |</span><br><span class="line">|  每1秒读取一次T0   |</span><br><span class="line">|  计数值 → 频率值   |</span><br><span class="line">|  → 送数码管显示    |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="💻-程序设计"><a href="#💻-程序设计" class="headerlink" title="💻 程序设计"></a>💻 程序设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief 定时器0初始化函数</span><br><span class="line"> * 配置为计数器模式，用于测量外部脉冲频率。</span><br><span class="line"> */</span><br><span class="line">void Timer0_Init(void) // 1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F; // 定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0xF0; // 清除T0的模式位</span><br><span class="line">TMOD |= 0x05; // 设置为计数器模式(M1=0, M0=1, C/T=1)，外部引脚T0(P3.4)的下降沿计数</span><br><span class="line">TL0 = 0x00;  // 设置计数器初始值</span><br><span class="line">TH0 = 0x00;  // 设置计数器初始值</span><br><span class="line">TF0 = 0;  // 清除TF0溢出标志</span><br><span class="line">TR0 = 1;  // 定时器0开始工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 定时器1初始化函数</span><br><span class="line"> * 配置为1ms中断的定时器，作为系统的心跳。</span><br><span class="line"> */</span><br><span class="line">void Timer1_Init(void) // 1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0xBF; // 定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0x0F; // 设置定时器模式 (清空T1的设置)</span><br><span class="line">TL1 = 0x18;  // 设置定时初始值 (65536-1000) -&gt; FC18H</span><br><span class="line">TH1 = 0xFC;  // 设置定时初始值</span><br><span class="line">TF1 = 0;  // 清除TF1溢出标志</span><br><span class="line">TR1 = 1;  // 定时器1开始计时</span><br><span class="line">ET1 = 1;  // 使能定时器1中断</span><br><span class="line">EA = 1;  // 开启总中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 定时器1中断服务函数</span><br><span class="line"> * 每1ms执行一次，处理需要定时执行的任务。</span><br><span class="line"> */</span><br><span class="line">void Timer1_Isr(void) interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">uwTick++; // 系统滴答计时器加1</span><br><span class="line"></span><br><span class="line">// 频率测量，每1000ms (1s) 计算一次</span><br><span class="line">if (++Time_1s == 1000)</span><br><span class="line">&#123;</span><br><span class="line">Time_1s = 0; // 计时器清零</span><br><span class="line">// 读取T0的计数值，即为过去1秒内的脉冲数(Hz)</span><br><span class="line">Freq = (TH0 &lt;&lt; 8) | TL0;</span><br><span class="line">TH0 = TL0 = 0; // 清空T0计数器，开始下一个周期的测量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NE555频率测量系统设计&quot;&gt;&lt;a href=&quot;#NE555频率测量系统设计&quot; class=&quot;headerlink&quot; title=&quot;NE555频率测量系统设计&quot;&gt;&lt;/a&gt;NE555频率测量系统设计&lt;/h1&gt;&lt;h2 id=&quot;📋-系统概述&quot;&gt;&lt;a href=&quot;#📋</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>8.任务调度器</title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/8.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/8.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:42:58.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言结构体与任务调度器"><a href="#C语言结构体与任务调度器" class="headerlink" title="C语言结构体与任务调度器"></a>C语言结构体与任务调度器</h1><hr><h2 id="第一部分：C语言结构体基础"><a href="#第一部分：C语言结构体基础" class="headerlink" title="第一部分：C语言结构体基础"></a>第一部分：C语言结构体基础</h2><p>结构体是C语言中用于将不同类型的数据组合在一起的复合数据类型。在嵌入式开发中，它是实现多任务调度、管理复杂数据的基础。</p><h3 id="2-声明变量的三种方式"><a href="#2-声明变量的三种方式" class="headerlink" title="2. 声明变量的三种方式"></a>2. 声明变量的三种方式</h3><h4 id="方式一：先定义类型，再声明变量（标准写法）"><a href="#方式一：先定义类型，再声明变量（标准写法）" class="headerlink" title="方式一：先定义类型，再声明变量（标准写法）"></a>方式一：先定义类型，再声明变量（标准写法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span> <span class="title">task1</span>;</span></span><br></pre></td></tr></table></figure><h4 id="方式二：使用-typedef-定义别名（推荐写法）"><a href="#方式二：使用-typedef-定义别名（推荐写法）" class="headerlink" title="方式二：使用 typedef 定义别名（推荐写法）"></a>方式二：使用 <code>typedef</code> 定义别名（推荐写法）</h4><p>这样可以省略 <code>struct</code> 关键字，代码更简洁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125; Task_t; <span class="comment">// 这里的 Task_t 是类型名</span></span><br><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line">Task_t task2;</span><br></pre></td></tr></table></figure><h4 id="方式三：指定成员初始化（C99标准）"><a href="#方式三：指定成员初始化（C99标准）" class="headerlink" title="方式三：指定成员初始化（C99标准）"></a>方式三：指定成员初始化（C99标准）</h4><p>优点是初始化顺序不影响代码逻辑，可读性强。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task_t task3 = &#123;</span><br><span class="line">    .name = <span class="string">&quot;压力检测&quot;</span>,</span><br><span class="line">    .priority = <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-成员访问规则"><a href="#3-成员访问规则" class="headerlink" title="3. 成员访问规则"></a>3. 成员访问规则</h3><ul><li><strong><code>.</code> 点运算符</strong>：用于结构体<strong>变量</strong>。</li><li><strong><code>-&gt;</code> 箭头运算符</strong>：用于结构体<strong>指针</strong>。</li></ul><hr><h2 id="第二部分：任务调度器实战"><a href="#第二部分：任务调度器实战" class="headerlink" title="第二部分：任务调度器实战"></a>第二部分：任务调度器实战</h2><h3 id="1-定义结构体（画一张“任务卡”的模板）"><a href="#1-定义结构体（画一张“任务卡”的模板）" class="headerlink" title="1. 定义结构体（画一张“任务卡”的模板）"></a>1. 定义结构体（画一张“任务卡”的模板）</h3><p>这是调度器的核心数据结构，每个任务卡上记录了三个关键信息：</p><ol><li><strong>要做什么</strong>（函数指针）</li><li><strong>多久做一次</strong>（执行周期）</li><li><strong>上次什么时候做的</strong>（时间戳）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);          <span class="comment">// 【1】要执行的函数（函数指针）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> rate_ms;        <span class="comment">// 【2】每隔多少毫秒执行一次（固定值）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> last_ms;        <span class="comment">// 【3】上次执行的时间（会自己变）</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure><h3 id="2-创建任务列表（填写8张任务卡）"><a href="#2-创建任务列表（填写8张任务卡）" class="headerlink" title="2. 创建任务列表（填写8张任务卡）"></a>2. 创建任务列表（填写8张任务卡）</h3><p>利用<strong>结构体数组</strong>来存储所有任务。推荐使用指定成员初始化（<code>.成员名 = 值</code>），这样即使以后结构体成员顺序变了，代码也不会出错。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">idata <span class="type">task_t</span> Scheduler_Task[] = &#123;</span><br><span class="line">    &#123;Led_Proc, <span class="number">1</span>, <span class="number">0</span>&#125;,          <span class="comment">// LED任务，每1ms</span></span><br><span class="line">    &#123;Key_Proc, <span class="number">10</span>, <span class="number">0</span>&#125;,         <span class="comment">// 按键任务，每10ms</span></span><br><span class="line">    &#123;Seg_Proc, <span class="number">20</span>, <span class="number">0</span>&#125;,         <span class="comment">// 数码管任务，每20ms</span></span><br><span class="line">    &#123;Get_Time, <span class="number">100</span>, <span class="number">0</span>&#125;,        <span class="comment">// 获取时间任务，每100ms</span></span><br><span class="line">    &#123;Get_Temperature, <span class="number">300</span>, <span class="number">0</span>&#125;, <span class="comment">// 获取温度任务，每300ms</span></span><br><span class="line">    &#123;AD_DA, <span class="number">150</span>, <span class="number">0</span>&#125;,           <span class="comment">// AD/DA任务，每150ms</span></span><br><span class="line">    &#123;Get_Distance, <span class="number">120</span>, <span class="number">0</span>&#125;,    <span class="comment">// 获取距离任务，每120ms</span></span><br><span class="line">    &#123;Uart_Proc, <span class="number">10</span>, <span class="number">0</span>&#125;,        <span class="comment">// 串口处理任务，每10ms</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-初始化：自动计算任务数量"><a href="#3-初始化：自动计算任务数量" class="headerlink" title="3. 初始化：自动计算任务数量"></a>3. 初始化：自动计算任务数量</h3><p>不要手动去数数组里有几个任务，让计算机帮你算。这样以后增删任务时，不需要修改这里的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idata <span class="type">unsigned</span> <span class="type">char</span> task_num;   <span class="comment">// 任务数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduler_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 总字节数 / 单个结构体字节数 = 元素个数</span></span><br><span class="line">    task_num = <span class="keyword">sizeof</span>(Scheduler_Task) / <span class="keyword">sizeof</span>(<span class="type">task_t</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-核心运行函数（调度引擎）"><a href="#4-核心运行函数（调度引擎）" class="headerlink" title="4. 核心运行函数（调度引擎）"></a>4. 核心运行函数（调度引擎）</h3><p>这个函数通常放在主循环 <code>while(1)</code> 中。它会不断扫描任务列表，判断时间是否到了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Scheduler_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_time = uwTick;   <span class="comment">// 获取当前系统时间（需在定时器中断里维护 uwTick++）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; task_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断逻辑：当前时间 - 上次执行时间 &gt;= 周期</span></span><br><span class="line">        <span class="keyword">if</span>(now_time - Scheduler_Task[i].last_ms &gt;= Scheduler_Task[i].rate_ms)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 更新时间戳（记录这次执行的时间）</span></span><br><span class="line">            Scheduler_Task[i].last_ms = now_time;   </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 执行任务（调用对应的函数）</span></span><br><span class="line">            Scheduler_Task[i].task_func();          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-完整使用流程"><a href="#5-完整使用流程" class="headerlink" title="5. 完整使用流程"></a>5. 完整使用流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 系统硬件初始化</span></span><br><span class="line">    Timer0_Init();         <span class="comment">// 初始化定时器，1ms中断，在中断里维护 uwTick++</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 调度器初始化</span></span><br><span class="line">    Scheduler_Init();      <span class="comment">// 计算任务数量</span></span><br><span class="line">    <span class="comment">// 3. 主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Scheduler_Run();   <span class="comment">// 放在主循环里不断运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三部分：重点速查表"><a href="#第三部分：重点速查表" class="headerlink" title="第三部分：重点速查表"></a>第三部分：重点速查表</h2><h3 id="1-重点口诀（避坑指南）"><a href="#1-重点口诀（避坑指南）" class="headerlink" title="1. 重点口诀（避坑指南）"></a>1. 重点口诀（避坑指南）</h3><table><thead><tr><th align="left">项目</th><th align="left">正确写法</th><th align="left">错误写法</th><th align="left">原因解析</th></tr></thead><tbody><tr><td align="left"><strong>取成员</strong></td><td align="left"><code>Scheduler_Task[i].task_func()</code></td><td align="left"><code>Scheduler_Task[i]-&gt;task_func()</code></td><td align="left"><code>Scheduler_Task[i]</code> 是数组里的<strong>实体</strong>，必须用点号 <code>.</code></td></tr><tr><td align="left"><strong>初始化</strong></td><td align="left"><code>{ .task_func = xxx, .rate_ms = yyy }</code></td><td align="left">乱序写且不带点号</td><td align="left">指定成员初始化最安全，防止结构体成员顺序调整后程序崩溃</td></tr><tr><td align="left"><strong>调用函数</strong></td><td align="left"><code>task_func()</code></td><td align="left"><code>task_func</code></td><td align="left">不加括号只是获取函数地址，加括号才是<strong>执行</strong>函数</td></tr><tr><td align="left"><strong>计算数量</strong></td><td align="left"><code>sizeof(arr)/sizeof(task_t)</code></td><td align="left">手动写数字 8</td><td align="left">自动计算，以后增删任务不需要改代码</td></tr></tbody></table><h3 id="2-数据类型速查表"><a href="#2-数据类型速查表" class="headerlink" title="2. 数据类型速查表"></a>2. 数据类型速查表</h3><table><thead><tr><th align="left">类型</th><th align="left">占用字节</th><th align="left">范围（无符号）</th><th align="left">典型用途</th><th align="left">代码示例</th></tr></thead><tbody><tr><td align="left"><code>unsigned char</code></td><td align="left">1</td><td align="left">0 ~ 255</td><td align="left">普通标志位、端口、循环变量</td><td align="left"><code>unsigned char i;</code></td></tr><tr><td align="left"><code>unsigned int</code></td><td align="left">2</td><td align="left">0 ~ 65,535</td><td align="left">短延时、ADC数据采集</td><td align="left"><code>unsigned int ad_val;</code></td></tr><tr><td align="left"><code>unsigned long int</code></td><td align="left">4</td><td align="left">0 ~ 4,294,967,295</td><td align="left"><strong>时间戳、长计时</strong></td><td align="left"><code>uwTick</code>, <code>last_ms</code></td></tr><tr><td align="left"><code>unsigned long</code></td><td align="left">4</td><td align="left">同上</td><td align="left">省略写法，效果一样</td><td align="left"><code>unsigned long time;</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C语言结构体与任务调度器&quot;&gt;&lt;a href=&quot;#C语言结构体与任务调度器&quot; class=&quot;headerlink&quot; title=&quot;C语言结构体与任务调度器&quot;&gt;&lt;/a&gt;C语言结构体与任务调度器&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;第一部分：C语言结构体基础&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>9.串口通信 (UART) </title>
    <link href="https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/9.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(UART)/"/>
    <id>https://rosslin.xyz/2025/11/24/%E6%96%87%E7%AB%A0/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/9.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(UART)/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2026-01-27T15:43:05.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📝-串口通信-UART"><a href="#📝-串口通信-UART" class="headerlink" title="📝 串口通信 (UART)"></a>📝 串口通信 (UART)</h1><h2 id="1-串口-UART-是什么？"><a href="#1-串口-UART-是什么？" class="headerlink" title="1. 串口 (UART) 是什么？"></a>1. 串口 (UART) 是什么？</h2><p>串口是一种用于点对点设备间通信的<strong>异步串行</strong>通信协议。</p><h3 id="🚀-串口与-I²C-的核心对比"><a href="#🚀-串口与-I²C-的核心对比" class="headerlink" title="🚀 串口与 I²C 的核心对比"></a>🚀 串口与 I²C 的核心对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>串口 (UART)</strong></th><th><strong>I²C (已学)</strong></th></tr></thead><tbody><tr><td><strong>传输类型</strong></td><td><strong>串行</strong> (一位一位)</td><td><strong>串行</strong> (一位一位)</td></tr><tr><td><strong>同步性</strong></td><td><strong>异步</strong> (无时钟线)</td><td><strong>同步</strong> (有 SCL 时钟线)</td></tr><tr><td><strong>时钟源</strong></td><td><strong>内部定时器</strong>生成波特率时钟</td><td><strong>主设备</strong>通过 SCL 线提供外部时钟</td></tr><tr><td><strong>拓扑结构</strong></td><td><strong>点对点</strong> (多数情况)</td><td><strong>总线型</strong> (多主多从)</td></tr><tr><td><strong>地址寻址</strong></td><td><strong>不需要</strong>地址</td><td><strong>需要</strong>地址 (7&#x2F;10 位地址)</td></tr><tr><td><strong>双工性</strong></td><td><strong>全双工</strong> (TX&#x2F;RX 分离，可同时收发)</td><td><strong>半双工</strong> (SDA 线，分时收发)</td></tr><tr><td><strong>信号线</strong></td><td>2 根：TXD (发送), RXD (接收)</td><td>2 根：SDA (数据), SCL (时钟)</td></tr><tr><td><strong>核心机制</strong></td><td>波特率、起始位、停止位</td><td>起始&#x2F;停止信号、ACK&#x2F;NACK</td></tr></tbody></table><h3 id="🔍-串口的核心概念"><a href="#🔍-串口的核心概念" class="headerlink" title="🔍 串口的核心概念"></a>🔍 串口的核心概念</h3><ul><li><strong>异步 (Asynchronous):</strong> 收发双方必须约定<strong>波特率</strong>，通过数据帧中的<strong>起始位</strong>实现同步。</li><li><strong>波特率 (Baud Rate):</strong> 每秒传输的位数 (bps)，收发双方必须一致。</li><li><strong>数据帧:</strong> 一帧数据包含：<code>起始位 (1位, 低电平)</code> + <code>数据位 (5~8位)</code> + <code>校验位 (可选)</code> + <code>停止位 (1~2位, 高电平)</code>。</li><li><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF.png"></li></ul><h2 id="2-串口数据收发与解析方式"><a href="#2-串口数据收发与解析方式" class="headerlink" title="2. 串口数据收发与解析方式"></a>2. 串口数据收发与解析方式</h2><p>串口通信的思路可以分为底层<strong>数据驱动</strong>和上层<strong>数据解析</strong>。</p><h3 id="A-驱动层思路：数据接收方式-CPU如何获取数据"><a href="#A-驱动层思路：数据接收方式-CPU如何获取数据" class="headerlink" title="A. 驱动层思路：数据接收方式 (CPU如何获取数据)"></a>A. 驱动层思路：数据接收方式 (CPU如何获取数据)</h3><table><thead><tr><th><strong>方式</strong></th><th><strong>描述</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td>1.<strong>轮询&#x2F;查询 (Polling)</strong></td><td>CPU 不断查询接收标志位 (<code>RI</code>)，直到其置 1 时读取数据。</td><td><strong>优点:</strong> 代码简单。 <strong>缺点:</strong> 效率极低，CPU 忙等浪费资源。</td></tr><tr><td>2.<strong>中断 (Interrupt)</strong></td><td>硬件接收完数据后，置位 <code>RI</code> 并触发中断。CPU 在中断服务函数 (<code>ISR</code>) 中处理数据。</td><td><strong>优点:</strong> <strong>效率高</strong>，CPU 可执行主程序。 <strong>缺点:</strong> 需配置中断。</td></tr><tr><td>3.<strong>DMA (直接存储器存取)</strong></td><td>(高级单片机) 数据直接从串口硬件搬运到内存，无需 CPU 参与。</td><td><strong>优点:</strong> <strong>最高效</strong>，几乎不占 CPU 资源。 <strong>缺点:</strong> 配置复杂，硬件要求高。</td></tr></tbody></table><h3 id="B-应用层思路：数据解析方式-如何判断一帧数据结束"><a href="#B-应用层思路：数据解析方式-如何判断一帧数据结束" class="headerlink" title="B. 应用层思路：数据解析方式 (如何判断一帧数据结束)"></a>B. 应用层思路：数据解析方式 (如何判断一帧数据结束)</h3><table><thead><tr><th><strong>方式</strong></th><th><strong>描述</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>1.<strong>字符流&#x2F;结束符</strong></td><td>以特定的字符（如 <code>\n</code>, <code>\r\n</code>）作为一帧数据的结束标志。</td><td>命令行交互、文本传输。</td></tr><tr><td>2.<strong>固定长度</strong></td><td>预先约定数据包长度。计数器达到约定长度后认为接收完成。</td><td>传感器数据流、固定格式协议。</td></tr><tr><td>3.<strong>帧头&#x2F;长度&#x2F;校验</strong></td><td>数据包包含：帧头、数据长度、有效数据、校验和、帧尾。</td><td><strong>最可靠</strong>，用于工业控制、复杂自定义协议。</td></tr><tr><td>4.<strong>超时 (Timeout)</strong></td><td>收到第一个字节后开始计时，如果在设定的时间阈值内没有收到后续字节，则认为当前数据接收完成。</td><td><strong>最灵活</strong>，适用于数据长度不固定、实时性要求不高的场景。</td></tr></tbody></table><h2 id="3-代码思路总结"><a href="#3-代码思路总结" class="headerlink" title="3.代码思路总结"></a>3.代码思路总结</h2><p>您的代码（基于 8051&#x2F;STC 单片机）采用了以下成熟的驱动和应用思路：</p><h3 id="A-数据发送思路：查询-忙等发送"><a href="#A-数据发送思路：查询-忙等发送" class="headerlink" title="A. 数据发送思路：查询&#x2F;忙等发送"></a>A. 数据发送思路：<strong>查询&#x2F;忙等发送</strong></h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123114733536.png" alt="串口配置"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;uart.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void Uart1_Init(void)//9600bps@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">SCON = 0x50;//8位数据,可变波特率</span><br><span class="line">AUXR |= 0x01;//串口1选择定时器2为波特率发生器</span><br><span class="line">AUXR &amp;= 0xFB;//定时器时钟12T模式</span><br><span class="line">T2L = 0xE6;//设置定时初始值</span><br><span class="line">T2H = 0xFF;//设置定时初始值</span><br><span class="line">AUXR |= 0x10;//定时器2开始计时</span><br><span class="line">ES = 1;//使能串口1中断</span><br><span class="line">EA = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char putchar (char ch)</span><br><span class="line">&#123;</span><br><span class="line">    SBUF = ch;</span><br><span class="line">    while(TI == 0)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    TI = 0;</span><br><span class="line">    return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-数据接收思路：中断接收-超时解析"><a href="#B-数据接收思路：中断接收-超时解析" class="headerlink" title="B. 数据接收思路：中断接收 + 超时解析"></a>B. 数据接收思路：<strong>中断接收 + 超时解析</strong></h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123115349717.png" alt="中断号"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Uart1_Isr(void) interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">if (RI) // 判断是否是接收中断</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Flag = 1; // 设置接收标志</span><br><span class="line">Uart_Rx_Tick = 0; // 重置超时计时器</span><br><span class="line">Uart_Rx_Buf[Uart_Rx_Index++] = SBUF;</span><br><span class="line">RI = 0; // 手动清除接收中断请求位</span><br><span class="line">if (Uart_Rx_Index &gt; 10)</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Index = 0;</span><br><span class="line">memset(Uart_Rx_Buf, 0, 10); // 溢出则清空缓冲区</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Server() interrupt 1</span><br><span class="line">&#123;   </span><br><span class="line">    if(Uart_Rx_Flag == 1)</span><br><span class="line">        Uart_Recv_Tick ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="III-代码解析：8051-串口实现"><a href="#III-代码解析：8051-串口实现" class="headerlink" title="III. 代码解析：8051 串口实现"></a>III. 代码解析：8051 串口实现</h2><h3 id="1-核心寄存器：SBUF-Serial-Buffer-Register"><a href="#1-核心寄存器：SBUF-Serial-Buffer-Register" class="headerlink" title="1. 核心寄存器：SBUF (Serial Buffer Register)"></a>1. 核心寄存器：SBUF (Serial Buffer Register)</h3><ul><li><strong>功能：</strong> 串口数据交换的<strong>唯一通道</strong>（“信箱”）。</li><li><strong>发送：</strong> 写入 <code>SBUF = ch </code>立即启动发送。</li><li><strong>接收：</strong> 接收完成后，数据自动存入 $\text{SBUF}$，需读取 $\text{ch} &#x3D; \text{SBUF}$。</li></ul><h3 id="2-数据发送：查询-忙等-用于-printf-重定向"><a href="#2-数据发送：查询-忙等-用于-printf-重定向" class="headerlink" title="2. 数据发送：查询&#x2F;忙等 (用于 printf 重定向)"></a>2. 数据发送：查询&#x2F;忙等 (用于 <code>printf</code> 重定向)</h3><p>该代码利用了 <strong>C 语言 I&#x2F;O 重定向机制</strong>。</p><h4 id="机制：printf-重定向"><a href="#机制：printf-重定向" class="headerlink" title="机制：printf 重定向"></a>机制：<code>printf</code> 重定向</h4><table><thead><tr><th><strong>概念</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>目标</strong></td><td>将 <code>printf</code> 的输出目标从默认的“屏幕&#x2F;控制台”<strong>转移</strong>到“串口硬件”。</td></tr><tr><td><strong>原理</strong></td><td><code>printf</code> 函数在底层依赖于一个名为 <code>putchar(char ch)</code> 的函数来逐个输出字符。</td></tr><tr><td><strong>操作</strong></td><td>程序员通过<strong>自行实现</strong> <code>char putchar(char ch)</code> 函数，并在其内部直接操作串口发送寄存器 <code>SBUF</code>。链接器将自动用您的版本替换库中的默认版本。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123120637083.png" alt="image-20251123120637083"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;string.h&quot; // 字符串处理函数</span><br><span class="line">#include &quot;stdio.h&quot;// 标准输入输出函数，如 printf 和 sscanf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 串口接收相关变量</span><br><span class="line">idata unsigned char Uart_Rx_Index;  // 串口接收缓冲区索引</span><br><span class="line">pdata unsigned char Uart_Rx_Buf[10] = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;; // 串口接收缓冲区</span><br><span class="line">idata unsigned char Uart_Rx_Flag;  // 串口接收到数据的标志</span><br><span class="line">idata unsigned char Uart_Rx_Tick;  // 串口接收超时计时器</span><br><span class="line"></span><br><span class="line">void Uart_Proc() //超时解析</span><br><span class="line">&#123;</span><br><span class="line">// 如果没有接收到数据，直接返回</span><br><span class="line">if (Uart_Rx_Index == 0)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">// 如果距离上次接收到数据超过10ms（超时）</span><br><span class="line">if (Uart_Rx_Tick &gt;= 10)</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Flag = 0; // 清除接收标志</span><br><span class="line">Uart_Rx_Tick = 0; // 复位超时计时器</span><br><span class="line"></span><br><span class="line">//处理函数</span><br><span class="line"></span><br><span class="line">// 清空接收缓冲区，为下次接收做准备</span><br><span class="line">memset(Uart_Rx_Buf, 0, Uart_Rx_Index);</span><br><span class="line">Uart_Rx_Index = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📝-串口通信-UART&quot;&gt;&lt;a href=&quot;#📝-串口通信-UART&quot; class=&quot;headerlink&quot; title=&quot;📝 串口通信 (UART)&quot;&gt;&lt;/a&gt;📝 串口通信 (UART)&lt;/h1&gt;&lt;h2 id=&quot;1-串口-UART-是什么？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
</feed>
