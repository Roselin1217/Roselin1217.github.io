<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RossLin的数字花园</title>
  
  <subtitle>记录·思考·成长</subtitle>
  <link href="https://rosslin.xyz/atom.xml" rel="self"/>
  
  <link href="https://rosslin.xyz/"/>
  <updated>2025-12-19T08:55:09.495Z</updated>
  <id>https://rosslin.xyz/</id>
  
  <author>
    <name>RossLin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11.内存管理</title>
    <link href="https://rosslin.xyz/2025/11/27/11.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://rosslin.xyz/2025/11/27/11.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2025-11-27T02:00:00.000Z</published>
    <updated>2025-12-19T08:55:09.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📝-内存管理"><a href="#📝-内存管理" class="headerlink" title="📝 内存管理"></a>📝 内存管理</h1><h2 id="一、什么是-RAM？（随机存取存储器）"><a href="#一、什么是-RAM？（随机存取存储器）" class="headerlink" title="一、什么是 RAM？（随机存取存储器）"></a>一、什么是 RAM？（随机存取存储器）</h2><ul><li><strong>RAM (Random Access Memory)</strong>：掉电丢失的数据存储区。</li><li>8051 系列的 <strong>片内 RAM</strong> 只有 <strong>128 字节 或 256 字节</strong>（极度珍贵！）。</li><li>所有变量、栈、缓冲区都必须放在这 256 字节以内，因此 <strong>必须手动管理内存</strong>！</li></ul><h2 id="二、Keil-C51-各种存储类型对比（超级重点）"><a href="#二、Keil-C51-各种存储类型对比（超级重点）" class="headerlink" title="二、Keil C51 各种存储类型对比（超级重点）"></a>二、Keil C51 各种存储类型对比（超级重点）</h2><table><thead><tr><th><strong>关键字</strong></th><th><strong>存放位置</strong></th><th><strong>地址范围</strong></th><th><strong>访问方式</strong></th><th><strong>访问速度</strong></th><th><strong>空间大小</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><code>data</code></td><td>片内 RAM <strong>低 128 字节</strong></td><td><code>00H ~ 7FH</code></td><td>直接寻址 &#x2F; 间接寻址</td><td>★★★★★</td><td>~100 字节可用</td><td><strong>频繁访问的小变量</strong>、函数参数、栈</td></tr><tr><td><code>idata</code></td><td>片内 RAM <strong>高 128 字节</strong></td><td><code>80H ~ FFH</code></td><td><strong>只能间接寻址</strong> (<code>@R0</code>&#x2F;<code>@R1</code>)</td><td>★★★★</td><td>128 字节</td><td>数组、缓冲区、不太频繁访问的变量</td></tr><tr><td><code>xdata</code></td><td><strong>片外扩展 RAM</strong>（如 6264）</td><td><code>0000H ~ FFFFH</code></td><td><code>MOVX</code> 指令</td><td>★★</td><td>最大 64KB</td><td><strong>大数组</strong>、LCD 缓冲区、FAT 文件系统等</td></tr><tr><td><code>pdata</code></td><td>片外 RAM <strong>低 256 字节</strong></td><td><code>0000H ~ 00FFH</code></td><td><code>MOVX @Ri</code></td><td>★★</td><td>256 字节</td><td>很少用（旧系统兼容）</td></tr><tr><td><code>code</code></td><td><strong>程序存储区</strong>（Flash&#x2F;ROM）</td><td><code>0000H ~ FFFFH</code></td><td><code>MOVC</code> 指令</td><td>★★★</td><td>最大 64KB</td><td><strong>常量、字符串、查找表</strong>（如字模）</td></tr><tr><td><strong>无关键字</strong></td><td>默认等同于 <code>data</code></td><td>同 <code>data</code></td><td>同 <code>data</code></td><td>★★★★★</td><td>同 <code>data</code></td><td>小项目最常用</td></tr></tbody></table><blockquote><p><strong>💡 注意：</strong></p><ul><li>老芯片（如 AT89C51）只有 128 字节 RAM，<code>80H~FFH</code> 与 SFR 重叠，但仍可通过间接寻址访问，所以 <code>idata</code> 仍然可用！</li><li>新芯片（如 AT89S52、STC89C52）真正有 256 字节 RAM，<code>idata</code> 空间更宽裕。</li></ul></blockquote><h2 id="三、8051-片内-RAM-结构图（经典-256-字节版）"><a href="#三、8051-片内-RAM-结构图（经典-256-字节版）" class="headerlink" title="三、8051 片内 RAM 结构图（经典 256 字节版）"></a>三、8051 片内 RAM 结构图（经典 256 字节版）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">地址      内容</span><br><span class="line">FFH ┌─────────────────┐  ← 二楼结束</span><br><span class="line">    │     idata 区域      │  ← 你代码里的大数组放这里</span><br><span class="line">80H ├─────────────────┤  ← 二楼开始（只能用指针 @R0/@R1 访问）</span><br><span class="line">7FH ┌─────────────────┐  ← 一楼结束</span><br><span class="line">    │     data 区域       │  ← 小变量、栈、频繁使用的放这里</span><br><span class="line">30H ├─────────────────┤</span><br><span class="line">    │   位寻址区          │</span><br><span class="line">20H ├─────────────────┤</span><br><span class="line">    │   寄存器组 R0~R7    │</span><br><span class="line">00H └─────────────────┘  ← 一楼开始</span><br></pre></td></tr></table></figure><h2 id="🔑-总结（背下来一辈子不忘）"><a href="#🔑-总结（背下来一辈子不忘）" class="headerlink" title="🔑 总结（背下来一辈子不忘）"></a>🔑 总结（背下来一辈子不忘）</h2><ul><li>RAM 只有 256 字节，宝贝得像金子一样省着用！</li><li>小变量、栈 → 扔 <strong><code>data</code></strong>（一楼，速度快）</li><li>大数组、缓冲区 → 扔 <strong><code>idata</code></strong>（二楼，空间大）</li><li>更大东西 → 扔 <strong><code>xdata</code></strong>（外面仓库）</li><li>常量、字模 → 扔 <strong><code>code</code></strong>（Flash 里）</li><li><strong>不写关键字 &#x3D; 默认 <code>data</code></strong>，一不小心就溢出！</li></ul><blockquote><p>📌 <strong>写 51 程序的第一生存技能：会数 RAM 字节！</strong></p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📝-内存管理&quot;&gt;&lt;a href=&quot;#📝-内存管理&quot; class=&quot;headerlink&quot; title=&quot;📝 内存管理&quot;&gt;&lt;/a&gt;📝 内存管理&lt;/h1&gt;&lt;h2 id=&quot;一、什么是-RAM？（随机存取存储器）&quot;&gt;&lt;a href=&quot;#一、什么是-RAM？（随机存</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>10.超声波测距</title>
    <link href="https://rosslin.xyz/2025/11/24/10.%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://rosslin.xyz/2025/11/24/10.%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%B5%8B%E8%B7%9D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:19:52.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="超声波测距"><a href="#超声波测距" class="headerlink" title="超声波测距"></a>超声波测距</h1><h2 id="一、超声波测距原理与实现"><a href="#一、超声波测距原理与实现" class="headerlink" title="一、超声波测距原理与实现"></a>一、超声波测距原理与实现</h2><h3 id="1-测距原理"><a href="#1-测距原理" class="headerlink" title="1. 测距原理"></a>1. 测距原理</h3><p>超声波测距的原理是利用超声波在空气中的传播速度为已知，测量声波在发射后遇到障碍物反射回来的时间，根据发射和接收的时间差计算出发射点到障碍物的实际距离。由此可见，超声波测距原理与雷达原理是一样的。</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127143229081.png" alt="image-20251127143229081"></p><h3 id="2-测距公式推导"><a href="#2-测距公式推导" class="headerlink" title="2. 测距公式推导"></a>2. 测距公式推导</h3><p>测距的公式表示为：</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251127182824215.png"></p><h3 id="3-超声波发送细节"><a href="#3-超声波发送细节" class="headerlink" title="3. 超声波发送细节"></a>3. 超声波发送细节</h3><p>根据我们上方的分析，我们可以知道我们首先需要进行发送，我们在这里发送 8 个 40kHz 的方波进行测量。</p><ul><li><strong>周期计算</strong>: 周期<br>$$<br>T &#x3D; \frac{1}{40 , \text{kHz}} &#x3D; 25 , \text{us}<br>$$<br>。</li><li><strong>电平反转时间</strong>: 也就是我们需要 12us 将发送的电平进行反转（约为半个周期）。</li></ul><h3 id="4-代码实现概述-基于-STC89C-系列单片机"><a href="#4-代码实现概述-基于-STC89C-系列单片机" class="headerlink" title="4. 代码实现概述 (基于 STC89C 系列单片机)"></a>4. 代码实现概述 (基于 STC89C 系列单片机)</h3><p>这里需要注意的是要正确使用系统频率为 12MHz，并且使用 <code>y1/stc89</code> 指令集。</p><h4 id="4-1-延时函数-Delay12us-void"><a href="#4-1-延时函数-Delay12us-void" class="headerlink" title="4.1 延时函数 Delay12us(void)"></a>4.1 延时函数 <code>Delay12us(void)</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127124721571.png" alt="image-20251127124721571"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ul.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span> <span class="comment">// 标准头文件</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  延时12微秒</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> * @note   基于12MHz系统时钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay12us</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//@12.000MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i;</span><br><span class="line">    _nop_(); <span class="comment">// 使用标准库函数 _nop_()</span></span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-超声波发送初始化-Ut-Wave-Init"><a href="#4-2-超声波发送初始化-Ut-Wave-Init" class="headerlink" title="4.2 超声波发送初始化 Ut_Wave_Init()"></a>4.2 超声波发送初始化 <code>Ut_Wave_Init()</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127122447909.png" alt="image-20251127122447909"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义超声波模块的引脚</span></span><br><span class="line">sbit Tx = P1^<span class="number">0</span>; <span class="comment">// 发送引脚</span></span><br><span class="line">sbit Rx = P1^<span class="number">1</span>; <span class="comment">// 接收引脚</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  发送8个40kHz的超声波脉冲</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ut_Wave_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Tx = <span class="number">1</span>; <span class="comment">// 拉高电平</span></span><br><span class="line">        Delay12us(); <span class="comment">// 延时12us</span></span><br><span class="line">        Tx = <span class="number">0</span>; <span class="comment">// 拉低电平</span></span><br><span class="line">        Delay12us(); <span class="comment">// 延时12us</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-超声波数据采集与距离计算-Ut-Wave-Data"><a href="#4-3-超声波数据采集与距离计算-Ut-Wave-Data" class="headerlink" title="4.3 超声波数据采集与距离计算 Ut_Wave_Data()"></a>4.3 超声波数据采集与距离计算 <code>Ut_Wave_Data()</code></h4><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251127134433921.png" alt="image-20251127134433921"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  触发测量并计算距离</span></span><br><span class="line"><span class="comment"> * @return unsigned char 返回测得的距离值</span></span><br><span class="line"><span class="comment"> * @note   此函数存在一个潜在的bug：返回值类型为 unsigned char，</span></span><br><span class="line"><span class="comment"> *         当距离超过255cm时会发生数据溢出。建议返回 unsigned int。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Ut_Wave_Data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> time;</span><br><span class="line">    <span class="comment">// 配置定时器/计数器</span></span><br><span class="line">    <span class="comment">// 注意: CH, CL, CMOD, CR, CF 是特定于STC系列PCA/PWM模块的寄存器，</span></span><br><span class="line">    <span class="comment">// 并非标准8051的定时器寄存器。此处代码是基于PCA模块实现。</span></span><br><span class="line">    CH = <span class="number">0</span>; <span class="comment">// 清空PCA计数器高字节</span></span><br><span class="line">    CL = <span class="number">0</span>; <span class="comment">// 清空PCA计数器低字节</span></span><br><span class="line">    CMOD = <span class="number">0x00</span>; <span class="comment">// 设置PCA时钟源为系统时钟/12，并禁止PCA中断</span></span><br><span class="line">    EA = <span class="number">0</span>; <span class="comment">// 关闭总中断，防止发送脉冲时被打断</span></span><br><span class="line">    Ut_Wave_Init(); <span class="comment">// 发送超声波脉冲</span></span><br><span class="line">    EA = <span class="number">1</span>; <span class="comment">// 立即开启总中断</span></span><br><span class="line">    CR = <span class="number">1</span>; <span class="comment">// 启动PCA计数器</span></span><br><span class="line">    <span class="comment">// 等待接收引脚Rx变为高电平（回波信号），或者PCA计数器溢出(CF=1)</span></span><br><span class="line">    <span class="keyword">while</span> (Rx &amp;&amp; !CF);</span><br><span class="line">    CR = <span class="number">0</span>; <span class="comment">// 停止PCA计数器</span></span><br><span class="line">    <span class="keyword">if</span> (!CF) <span class="comment">// 如果未溢出，说明收到了回波</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算时间</span></span><br><span class="line">        time = CH &lt;&lt; <span class="number">8</span> | CL; <span class="comment">// 合并PCA计数器值</span></span><br><span class="line">        <span class="comment">// 距离计算: d = 0.017 * time</span></span><br><span class="line">        <span class="comment">// us -&gt; s 10^(-6)</span></span><br><span class="line">        <span class="comment">// m -&gt; cm 10^2</span></span><br><span class="line">        <span class="comment">// L = V*T/2 = 340 * time / 2 = 170 * 10^(-4) * time = 0.017 * time</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0.017</span> * time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果溢出，说明超出测量范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        CF = <span class="number">0</span>; <span class="comment">// 清除溢出标志位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示测量失败或超出范围</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码注解</strong>:</p><ol><li><strong>寄存器</strong>: <code>CH</code>, <code>CL</code>, <code>CMOD</code>, <code>CR</code>, <code>CF</code> 看起来是 STC 单片机特有的 <strong>PCA (可编程计数器阵列)</strong> 模块的寄存器，而不是标准的定时器0&#x2F;1的 <code>TH0</code>, <code>TL0</code>, <code>TF0</code>。这需要根据具体的单片机型号和定时器配置进行适配。</li><li><strong>返回值类型</strong>: <code>return (0.017 * time);</code> 的返回值类型为 <code>unsigned char</code>，这意味着最大只能返回 255。如果距离超过 255cm，将会发生截断，导致数据不准确。通常距离值会使用 <code>unsigned int</code> 类型存储。</li></ol></blockquote><h4 id="4-4-读取距离值-Get-Distance"><a href="#4-4-读取距离值-Get-Distance" class="headerlink" title="4.4 读取距离值 Get_Distance()"></a>4.4 读取距离值 <code>Get_Distance()</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设的全局变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Distance_Slow_Down = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Distance_Val = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  读取距离值</span></span><br><span class="line"><span class="comment"> * @param  无</span></span><br><span class="line"><span class="comment"> * @note   通过一个延时变量来控制测量的频率，避免过于频繁地测量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_Distance</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查延时是否到达</span></span><br><span class="line">    <span class="keyword">if</span> (Distance_Slow_Down &lt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Distance_Slow_Down = <span class="number">0</span>; <span class="comment">// 重置延时计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取超声波模块测量的距离</span></span><br><span class="line">    Distance_Val = Ut_Wave_Data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重要注意事项</strong>：在 <code>Ut_Wave_Data()</code> 函数中，我们使用了 <code>EA = 0;</code> 来关闭总中断，以确保发送8个脉冲的精确时序。<strong>在发送完毕后，必须立即使用 <code>EA = 1;</code> 重新开启中断</strong>，否则程序中依赖中断的部分（如数码管动态扫描、按键检测等）将停止工作，导致系统无响应。</p><h2 id="二、核心知识补充：PCA-vs-普通定时器"><a href="#二、核心知识补充：PCA-vs-普通定时器" class="headerlink" title="二、核心知识补充：PCA vs. 普通定时器"></a>二、核心知识补充：PCA vs. 普通定时器</h2><p>代码中使用了STC单片机特有的PCA模块来实现计时，这是一个非常好的实践。为了更深入地理解，我们将其与最常见的普通定时器（如Timer 0）进行详细对比。</p><h3 id="1-核心思想：瑞士军刀-vs-专用扳手"><a href="#1-核心思想：瑞士军刀-vs-专用扳手" class="headerlink" title="1. 核心思想：瑞士军刀 vs. 专用扳手"></a>1. 核心思想：瑞士军刀 vs. 专用扳手</h3><p>这是一个非常形象的比喻：</p><ul><li><strong>普通定时器</strong>：就像一把<strong>专用扳手</strong>。它非常擅长做一件事：<strong>定时&#x2F;计数</strong>。当你需要一个周期性的中断来执行任务时（如每隔1ms刷新数码管），它就是最直接、最高效的选择。</li><li><strong>PCA（<strong>P</strong>rogrammable <strong>C</strong>ounter <strong>A</strong>rray）</strong>：就像一把<strong>瑞士军刀</strong>。它的核心也是一个定时器（主计数器），但它还集成了多个“小工具”（比较&#x2F;捕获模块），使得它能实现更复杂的功能。</li><li>两者本质都是<strong>计数器</strong>。</li></ul><h3 id="2-功能对比"><a href="#2-功能对比" class="headerlink" title="2. 功能对比"></a>2. 功能对比</h3><table><thead><tr><th align="left">功能特性</th><th align="left">普通定时器 (Timer 0&#x2F;1)</th><th align="left">PCA (可编程计数器阵列)</th></tr></thead><tbody><tr><td align="left"><strong>基本定时&#x2F;计数</strong></td><td align="left">✅ <strong>核心功能</strong></td><td align="left">✅ <strong>核心功能</strong></td></tr><tr><td align="left"><strong>周期性中断</strong></td><td align="left">✅ <strong>直接支持</strong>。设置初值，溢出后触发中断。</td><td align="left">✅ <strong>支持</strong>。通过溢出标志<code>CF</code>触发中断。</td></tr><tr><td align="left"><strong>PWM输出</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需用软件在中断中模拟，占用CPU，精度差。</td><td align="left">✅ <strong>硬件自动实现</strong>。配置后，硬件自动输出PWM波形，不占CPU。</td></tr><tr><td align="left"><strong>输入捕获</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需用外部中断+定时器组合，逻辑复杂。</td><td align="left">✅ <strong>硬件自动实现</strong>。可自动捕获引脚电平跳变时刻的计数值，响应快。</td></tr><tr><td align="left"><strong>软件定时器</strong></td><td align="left">❌ <strong>无法直接实现</strong>。需在主程序或中断中维护变量。</td><td align="left">✅ <strong>支持</strong>。每个比较模块都可设为独立的软件定时器。</td></tr></tbody></table><h3 id="3-寄存器对比"><a href="#3-寄存器对比" class="headerlink" title="3. 寄存器对比"></a>3. 寄存器对比</h3><p>你的代码中，两种定时器使用了完全不同的寄存器集，这证明了它们是独立的硬件模块。</p><table><thead><tr><th align="left">作用</th><th align="left">普通定时器 (以Timer 0为例)</th><th align="left">PCA</th></tr></thead><tbody><tr><td align="left"><strong>模式配置</strong></td><td align="left"><code>TMOD</code> (设置16位&#x2F;8位模式) <code>AUXR</code> (设置12T&#x2F;1T时钟)</td><td align="left"><code>CMOD</code> (设置时钟源、中断使能)</td></tr><tr><td align="left"><strong>计数器值</strong></td><td align="left"><code>TH0</code>, <code>TL0</code> (高&#x2F;低字节)</td><td align="left"><code>CH</code>, <code>CL</code> (高&#x2F;低字节)</td></tr><tr><td align="left"><strong>启停控制</strong></td><td align="left"><code>TR0</code> (Run control bit)</td><td align="left"><code>CR</code> (Run control bit)</td></tr><tr><td align="left"><strong>溢出标志</strong></td><td align="left"><code>TF0</code> (Overflow Flag)</td><td align="left"><code>CF</code> (Counter Overflow Flag)</td></tr><tr><td align="left"><strong>中断控制</strong></td><td align="left"><code>ET0</code> (Timer 0 Interrupt Enable)</td><td align="left">PCA有独立的中断使能位</td></tr></tbody></table><h3 id="4-在你的超声波测距代码中的应用分析"><a href="#4-在你的超声波测距代码中的应用分析" class="headerlink" title="4. 在你的超声波测距代码中的应用分析"></a>4. 在你的超声波测距代码中的应用分析</h3><p>现在我们回头看你的 <code>Ut_Wave_Data()</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">CH = 0; CL = 0;   // 清空PCA计数器</span><br><span class="line">CMOD = 0x00;      // 配置PCA</span><br><span class="line">CR = 1;           // 启动PCA</span><br><span class="line">while (Rx &amp;&amp; !CF); // 轮询等待</span><br><span class="line">CR = 0;           // 停止PCA</span><br><span class="line">time = CH &lt;&lt; 8 | CL; // 读取计数值</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><ul><li><strong>代码中用到了PCA的什么功能？</strong><br>你只用了PCA最基础的功能：<strong>把它当作一个16位的、从0开始计时的秒表</strong>。你通过轮询<code>CF</code>标志位来实现超时检测。</li><li><strong>能用普通定时器实现吗？</strong><br><strong>完全可以！</strong> 而且这是更常规的做法。使用Timer 0的代码逻辑几乎完全一样，只是换一套寄存器而已：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用Timer 0的伪代码</span><br><span class="line">TMOD = 0x01;    // 16位定时器模式</span><br><span class="line">TH0 = 0; TL0 = 0; // 从0开始计时</span><br><span class="line">TF0 = 0;        // 清除溢出标志</span><br><span class="line">TR0 = 1;        // 启动Timer 0</span><br><span class="line">while (Rx &amp;&amp; !TF0); // 轮询等待</span><br><span class="line">TR0 = 0;        // 停止Timer 0</span><br><span class="line">time = TH0 &lt;&lt; 8 | TL0; // 读取计数值</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><h3 id="5-如何选择？"><a href="#5-如何选择？" class="headerlink" title="5. 如何选择？"></a>5. 如何选择？</h3><ul><li><strong>选择普通定时器</strong>：当你的需求仅仅是<strong>定时、延时、或者测量一个时间长度</strong>时，使用Timer 0或Timer 1是首选。它更简单、通用，代码移植性也更好。</li><li><strong>选择PCA</strong>：当你的项目需要<strong>同时实现多种功能</strong>时，PCA的优势就体现出来了。例如，你的项目既要超声波测距，又要用PWM控制电机转速，这时用PCA的捕获模块测距，用另一个模块输出PWM，就能高效地完成任务，而把普通的Timer 0留给系统时钟节拍等关键任务。</li></ul><p><strong>结论</strong>：在你的超声波测距代码中，你使用了PCA的“瑞士军刀”来切苹果（做基本计时），这是完全可行的。但了解普通定时器这把“专用扳手”同样能胜任，并且知道它们之间的区别，能帮助你在未来的项目中做出更合理的设计选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;超声波测距&quot;&gt;&lt;a href=&quot;#超声波测距&quot; class=&quot;headerlink&quot; title=&quot;超声波测距&quot;&gt;&lt;/a&gt;超声波测距&lt;/h1&gt;&lt;h2 id=&quot;一、超声波测距原理与实现&quot;&gt;&lt;a href=&quot;#一、超声波测距原理与实现&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>2.数码管和定时器</title>
    <link href="https://rosslin.xyz/2025/11/24/2.%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://rosslin.xyz/2025/11/24/2.%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E6%89%AB%E6%8F%8F%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:22:15.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数码管和定时器"><a href="#数码管和定时器" class="headerlink" title="**数码管和定时器 **"></a>**数码管和定时器 **</h1><h2 id="一、数码管基本原理"><a href="#一、数码管基本原理" class="headerlink" title="一、数码管基本原理"></a>一、数码管基本原理</h2><h3 id="1-数码管结构"><a href="#1-数码管结构" class="headerlink" title="1. 数码管结构"></a>1. 数码管结构</h3><p>数码管本质上是由<strong>8个LED段</strong>（a<del>g + 小数点dp）组合而成的显示器件，用于显示数字0</del>9及部分字母。</p><p>根据内部连接方式，可分为两种类型：</p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230550029.png" style="zoom: 67%;" /><table><thead><tr><th>类型</th><th>阳极连接</th><th>阴极连接</th><th>控制方式</th><th>亮灭逻辑</th></tr></thead><tbody><tr><td><strong>共阳极数码管</strong></td><td>所有LED阳极连在一起接VCC</td><td>每段独立接驱动电路</td><td>控制<strong>阴极电平</strong></td><td><strong>0亮，1灭</strong></td></tr><tr><td><strong>共阴极数码管</strong></td><td>每段独立接驱动电路</td><td>所有LED阴极连在一起接地</td><td>控制<strong>阳极电平</strong></td><td><strong>1亮，0灭</strong></td></tr></tbody></table><blockquote><p>✅ <strong>本系统使用的是共阳极数码管</strong>（根据电路图与代码中<code>0xc0, 0xf9...</code>推断）<br>因此：<strong>输出低电平 → 段点亮；输出高电平 → 段熄灭</strong></p></blockquote><h3 id="2-段码表（共阳极数码管）"><a href="#2-段码表（共阳极数码管）" class="headerlink" title="2. 段码表（共阳极数码管）"></a>2. 段码表（共阳极数码管）</h3><h3 id="3-什么是“消影”？如何解决？"><a href="#3-什么是“消影”？如何解决？" class="headerlink" title="3. 什么是“消影”？如何解决？"></a>3. 什么是“消影”？如何解决？</h3><h4 id="❓-什么是消影？"><a href="#❓-什么是消影？" class="headerlink" title="❓ 什么是消影？"></a>❓ 什么是消影？</h4><p>在<strong>动态扫描显示</strong>中，当从一个数码管切换到另一个时，由于<strong>段码数据提前加载</strong>或<strong>位选信号延迟关闭</strong>，会导致前一个数码管在切换瞬间仍有残影（部分段微亮），这种现象称为**“消影”**（或“鬼影”）。</p><h4 id="✅-消影产生的原因："><a href="#✅-消影产生的原因：" class="headerlink" title="✅ 消影产生的原因："></a>✅ 消影产生的原因：</h4><ul><li>位选（选中哪个数码管）与段选（显示什么数字）未严格同步；</li><li>段码数据写入后，未先关闭所有位选就切换，造成短暂重叠。</li></ul><h4 id="🔧-解决方法："><a href="#🔧-解决方法：" class="headerlink" title="🔧 解决方法："></a>🔧 解决方法：</h4><blockquote><p><strong>“先关位选 → 再送段码 → 再开位选”</strong><br>即：<strong>消影三步法</strong></p><ol><li>先关闭所有数码管（P0 &#x3D; 0xFF，段码全灭）</li><li>再进行位选（选中要显示的数码管）</li><li>最后写入段码并锁存</li></ol></blockquote><blockquote><p>✅ 本系统通过在每次显示前先执行一次**“全灭”操作**，有效消除鬼影。</p></blockquote><hr><h2 id="二、数码管动态显示原理"><a href="#二、数码管动态显示原理" class="headerlink" title="二、数码管动态显示原理"></a>二、数码管动态显示原理</h2><h3 id="🎯-原理概述"><a href="#🎯-原理概述" class="headerlink" title="🎯 原理概述"></a>🎯 原理概述</h3><p>动态显示是指<strong>多个数码管轮流点亮</strong>，利用人眼的<strong>视觉暂留效应</strong>（约10~40ms），在快速切换下产生“同时点亮”的错觉。</p><ul><li><p><strong>刷新频率建议</strong>：&gt; 50Hz（即每50ms刷新一次），人眼无闪烁。</p></li><li><p><strong>每个数码管点亮时间</strong>：约 1~5ms</p></li><li><p><strong>优点</strong>：节省IO口、功耗低、电路简单</p></li><li><p><strong>缺点</strong>：需程序定时刷新，占用CPU资源</p></li></ul><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230743404.png"></p><h3 id="✅-动态扫描实现步骤"><a href="#✅-动态扫描实现步骤" class="headerlink" title="✅ 动态扫描实现步骤"></a>✅ 动态扫描实现步骤</h3><blockquote><p><strong>“消影 → 位选 → 段选”</strong></p></blockquote><table><thead><tr><th>步骤</th><th>操作</th><th>目的</th></tr></thead><tbody><tr><td>1. 消影</td><td>P0 &#x3D; 0xFF + 锁存</td><td>关闭所有段，避免残影</td></tr><tr><td>2. 位选</td><td>选中某个数码管（如第3位）</td><td>让电流只流过该数码管</td></tr><tr><td>3. 段选</td><td>写入对应数字的段码</td><td>显示所需数字</td></tr></tbody></table><blockquote><p>💡 <strong>注意</strong>：位选与段选需分别通过<strong>不同的锁存器</strong>控制（本系统使用两个锁存器：一个控制位选、一个控制段选）</p></blockquote><hr><h2 id="三、硬件连接说明"><a href="#三、硬件连接说明" class="headerlink" title="三、硬件连接说明"></a>三、硬件连接说明</h2><ul><li><strong>P0口</strong>：输出段码与位选信号（共用）</li><li>P2口:控制锁存器使能端<ul><li><code>P2.5</code> 控制<strong>段选锁存器</strong>（LE &#x3D; Y6C （110），由Y6选通）  </li><li><code>P2.7</code> 控制<strong>位选锁存器</strong>（LE &#x3D; Y7C（111），由Y7选通）</li></ul></li><li><strong>Y4~Y7</strong>：由74HC138译码器输出，用于选通不同锁存器</li></ul><blockquote><p>✅ <strong>段选锁存器使能</strong>：选中 Y6 → Y6&#x3D;0 → Y6C&#x3D;1 → 段选锁存器打开<br>✅ <strong>位选锁存器使能</strong>：选中 Y7 → Y7&#x3D;0 → Y7C&#x3D;1 → 位选锁存器打开</p></blockquote><hr><h2 id="四、完整代码实现（带详细注释）"><a href="#四、完整代码实现（带详细注释）" class="headerlink" title="四、完整代码实现（带详细注释）"></a>四、完整代码实现（带详细注释）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_dula[] = &#123;0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0xbf,0xc6&#125;;</span><br><span class="line">unsigned char seg_wela[] = &#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;</span><br><span class="line"></span><br><span class="line">// 函数名：数码管动态显示函数</span><br><span class="line">// 入口参数：</span><br><span class="line">//   wela：位选索引（0~7），表示第几个数码管（从右到左）</span><br><span class="line">//   dula：段选数字（0~9），表示要显示的数字</span><br><span class="line">//   point：是否点亮小数点（1=点亮，0=不点亮）</span><br><span class="line">// 返回值：无</span><br><span class="line">// 功能：通过动态扫描显示一个数字，支持小数点，自动消影</span><br><span class="line"></span><br><span class="line">void seg_disp(unsigned char wela, unsigned char dula, unsigned char point)</span><br><span class="line">&#123;</span><br><span class="line">    // 第一步：消影 —— 先关闭所有数码管（避免残影）</span><br><span class="line">    // 将P0设为全高（0xFF）→ 所有段灭</span><br><span class="line">    P0 = 0xFF;</span><br><span class="line"></span><br><span class="line">    // 锁存器使能：选中Y7（P2.7=1, P2.6=1, P2.5=1, P2.4=0 → Y7=0，使能位选锁存器）</span><br><span class="line">    // P2 = P2 &amp; 0x1F | 0xE0; → 保留低5位，高三位设为111 → 1110 0000 = 0xE0</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xE0;</span><br><span class="line">    </span><br><span class="line">    // 锁存：拉低LE → 保持全灭状态</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">    // 第二步：位选 —— 选中要显示的数码管（如第3位）</span><br><span class="line">    P0 = seg_wela[wela];  // 写入位选码（低电平有效）</span><br><span class="line"></span><br><span class="line">    // 使能位选锁存器（Y7选通）→ Y7=0 → Y7C=1 → 打开锁存器</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xE0;</span><br><span class="line">    </span><br><span class="line">    // 锁存位选信号</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">    // 第三步：段选 —— 设置要显示的数字</span><br><span class="line">    P0 = seg_dula[dula];  // 写入段码</span><br><span class="line"></span><br><span class="line">    // 如果需要显示小数点</span><br><span class="line">    if(point)</span><br><span class="line">        P0 &amp;= 0x7F;  // 将dp位（第7位）置0，点亮小数点（共阳极：0亮）</span><br><span class="line"></span><br><span class="line">    // 使能段选锁存器（选中Y6 → P2.5=1, P2.6=1, P2.7=1 → Y6=0 → Y6C=1）</span><br><span class="line">    // 注意：此时P2.7仍为1，但锁存器是Y6控制的，不影响</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xC0;  // 0xC0 = 1100 0000 → 设置P2.7=1, P2.6=1, P2.5=0 → 选Y6</span><br><span class="line">    P2 &amp;= 0x1F;  // 锁存段码</span><br><span class="line"></span><br><span class="line">    // ✅ 完成一次显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器</p><p>1.在STC-ISP上生成初始化函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Init(void)</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F;</span><br><span class="line">TMOD &amp;= 0xF0;</span><br><span class="line">TL0 = 0x18;</span><br><span class="line">TH0 = 0xFC;</span><br><span class="line">TF0 = 0;</span><br><span class="line">TR0 = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ET0 = 1; //打开定时器0中断 （Enable Timer 0 Interrupt）</span><br><span class="line">EA = 1; //打开总中断  （Enable All interrupts）</span><br></pre></td></tr></table></figure><p>2.编写中断服务函数:</p><p>只需要在普通函数后加 interrupt num<br>num越大，中断优先级越低，当中断同时发生，优先级高的先进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_pos;</span><br><span class="line">unsigned char seg_buf[8] =&#123;10,10,10,10,10,10,10,10&#125;;</span><br><span class="line">unsigned char seg_point[8] =&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Timer0Init interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"> if(++seg_pos == 8) seg_pos = 0;</span><br><span class="line"> Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、定时器0中断系统（实现自动动态扫描）"><a href="#五、定时器0中断系统（实现自动动态扫描）" class="headerlink" title="五、定时器0中断系统（实现自动动态扫描）"></a>五、定时器0中断系统（实现自动动态扫描）</h2><h3 id="1-定时器0初始化（1ms定时，用于刷新数码管）"><a href="#1-定时器0初始化（1ms定时，用于刷新数码管）" class="headerlink" title="1. 定时器0初始化（1ms定时，用于刷新数码管）"></a><strong>1. 定时器0初始化（1ms定时，用于刷新数码管）</strong></h3><p>(**易错点)**<strong>定义时间变量 常用 <code>unsigned int</code></strong> </p><p>int（ <strong>integer</strong>（整数））：<strong>16 位</strong>（2 字节）</p><p>取值范围：2^16&#x3D;65535</p><p><code>char</code> （ <strong>character（字符）</strong>）：是 <strong>1 字节（8 位）</strong> </p><p>取值范围：2^8 &#x3D;255</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230848799.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 函数名：定时器0初始化</span><br><span class="line">// 功能：配置定时器0为模式1（16位定时），每1ms产生一次中断</span><br><span class="line">// 晶振：12MHz → 机器周期：1μs</span><br><span class="line">// 定时1ms → 计数值 = 1000</span><br><span class="line">// 定时器计数 = 65536 - 1000 = 64536 = 0xFC18</span><br><span class="line">// TH0 = 0xFC, TL0 = 0x18</span><br><span class="line"></span><br><span class="line">void Timer0Init(void)</span><br><span class="line">&#123;</span><br><span class="line">    AUXR &amp;= 0x7F;     // 设置定时器0为1T模式（STC专用，加速）</span><br><span class="line">    TMOD &amp;= 0xF0;     // 清除T0模式位，保留T1</span><br><span class="line">    TL0 = 0x18;       // 低8位初值</span><br><span class="line">    TH0 = 0xFC;       // 高8位初值</span><br><span class="line">    TF0 = 0;          // 清除溢出标志</span><br><span class="line">    TR0 = 1;          // 启动定时器0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔔 <strong>注意</strong>：</p><ul><li>若使用12T模式（默认），初值为 <code>TH0=0x3C, TL0=0xB0</code></li><li>本代码使用 <strong>1T模式</strong>（STC增强型），精度更高，推荐使用！</li></ul></blockquote><h3 id="2-打开中断"><a href="#2-打开中断" class="headerlink" title="2. 打开中断"></a>2. 打开中断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ET0 = 1; //打开定时器0中断 （Enable Timer 0 Interrupt）</span><br><span class="line">EA = 1; //打开总中断  （Enable All interrupts）</span><br></pre></td></tr></table></figure><h3 id="3-定时器0中断服务函数（核心！动态扫描在此完成）"><a href="#3-定时器0中断服务函数（核心！动态扫描在此完成）" class="headerlink" title="3. 定时器0中断服务函数（核心！动态扫描在此完成）"></a>3. 定时器0中断服务函数（核心！动态扫描在此完成）</h3><p><strong>只需要在普通函数后加 interrupt num</strong><br><strong>。num越大，中断优先级越低，当中断同时发生，优先级高的先进行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char seg_pos;</span><br><span class="line">unsigned char seg_buf[8] =&#123;10,10,10,10,10,10,10,10&#125;;</span><br><span class="line">unsigned char seg_point[8] =&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Timer0Init interrupt 1  //void Function_Name() interrupt num  num取决于数据手册</span><br><span class="line">&#123;</span><br><span class="line"> if(++seg_pos == 8) seg_pos = 0;</span><br><span class="line"> Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>关键说明</strong>：</p><ul><li>中断服务函数<strong>必须重载初值</strong>（1T模式下TH0&#x2F;TL0不自动重载）</li><li><code>seg_disp()</code> 会自动执行“消影→位选→段选”三步，无需额外处理</li><li>所有显示数据由 <code>seg_buf[]</code> 和 <code>seg_point[]</code> 提供，<strong>主程序只需修改这两数组</strong></li></ul></blockquote><h3 id="8051单片机定时器相关寄存器总结"><a href="#8051单片机定时器相关寄存器总结" class="headerlink" title="8051单片机定时器相关寄存器总结"></a><strong>8051单片机定时器相关寄存器总结</strong></h3><table><thead><tr><th align="left">缩写</th><th align="left">全称</th><th align="left">说明</th><th align="left">相关代码示例及解释</th></tr></thead><tbody><tr><td align="left"><strong>AUXR</strong></td><td align="left">Auxiliary Register (辅助寄存器)</td><td align="left">某些增强型8051单片机（如STC系列）特有的寄存器，用于控制定时器的工作模式。</td><td align="left"><code>AUXR &amp;= 0x7F;</code> 将第7位（通常为T0x12位）清零，选择12T模式（即12个时钟周期为一个机器周期，传统8051模式）。</td></tr><tr><td align="left"><strong>TMOD</strong></td><td align="left">Timer Mode Register (定时器模式寄存器)</td><td align="left">用于设置定时器0和定时器1的工作模式（如方式0~3）。</td><td align="left"><code>TMOD &amp;= 0xF0;</code> 表示清除低4位，即定时器0的模式被设为方式0（13位定时器）或方式1（16位定时器）。具体取决于后续是否设置M1&#x2F;M0位。</td></tr><tr><td align="left"><strong>TL0</strong></td><td align="left">Timer 0 Low-byte (定时器0低8位)</td><td align="left">定时器0的低字节计数寄存器。与TH0共同组成一个16位的计数器。</td><td align="left">(无直接代码示例，通常与TH0一起赋值)</td></tr><tr><td align="left"><strong>TH0</strong></td><td align="left">Timer 0 High-byte (定时器0高8位)</td><td align="left">定时器0的高字节计数寄存器。与TL0共同组成一个16位的计数器。</td><td align="left">(无直接代码示例，通常与TL0一起赋值)</td></tr><tr><td align="left"><strong>TF0</strong></td><td align="left">Timer 0 Overflow Flag (定时器0溢出标志位)</td><td align="left">当定时器0计数溢出时，硬件自动置1；需软件清零。</td><td align="left"><code>TF0 = 0;</code> 手动清除溢出标志。虽然上电后通常为0，但显式清零是良好习惯。</td></tr><tr><td align="left"><strong>TR0</strong></td><td align="left">Timer 0 Run control bit (定时器0运行控制位)</td><td align="left">位于TCON寄存器中，用于控制定时器0的启停。</td><td align="left"><code>TR0 = 1;</code> 启动定时器0开始计数。 <code>TR0 = 0;</code> 停止定时器0计数。</td></tr><tr><td align="left"><strong>ET0</strong></td><td align="left">Enable Timer 0 Interrupt (使能定时器0中断)</td><td align="left">位于IE（Interrupt Enable）寄存器中，用于允许或禁止定时器0中断。</td><td align="left"><code>ET0 = 1;</code> 允许定时器0溢出时产生中断。</td></tr><tr><td align="left"><strong>EA</strong></td><td align="left">Enable All interrupts (全局中断使能位)</td><td align="left">位于IE（Interrupt Enable）寄存器中，用于全局开启或关闭所有中断。</td><td align="left"><code>EA = 1;</code> 开启CPU总中断允许，否则所有中断都被屏蔽。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数码管和定时器&quot;&gt;&lt;a href=&quot;#数码管和定时器&quot; class=&quot;headerlink&quot; title=&quot;**数码管和定时器 **&quot;&gt;&lt;/a&gt;**数码管和定时器 **&lt;/h1&gt;&lt;h2 id=&quot;一、数码管基本原理&quot;&gt;&lt;a href=&quot;#一、数码管基本原理&quot; cla</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>3.单总线协议详解（DS18B20 ）</title>
    <link href="https://rosslin.xyz/2025/11/24/3.one_wire%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88DS18B20%EF%BC%89/"/>
    <id>https://rosslin.xyz/2025/11/24/3.one_wire%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%EF%BC%88DS18B20%EF%BC%89/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:17:19.343Z</updated>
    
    <content type="html"><![CDATA[<p>​</p><h1 id="单总线协议详解（DS18B20-）"><a href="#单总线协议详解（DS18B20-）" class="headerlink" title="单总线协议详解（DS18B20 ）"></a>单总线协议详解（DS18B20 ）</h1><hr><h2 id="一、单总线协议基础"><a href="#一、单总线协议基础" class="headerlink" title="一、单总线协议基础"></a>一、单总线协议基础</h2><h3 id="1-1-什么是单总线？"><a href="#1-1-什么是单总线？" class="headerlink" title="1.1 什么是单总线？"></a>1.1 什么是单总线？</h3><p><strong>单总线（1-Wire）</strong> 是 Dallas&#x2F;Maxim 公司开发的一种串行通信协议。</p><p><strong>核心特点：</strong></p><ul><li>✅ 只需 1 根数据线 <strong>Data Queue</strong> （DQ）+ 1 根地线（GND）</li><li>✅ 支持多设备挂载（每个设备有唯一 64 位 ROM 码）</li><li>✅ 半双工通信（同一时刻只能单向传输）</li><li>✅ 主从架构（MCU 是主机，传感器是从机）</li></ul><p><strong>硬件连接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT        VCC (3.3V/5V)</span><br><span class="line">         |</span><br><span class="line">        [R] 4.7kΩ 上拉电阻</span><br><span class="line">         |</span><br><span class="line">MCU -----+-------- DS18B20 (DQ)</span><br><span class="line">         |</span><br><span class="line">        GND</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-开漏输出原理（重要！）"><a href="#1-2-开漏输出原理（重要！）" class="headerlink" title="1.2 开漏输出原理（重要！）"></a>1.2 开漏输出原理（重要！）</h3><p>单总线使用 <strong>开漏输出（Open-Drain）</strong> 模式：</p><table><thead><tr><th align="left">MCU 操作</th><th align="left">DQ 引脚状态</th><th align="left">实际电平</th></tr></thead><tbody><tr><td align="left"><code>DQ = 0</code></td><td align="left">强制拉低</td><td align="left">低电平（0V）</td></tr><tr><td align="left"><code>DQ = 1</code></td><td align="left"><strong>释放总线</strong>（高阻态）</td><td align="left">高电平（由上拉电阻决定）</td></tr></tbody></table><p><strong>关键理解：</strong></p><ul><li><code>DQ = 1</code> <strong>不是</strong>主动输出高电平，而是”松手”让上拉电阻把总线拉高</li><li>从机可以在总线被释放后拉低总线（实现数据传输）</li></ul><hr><h2 id="二、单总线时序（通用规则）"><a href="#二、单总线时序（通用规则）" class="headerlink" title="二、单总线时序（通用规则）"></a>二、单总线时序（通用规则）</h2><h3 id="2-1-初始化时序（复位-应答）"><a href="#2-1-初始化时序（复位-应答）" class="headerlink" title="2.1 初始化时序（复位 + 应答）"></a>2.1 初始化时序（复位 + 应答）</h3><p><strong>目的：</strong> 确认设备在线</p><p><strong>流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT主机动作：</span><br><span class="line">1. 拉低总线 ≥480μs（发送复位脉冲）</span><br><span class="line">2. 释放总线</span><br><span class="line">3. 等待 15~60μs</span><br><span class="line">4. 读取总线电平</span><br><span class="line"></span><br><span class="line">从机响应：</span><br><span class="line">- 检测到复位脉冲后，拉低总线 60~240μs（应答脉冲）</span><br><span class="line">- 返回 0 = 在线，返回 1 = 无响应</span><br></pre></td></tr></table></figure><p><strong>波形图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXTMCU:  ────┐     ┌─────────────</span><br><span class="line">          │ 480μs│</span><br><span class="line">          └─────┘</span><br><span class="line"></span><br><span class="line">DS:   ─────────┐   ┌─────────</span><br><span class="line">               │60~│240μs</span><br><span class="line">               └───┘ 应答脉冲</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bit init_ds18b20(void)</span><br><span class="line">   &#123;</span><br><span class="line">       bit initflag = 0;</span><br><span class="line">       </span><br><span class="line">       DQ = 1;         // 拉高总线，准备</span><br><span class="line">       Delay_OneWire(12);</span><br><span class="line">       DQ = 0;         // 产生复位脉冲 (拉低 &gt; 480us)</span><br><span class="line">       Delay_OneWire(80);</span><br><span class="line">       DQ = 1;         // 释放总线，等待DS18B20响应</span><br><span class="line">       Delay_OneWire(10); </span><br><span class="line">       initflag = DQ;  // 检测应答脉冲 (低电平表示存在)</span><br><span class="line">       Delay_OneWire(5);</span><br><span class="line">       </span><br><span class="line">       return initflag; // 返回0表示存在，1表示不存在</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-写时序（主机发送数据）"><a href="#2-2-写时序（主机发送数据）" class="headerlink" title="2.2 写时序（主机发送数据）"></a>2.2 写时序（主机发送数据）</h3><p><strong>原则：</strong> 通过 <strong>拉低时间长短</strong> 区分 0 和 1</p><h4 id="写-0"><a href="#写-0" class="headerlink" title="写 0"></a>写 0</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 拉低 60~120μs</span><br><span class="line">2. 释放总线</span><br><span class="line">TEXTDQ: ────┐           ┌───</span><br><span class="line">        │  60~120μs │</span><br><span class="line">        └───────────┘</span><br></pre></td></tr></table></figure><h4 id="写-1"><a href="#写-1" class="headerlink" title="写 1"></a>写 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 拉低 1~15μs（短脉冲）</span><br><span class="line">2. 立即释放总线</span><br><span class="line">3. 保持高电平至时间槽结束</span><br><span class="line">TEXTDQ: ────┐┌──────────</span><br><span class="line">        ││ &lt;15μs</span><br><span class="line">        └┘</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Write_DS18B20(unsigned char dat)</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned char i;</span><br><span class="line">        for(i=0; i&lt;8; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            DQ = 0;             // 开始写时序，拉低总线</span><br><span class="line">            DQ = dat &amp; 0x01;    // 写入数据位 (0或1)</span><br><span class="line">            Delay_OneWire(5);   // 保持 &gt; 60us</span><br><span class="line">            DQ = 1;             // 释放总线</span><br><span class="line">            dat &gt;&gt;= 1;          // 准备下一位数据</span><br><span class="line">        &#125;</span><br><span class="line">        Delay_OneWire(5);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-读时序（从机发送数据）"><a href="#2-3-读时序（从机发送数据）" class="headerlink" title="2.3 读时序（从机发送数据）"></a>2.3 读时序（从机发送数据）</h3><p><strong>原则：</strong> 主机触发，从机控制总线电平</p><p><strong>流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 主机拉低总线 1μs（触发信号）</span><br><span class="line">2. 主机释放总线</span><br><span class="line">3. 等待 10~15μs 后采样总线电平</span><br><span class="line">   - 低电平 = 0</span><br><span class="line">   - 高电平 = 1</span><br></pre></td></tr></table></figure><p><strong>波形图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TEXT读到 0:</span><br><span class="line">MCU:  ───┐┌────────</span><br><span class="line">         ││ 1μs</span><br><span class="line">         └┘</span><br><span class="line">DS:   ────┐        ┌───</span><br><span class="line">          │ 从机拉低 │</span><br><span class="line">          └────────┘</span><br><span class="line"></span><br><span class="line">读到 1:</span><br><span class="line">MCU:  ───┐┌────────</span><br><span class="line">         └┘</span><br><span class="line">DS:   ──────────────  (从机不拉低，保持高电平)</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Read_DS18B20(void)</span><br><span class="line">   &#123;</span><br><span class="line">       unsigned char i;</span><br><span class="line">       unsigned char dat = 0; // 初始化为0</span><br><span class="line">       </span><br><span class="line">       for(i=0; i&lt;8; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           DQ = 0;             // 开始读时序，拉低总线</span><br><span class="line">           dat &gt;&gt;= 1;          // 右移一位，准备接收新数据</span><br><span class="line">           DQ = 1;             // 释放总线，让DS18B20控制</span><br><span class="line">           if(DQ)              // 在15us内读取总线电平</span><br><span class="line">           &#123;</span><br><span class="line">               dat |= 0x80;    // 如果为高电平，则最高位置1</span><br><span class="line">           &#125;    </span><br><span class="line">           Delay_OneWire(5);   // 等待读周期结束</span><br><span class="line">       &#125;</span><br><span class="line">       return dat;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、单总线通信流程"><a href="#三、单总线通信流程" class="headerlink" title="三、单总线通信流程"></a>三、单总线通信流程</h2><h3 id="3-1-标准流程（固定顺序）"><a href="#3-1-标准流程（固定顺序）" class="headerlink" title="3.1 标准流程（固定顺序）"></a>3.1 标准流程（固定顺序）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEXT1. 初始化        ← 握手确认设备在线</span><br><span class="line">   ↓</span><br><span class="line">2. ROM 操作      ← 选择/跳过设备</span><br><span class="line">   ↓</span><br><span class="line">3. 功能指令      ← 发送设备特定命令</span><br><span class="line">   ↓</span><br><span class="line">4. 数据传输      ← 读取或写入数据</span><br></pre></td></tr></table></figure><p><strong>每次通信必须从初始化开始！</strong></p><hr><h3 id="3-2-ROM-操作指令（所有单总线设备通用）"><a href="#3-2-ROM-操作指令（所有单总线设备通用）" class="headerlink" title="3.2 ROM 操作指令（所有单总线设备通用）"></a>3.2 ROM 操作指令（所有单总线设备通用）</h3><table><thead><tr><th align="center">指令码</th><th align="left">名称</th><th align="left">功能</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="center"><code>0xCC</code></td><td align="left">Skip ROM</td><td align="left">跳过 ROM 匹配</td><td align="left"><strong>单设备</strong>系统（最常用）</td></tr><tr><td align="center"><code>0x55</code></td><td align="left">Match ROM</td><td align="left">选择特定设备</td><td align="left">多设备总线</td></tr><tr><td align="center"><code>0x33</code></td><td align="left">Read ROM</td><td align="left">读取 64 位 ROM 码</td><td align="left">获取设备 ID</td></tr><tr><td align="center"><code>0xF0</code></td><td align="left">Search ROM</td><td align="left">搜索所有设备</td><td align="left">设备枚举</td></tr></tbody></table><hr><h2 id="四、DS18B20-专属内容"><a href="#四、DS18B20-专属内容" class="headerlink" title="四、DS18B20 专属内容"></a>四、DS18B20 专属内容</h2><h3 id="4-1-功能指令（DS18B20-特定）"><a href="#4-1-功能指令（DS18B20-特定）" class="headerlink" title="4.1 功能指令（DS18B20 特定）"></a>4.1 功能指令（DS18B20 特定）</h3><table><thead><tr><th align="center">指令码</th><th align="left">名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center"><code>0x44</code></td><td align="left">Convert T</td><td align="left">启动温度转换（耗时 750ms）</td></tr><tr><td align="center"><code>0xBE</code></td><td align="left">Read Scratchpad</td><td align="left">读取暂存器（含温度数据）</td></tr><tr><td align="center"><code>0x4E</code></td><td align="left">Write Scratchpad</td><td align="left">写入配置（精度、报警阈值）</td></tr></tbody></table><hr><h3 id="4-2-暂存器结构（9-字节）"><a href="#4-2-暂存器结构（9-字节）" class="headerlink" title="4.2 暂存器结构（9 字节）"></a>4.2 暂存器结构（9 字节）</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111104128787.png"></p><p>调用 <code>0xBE</code> 后，DS18B20 按顺序发送：</p><table><thead><tr><th align="center">字节索引</th><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">Byte 0</td><td align="left">温度低 8 位（LSB）</td><td align="left">第1次 <code>Read_DS18B20()</code></td></tr><tr><td align="center">Byte 1</td><td align="left">温度高 8 位（MSB）</td><td align="left">第2次 <code>Read_DS18B20()</code></td></tr><tr><td align="center">Byte 2</td><td align="left">TH 寄存器</td><td align="left">高温报警阈值</td></tr><tr><td align="center">Byte 3</td><td align="left">TL 寄存器</td><td align="left">低温报警阈值</td></tr><tr><td align="center">Byte 4</td><td align="left">配置寄存器</td><td align="left">精度设置（9&#x2F;10&#x2F;11&#x2F;12位）</td></tr><tr><td align="center">Byte 5-7</td><td align="left">保留</td><td align="left">固定 0xFF</td></tr><tr><td align="center">Byte 8</td><td align="left">CRC 校验</td><td align="left">数据完整性校验</td></tr></tbody></table><hr><h3 id="4-3-温度数据格式"><a href="#4-3-温度数据格式" class="headerlink" title="4.3 温度数据格式"></a>4.3 温度数据格式</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111104239787.png"></p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105018620.png"></p><p><strong>16 位补码表示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TEXT高字节 (MSB)              低字节 (LSB)</span><br><span class="line">S S S S S 2⁶ 2⁵ 2⁴   2³ 2² 2¹ 2⁰ 2⁻¹ 2⁻² 2⁻³ 2⁻⁴</span><br><span class="line">└─符号位─┘  └─整数部分─┘  └─────小数部分─────┘</span><br></pre></td></tr></table></figure><ul><li><strong>分辨率</strong>：0.0625°C（1&#x2F;16）</li><li><strong>范围</strong>：-55°C ~ +125°C</li></ul><p><strong>计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">温度 = (high &lt;&lt; 8 | low) / 16.0</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXT+25.0625°C:  0x0191 = 401 → 401/16 = 25.0625</span><br><span class="line">-10.125°C:   0xFF5E（补码）→ -162/16 = -10.125</span><br></pre></td></tr></table></figure><hr><h3 id="4-4-完整读取温度代码"><a href="#4-4-完整读取温度代码" class="headerlink" title="4.4 完整读取温度代码"></a>4.4 完整读取温度代码</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251114104523084.png" alt="image-20251114104523084"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;onewire.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit DQ = P1 ^ 4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">float rd_temperature(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char low, high; // 用于存储温度的低位和高位字节</span><br><span class="line">   </span><br><span class="line">    init_ds18b20();         // 初始化DS18B20</span><br><span class="line">    Write_DS18B20(0xcc);    // 跳过ROM操作（适用于单总线只有一个设备的情况）</span><br><span class="line">    Write_DS18B20(0x44);    // 发送启动温度转换命令</span><br><span class="line"></span><br><span class="line">    init_ds18b20();         // 再次初始化DS18B20，准备读取</span><br><span class="line">    Write_DS18B20(0xcc);    // 跳过ROM操作</span><br><span class="line">    Write_DS18B20(0xbe);    // 发送读取暂存器命令</span><br><span class="line">    </span><br><span class="line">    low = Read_DS18B20();   // 读取温度值的低位字节</span><br><span class="line">    high = Read_DS18B20();  // 读取温度值的高位字节</span><br><span class="line">    </span><br><span class="line">    return ((high &lt;&lt; 8) | low) / 16.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Intrinsic Function（内嵌函数/固有函数）是一种特殊的函数。</span><br><span class="line">_nop_()：空操作（No Operation）。它会插入一个精确的机器周期延时，用于产生非常短的延时。</span><br><span class="line">_cror_()：循环右移（Circular Rotate Right）。</span><br><span class="line">_crol_()：循环左移（Circular Rotate Left）。</span><br><span class="line">_iror_()：带进位循环右移。</span><br><span class="line">_irol_()：带进位循环左移。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│         单总线 (One-Wire)            │  ← 通信协议（抽象规则）</span><br><span class="line">│   - 一种通信标准/协议                 │</span><br><span class="line">│   - 定义了时序规则                    │</span><br><span class="line">│   - 定义了通信流程                    │</span><br><span class="line">└──────────────┬──────────────────────┘</span><br><span class="line">               │ 遵循/实现</span><br><span class="line">               ▼</span><br><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│          DS18B20                    │  ← 具体芯片（实现者）</span><br><span class="line">│   - 一款温度传感器芯片                │</span><br><span class="line">│   - 使用单总线协议通信                │</span><br><span class="line">│   - 有自己特定的指令集                │</span><br><span class="line">└─────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​		&lt;/p&gt;
&lt;h1 id=&quot;单总线协议详解（DS18B20-）&quot;&gt;&lt;a href=&quot;#单总线协议详解（DS18B20-）&quot; class=&quot;headerlink&quot; title=&quot;单总线协议详解（DS18B20 ）&quot;&gt;&lt;/a&gt;单总线协议详解（DS18B20 ）&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>4.I2C协议（PCF8591）</title>
    <link href="https://rosslin.xyz/2025/11/24/4.I2C%E5%8D%8F%E8%AE%AE(PCF8591)/"/>
    <id>https://rosslin.xyz/2025/11/24/4.I2C%E5%8D%8F%E8%AE%AE(PCF8591)/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:17:43.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I2C-协议（PCF8591）"><a href="#I2C-协议（PCF8591）" class="headerlink" title="I2C 协议（PCF8591）"></a>I2C 协议（PCF8591）</h1><p>本文档记录了 I2C 通信协议的基础知识以及 PCF8591 芯片（8位AD&#x2F;DA转换器）的应用细节。</p><h2 id="🏗️-整体架构"><a href="#🏗️-整体架构" class="headerlink" title="🏗️ 整体架构"></a>🏗️ 整体架构</h2><h3 id="三层关系图"><a href="#三层关系图" class="headerlink" title="三层关系图"></a>三层关系图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TEXT┌─────────────────────────────────────────┐</span><br><span class="line">│  应用层：PCF8591芯片                     │</span><br><span class="line">│  ├─ 硬件功能：4路AD + 1路DA              │</span><br><span class="line">│  ├─ 设备地址：0x90/0x91                 │</span><br><span class="line">│  └─ 控制逻辑：寄存器/控制字节            │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  通信层：I2C协议                         │</span><br><span class="line">│  ├─ 7个基础函数（通用所有I2C设备）       │</span><br><span class="line">│  └─ 时序：Start/Stop/应答/数据传输       │</span><br><span class="line">├─────────────────────────────────────────┤</span><br><span class="line">│  硬件层：51单片机GPIO                    │</span><br><span class="line">│  ├─ SCL：P2.1（时钟线）                 │</span><br><span class="line">│  └─ SDA：P2.0（数据线）                 │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="整体架构与类比"><a href="#整体架构与类比" class="headerlink" title="整体架构与类比"></a>整体架构与类比</h2><p>I2C 相关的开发可以理解为分层结构：</p><table><thead><tr><th align="left">层次</th><th align="left">负责内容</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><strong>应用层</strong></td><td align="left">PCF8591 芯片功能逻辑、地址、控制字节。</td><td align="left">读取 AIN1，设置 DA 输出 150。</td></tr><tr><td align="left"><strong>通信层</strong></td><td align="left">I2C 协议的通用实现（Start&#x2F;Stop、应答、数据发送）。</td><td align="left"><strong>7个</strong>基础 I2C 函数（与设备无关）。</td></tr><tr><td align="left"><strong>硬件层</strong></td><td align="left">51单片机与 SCL&#x2F;SDA 引脚的 GPIO 操作。</td><td align="left">控制 P2.1 (SCL) 和 P2.0 (SDA) 的高低电平。</td></tr></tbody></table><h2 id="1-I2C-通信协议基础-Inter-Integrated-Circuit"><a href="#1-I2C-通信协议基础-Inter-Integrated-Circuit" class="headerlink" title="1. I2C 通信协议基础 (Inter-Integrated Circuit)"></a>1. I2C 通信协议基础 (Inter-Integrated Circuit)</h2><p>I2C 是一种由飞利浦（NXP）开发的<strong>同步、多主&#x2F;从、两线同步串行通信协议</strong>，主要用于短距离内连接低速外设。</p><ul><li><p>**SCL (Serial Clock Line，串行时钟线)**由主设备（Master）产生，用于同步数据传输。</p></li><li><p><strong>SDA (Serial Data Line，串行数据线):</strong> 用于传输数据。</p></li></ul><h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><table><thead><tr><th align="left">特点</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>线路</strong></td><td align="left">仅需 <strong>SCL</strong> (时钟线) 和 <strong>SDA</strong> (数据线) 两条线，均需<strong>上拉电阻</strong>。</td></tr><tr><td align="left"><strong>同步性</strong></td><td align="left"><strong>SCL</strong> 线上的时钟信号同步所有数据位传输。</td></tr><tr><td align="left"><strong>主从架构</strong></td><td align="left"><strong>主设备 (Master)</strong> 控制通信时序，<strong>从设备 (Slave)</strong> 响应请求，每个从设备有唯一的地址。</td></tr></tbody></table><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/i2c%E5%8D%8F%E8%AE%AE.png"></p><p>一个标准的 I2C 通信包括以下步骤：</p><ol><li><p><strong>起始条件 (Start):</strong> SCL 为高电平，SDA 从高电平拉低。</p></li><li><p><strong>发送地址:</strong> 主设备发送 7 位地址 + 1 位 <strong>R&#x2F;W</strong> 位（0&#x3D;写，1&#x3D;读）。</p></li><li><p><strong>应答 (ACK&#x2F;NACK):</strong> 被寻址的从设备必须将 SDA 拉低（ACK）。</p></li><li><p><strong>数据传输:</strong> 以 **8 位（1字节）**为单位进行交换，每字节后都需要应答。</p></li><li><p><strong>停止条件 (Stop):</strong> SCL 为高电平，SDA 从低电平拉高，释放总线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iic.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line"></span><br><span class="line">#define DELAY_TIME 5 //原来是10</span><br><span class="line"></span><br><span class="line">#define Photo_Res_Channel 0x41</span><br><span class="line">#define Adj_Res_Channel 0x43</span><br><span class="line"></span><br><span class="line">//总线引脚定义</span><br><span class="line">sbit SDA = P2^1;  /* 数据线 */</span><br><span class="line">sbit SCL = P2^0;  /* 时钟线 */</span><br><span class="line"></span><br><span class="line">void IIC_Delay(unsigned char i)</span><br><span class="line">&#123;</span><br><span class="line">    do&#123;_nop_();&#125;</span><br><span class="line">    while(i--);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//总线启动条件</span><br><span class="line">void IIC_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA = 1;</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = 0;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//总线停止条件</span><br><span class="line">void IIC_Stop(void)</span><br><span class="line">&#123;</span><br><span class="line">    SDA = 0;</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SDA = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发送应答</span><br><span class="line">void IIC_SendAck(bit ackbit)</span><br><span class="line">&#123;</span><br><span class="line">    SCL = 0;</span><br><span class="line">    SDA = ackbit;  // 0：应答，1：非应答</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    SCL = 0; </span><br><span class="line">    SDA = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待应答</span><br><span class="line">bit IIC_WaitAck(void)</span><br><span class="line">&#123;</span><br><span class="line">    bit ackbit;</span><br><span class="line"></span><br><span class="line">    SCL  = 1;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    ackbit = SDA;</span><br><span class="line">    SCL = 0;</span><br><span class="line">    IIC_Delay(DELAY_TIME);</span><br><span class="line">    return ackbit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过I2C总线发送数据</span><br><span class="line">void IIC_SendByte(unsigned char byt)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i;</span><br><span class="line"></span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SCL  = 0;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        if(byt &amp; 0x80) SDA  = 1;</span><br><span class="line">        else SDA  = 0;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">        SCL = 1;</span><br><span class="line">        byt &lt;&lt;= 1;</span><br><span class="line">        IIC_Delay(DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    SCL  = 0;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从I2C总线上接收数据</span><br><span class="line">unsigned char IIC_RecByte(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char i, da;</span><br><span class="line">    for(i=0; i&lt;8; i++)</span><br><span class="line">    &#123;   </span><br><span class="line">    SCL = 1;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">da &lt;&lt;= 1;</span><br><span class="line">if(SDA) da |= 1;</span><br><span class="line">SCL = 0;</span><br><span class="line">IIC_Delay(DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    return da;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="2-AD-DA-转换功能层"><a href="#2-AD-DA-转换功能层" class="headerlink" title="2. AD&#x2F;DA 转换功能层"></a>2. AD&#x2F;DA 转换功能层</h2><h3 id="什么是-AD-DA？"><a href="#什么是-AD-DA？" class="headerlink" title="什么是 AD&#x2F;DA？"></a>什么是 AD&#x2F;DA？</h3><h4 id="A-D-转换-Analog-to-Digital-ADC"><a href="#A-D-转换-Analog-to-Digital-ADC" class="headerlink" title="A&#x2F;D 转换 (Analog to Digital - ADC)"></a>A&#x2F;D 转换 (Analog to Digital - ADC)</h4><p>将连续的**模拟信号（电压）**转换为离散的**数字信号（0-255，8位）**。</p><p>模拟信号(0−5V)→ADC数字信号(0−255)模拟信号(0−5<em>V</em>)ADC数字信号(0−255)</p><ul><li><strong>示例:</strong> 输入 2.5V→2.5V→ 输出 127127 (约一半)。</li></ul><h4 id="D-A-转换-Digital-to-Analog-DAC"><a href="#D-A-转换-Digital-to-Analog-DAC" class="headerlink" title="D&#x2F;A 转换 (Digital to Analog - DAC)"></a>D&#x2F;A 转换 (Digital to Analog - DAC)</h4><p>将**数字信号（0-255）**转换为**模拟信号（电压）**。</p><p>数字信号(0−255)→DAC模拟信号(0−5V)数字信号(0−255)DAC模拟信号(0−5<em>V</em>)</p><ul><li><strong>示例:</strong> 输入 127→127→ 输出 ≈2.5V≈2.5V。</li></ul><h3 id="51单片机的局限与-PCF8591-的补充"><a href="#51单片机的局限与-PCF8591-的补充" class="headerlink" title="51单片机的局限与 PCF8591 的补充"></a>51单片机的局限与 PCF8591 的补充</h3><table><thead><tr><th align="left">设备</th><th align="left">限制&#x2F;能力</th></tr></thead><tbody><tr><td align="left"><strong>51单片机</strong></td><td align="left">只能识别和输出数字信号（0&#x2F;1）。</td></tr><tr><td align="left"><strong>PCF8591</strong></td><td align="left"><strong>4路AD</strong> (读取传感器) + <strong>1路DA</strong> (输出控制电压)。</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><table><thead><tr><th align="center">功能</th><th align="center">输入类型</th><th align="center">输出类型</th><th align="center">应用实例</th></tr></thead><tbody><tr><td align="center"><strong>AD</strong></td><td align="center">模拟传感器</td><td align="center">数字值</td><td align="center">温度检测、光照检测</td></tr><tr><td align="center"><strong>DA</strong></td><td align="center">数字值</td><td align="center">模拟电压</td><td align="center">LED调光、声音输出</td></tr></tbody></table><h2 id="🔧-PCF8591应用层"><a href="#🔧-PCF8591应用层" class="headerlink" title="🔧 PCF8591应用层"></a>🔧 PCF8591应用层</h2><h3 id="1-芯片概述"><a href="#1-芯片概述" class="headerlink" title="1. 芯片概述"></a>1. 芯片概述</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105134801.png"></p><p><strong>PCF8591 &#x3D; 8位AD&#x2F;DA转换器 + I2C接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEXT芯片引脚：</span><br><span class="line">  AIN0-AIN3：4路模拟输入（AD）</span><br><span class="line">  AOUT：     1路模拟输出（DA）</span><br><span class="line">  SCL/SDA：  I2C通信接口</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105211035.png"></p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105343352.png"></p><h3 id="2-设备地址（来自数据手册"><a href="#2-设备地址（来自数据手册" class="headerlink" title="2. 设备地址（来自数据手册)"></a>2. 设备地址（来自数据手册)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C// 地址格式：1001 A2 A1 A0 R/W</span><br><span class="line">// A2/A1/A0由硬件引脚决定（通常接地）</span><br><span class="line"></span><br><span class="line">#define PCF8591_ADDR_W  0x90  // 1001 0000 (写)</span><br><span class="line">#define PCF8591_ADDR_R  0x91  // 1001 0001 (读)</span><br></pre></td></tr></table></figure><p><strong>地址推导</strong>：</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105438501.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEXT基础地址：1001 000X</span><br><span class="line">         ││││ │││└─ R/W位</span><br><span class="line">         ││││ │└─── A0引脚（0=GND）</span><br><span class="line">         ││││ └──── A1引脚（0=GND）</span><br><span class="line">         │││└────── A2引脚（0=GND）</span><br><span class="line">         └┴┴─────── 固定标识</span><br><span class="line"></span><br><span class="line">写地址：1001 0000 = 0x90</span><br><span class="line">读地址：1001 0001 = 0x91</span><br></pre></td></tr></table></figure><hr><h3 id="3-控制字节（来自数据手册）"><a href="#3-控制字节（来自数据手册）" class="headerlink" title="3. 控制字节（来自数据手册）"></a>3. 控制字节（来自数据手册）</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105510306.png">]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 控制字节格式：</span><br><span class="line">// bit7 | bit6 | bit5 | bit4 | bit3 | bit2 | bit1 | bit0</span><br><span class="line">//  0   | DAC  | AIN2 | AIN1 | AIN0 |  0   | Auto | Auto</span><br><span class="line">//        使能   通道选择(0-3)         自动增量模式</span><br><span class="line"></span><br><span class="line">//滑动变阻器 0000 1000</span><br><span class="line">#define PCF8591_DAC_OFF  0x00  // 0000 0000</span><br><span class="line">#define PCF8591_DAC_ON   0x40  // 0100 0000</span><br></pre></td></tr></table></figure><h3 id="AD-读取函数"><a href="#AD-读取函数" class="headerlink" title="AD 读取函数"></a>AD 读取函数</h3><p><strong>PCF8591 读取特点:</strong> 每次使用读地址 <code>0x91</code> 通信时，它会返回<strong>两个字节</strong>：第一个是状态&#x2F;控制字，第二个才是我们需要的 AD 数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unsigned char Ad_Read(unsigned char addr)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char temp;</span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_SendByte(0x90);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line">IIC_SendByte(addr);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line">IIC_SendByte(0x91);</span><br><span class="line">IIC_WaitAck();</span><br><span class="line">temp = IIC_RecByte();</span><br><span class="line">IIC_SendAck(1);//应带信号  只有主机接收信号才需要发送</span><br><span class="line">IIC_Stop();</span><br><span class="line">return temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DA-输出函数"><a href="#DA-输出函数" class="headerlink" title="DA 输出函数"></a>DA 输出函数</h3><p>要通过 DA 输出一个数字值 <code>dat</code> (0-255)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Da_Write(unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">    IIC_Start();                   // 1. START信号</span><br><span class="line">    IIC_SendByte(0x90);            // 2. 发送写地址 (0x90)</span><br><span class="line">    IIC_WaitAck();                 // 3. 等待应答</span><br><span class="line">    IIC_SendByte(0x40);            // 4. 发送控制字节 (DAC使能)</span><br><span class="line">    IIC_WaitAck();                 // 5. 等待应答</span><br><span class="line">    IIC_SendByte(dat);             // 6. 发送DA值 (0-255)</span><br><span class="line">    IIC_WaitAck();                 // 7. 等待应答</span><br><span class="line">    IIC_Stop();                    // 8. STOP信号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p> <strong>易错点</strong>：混淆<code>IIC_SendByte</code>和<code>IIC_SendAck</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I2C-协议（PCF8591）&quot;&gt;&lt;a href=&quot;#I2C-协议（PCF8591）&quot; class=&quot;headerlink&quot; title=&quot;I2C 协议（PCF8591）&quot;&gt;&lt;/a&gt;I2C 协议（PCF8591）&lt;/h1&gt;&lt;p&gt;本文档记录了 I2C 通信协议的基础</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>6.DS1302实时时钟</title>
    <link href="https://rosslin.xyz/2025/11/24/6.DS1302/"/>
    <id>https://rosslin.xyz/2025/11/24/6.DS1302/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:19:05.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🕰️-DS1302-实时钟芯片学习笔记"><a href="#🕰️-DS1302-实时钟芯片学习笔记" class="headerlink" title="🕰️ DS1302 实时钟芯片学习笔记"></a>🕰️ DS1302 实时钟芯片学习笔记</h1><h2 id="一、DS1302-通讯协议"><a href="#一、DS1302-通讯协议" class="headerlink" title="一、DS1302 通讯协议"></a>一、DS1302 通讯协议</h2><p>DS1302 采用 <strong>Dallas&#x2F;Maxim 三线同步串行接口</strong>（专有协议）。</p><h3 id="1-信号线"><a href="#1-信号线" class="headerlink" title="1. 信号线"></a>1. 信号线</h3><p>芯片仅需 3 根信号线进行通信：</p><ul><li><strong>SCLK</strong>：串行时钟（<strong>主机输出</strong>）</li><li><strong>I&#x2F;O</strong>：双向数据线（<strong>开漏输出</strong>，必须外接上拉电阻）</li><li><strong>RST</strong>：片选&#x2F;复位（高电平有效，<strong>通信开始&#x2F;结束标志</strong>）</li></ul><h3 id="2-通信规则"><a href="#2-通信规则" class="headerlink" title="2. 通信规则"></a>2. 通信规则</h3><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>开始</strong></td><td>必须先拉高 <strong>RST</strong></td></tr><tr><td><strong>流程</strong></td><td>先发送 <strong>1 字节命令</strong> → 再读&#x2F;写 <strong>1 字节或多个字节数据</strong></td></tr><tr><td><strong>数据顺序</strong></td><td>数据传输时，<strong>低位在前 (LSB first)</strong></td></tr><tr><td><strong>结束</strong></td><td>必须拉低 <strong>RST</strong></td></tr></tbody></table><h2 id="二、程序中常用命令"><a href="#二、程序中常用命令" class="headerlink" title="二、程序中常用命令"></a>二、程序中常用命令</h2><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251120213917095.png" alt="image-20251120213917095"></p><h3 id="⚠️-编程重要提醒"><a href="#⚠️-编程重要提醒" class="headerlink" title="⚠️ 编程重要提醒"></a>⚠️ 编程重要提醒</h3><ol><li><strong>写保护控制：</strong><ul><li><strong>关闭写保护</strong>（允许写入）：<code>Write_Ds1302_Byte(0x8E, 0x00);</code></li><li><strong>打开写保护</strong>（禁止写入）：<code>Write_Ds1302_Byte(0x8E, 0x80);</code></li></ul></li><li><strong>时间启动：</strong><ul><li>在写入<strong>秒寄存器</strong> (<code>0x80</code>) 的值时，必须确保其 <strong>CH 位 (bit7) 为 0</strong>，即需要对写入值进行 <code>&amp; 0x7F</code> 操作，否则时间将停止。</li></ul></li></ol><h2 id="三、程序中的数据转换：十进制-↔-BCD-码"><a href="#三、程序中的数据转换：十进制-↔-BCD-码" class="headerlink" title="三、程序中的数据转换：十进制 ↔ BCD 码"></a>三、程序中的数据转换：十进制 ↔ BCD 码</h2><p>DS1302 的所有时间&#x2F;日期<strong>寄存器</strong>都使用<strong>BCD (Binary-Coded Decimal) 码</strong> 存储数据，而不是纯二进制。</p><h3 id="1-十进制-→-BCD-码（写入时使用）"><a href="#1-十进制-→-BCD-码（写入时使用）" class="headerlink" title="1. 十进制 → BCD 码（写入时使用）"></a>1. 十进制 → BCD 码（写入时使用）</h3><p>将十进制数拆分为“十位”和“个位”，并分别放入 BCD 字节的高 4 位和低 4 位。<br>$$<br>BCD &#x3D; \left(\frac{十进制}{10} \ll 4\right) ; \mid ; \left(十进制 \bmod 10\right)<br>$$<br>或使用加法：<br>$$<br>BCD &#x3D; \left(\left(\frac{十进制}{10}\right) \ll 4\right) + \left(十进制 \bmod 10\right)<br>$$<br>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23 → (2&lt;&lt;4)|3 = 0x23</span><br><span class="line">09 → (0&lt;&lt;4)|9 = 0x09</span><br><span class="line">58 → 0x58</span><br></pre></td></tr></table></figure><h3 id="2-BCD-码-→-十进制（读取时使用）"><a href="#2-BCD-码-→-十进制（读取时使用）" class="headerlink" title="2. BCD 码 → 十进制（读取时使用）"></a>2. BCD 码 → 十进制（读取时使用）</h3><p>将 BCD 字节的高 4 位乘以 10，然后加上低 4 位。<br>$$<br>十进制 &#x3D; \left(\frac{BCD}{16}\right) \times 10 + \left(BCD \bmod 16\right)<br>$$<br>或使用移位操作：<br>$$<br>十进制 &#x3D; \left(BCD \gg 4\right) \times 10 + \left(BCD \land 0x0F\right)<br>$$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x23 → (2)*10 + 3 = 23</span><br><span class="line">0x59 → 5*10 + 9 = 59</span><br></pre></td></tr></table></figure><h3 id="3-完整写入年月日时分秒"><a href="#3-完整写入年月日时分秒" class="headerlink" title="3. 完整写入年月日时分秒"></a>3. 完整写入年月日时分秒</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251120221158940.png" alt="image-20251120221158940"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;intrins.h&quot;</span><br><span class="line">sbit SDA = P2 ^ 3;</span><br><span class="line">sbit RST = P1 ^ 3;</span><br><span class="line">sbit SCK = P1 ^ 7;</span><br><span class="line"></span><br><span class="line">// Write_Ds1302_Byte(addr,dat)</span><br><span class="line">void Set_Rtc(unsigned char *ucRtc)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char i;</span><br><span class="line">  Write_Ds1302_Byte(0x8e, 0x00); // 禁止写保护 控制寄存器 bit7 是 WP 位，0=允许写入所有寄存器</span><br><span class="line">  Write_Ds1302_Byte(0x80, 0x80); // 暂停设备运行</span><br><span class="line">  for (i = 0; i &lt; 3; i++)</span><br><span class="line">    Write_Ds1302_Byte(0x84 - 2 * i, ucRtc[i] / 10 % 10 &lt;&lt; 4 | ucRtc[i] % 10);//十进制整数转换为BCD码 时分秒顺序</span><br><span class="line">    // 这行代码把一个十进制数（比如23）转换成了BCD码（`0010 0011`，即0x23）。</span><br><span class="line">  Write_Ds1302_Byte(0x8e, 0x80);//写保护</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Read_Rtc(unsigned char *ucRtc)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char i;</span><br><span class="line">  unsigned temp;</span><br><span class="line">  EA = 0; // 关闭总中断，防止时序错误</span><br><span class="line">  for (i = 0; i &lt; 3; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp = Read_Ds1302_Byte(0x85 - 2 * i);</span><br><span class="line">    ucRtc[i] = temp / 16 * 10 + temp % 16;//BCD码到十进制数的转换。</span><br><span class="line">    //这行代码把BCD码（比如0x23）转换回了十进制数23。</span><br><span class="line">  &#125;</span><br><span class="line">  EA = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🕰️-DS1302-实时钟芯片学习笔记&quot;&gt;&lt;a href=&quot;#🕰️-DS1302-实时钟芯片学习笔记&quot; class=&quot;headerlink&quot; title=&quot;🕰️ DS1302 实时钟芯片学习笔记&quot;&gt;&lt;/a&gt;🕰️ DS1302 实时钟芯片学习笔记&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>8.任务调度器</title>
    <link href="https://rosslin.xyz/2025/11/24/8.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://rosslin.xyz/2025/11/24/8.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:19:34.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);          <span class="comment">// 【1】要执行的函数（函数指针）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> rate_ms;        <span class="comment">// 【2】每隔多少毫秒执行一次（固定值）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> last_ms;        <span class="comment">// 【3】上次执行的时间（会自己变）</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure><h3 id="1-定义结构体（只是画一张“任务卡的模板）"><a href="#1-定义结构体（只是画一张“任务卡的模板）" class="headerlink" title="1. 定义结构体（只是画一张“任务卡的模板）"></a>1. 定义结构体（只是画一张“任务卡的模板）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单任务调度器结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*task_func)(<span class="type">void</span>);          <span class="comment">// 任务函数指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> rate_ms;        <span class="comment">// 执行周期（毫秒）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> last_ms;        <span class="comment">// 上次执行的时间戳</span></span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br></pre></td></tr></table></figure><h3 id="2-创建任务列表（真正填好的8张任务卡）"><a href="#2-创建任务列表（真正填好的8张任务卡）" class="headerlink" title="2. 创建任务列表（真正填好的8张任务卡）"></a>2. 创建任务列表（真正填好的8张任务卡）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法：用 .成员名 = 值，顺序随便改也不怕错！</span></span><br><span class="line">idata <span class="type">task_t</span> Scheduler_Task[] = &#123;</span><br><span class="line">  &#123;Led_Proc, <span class="number">1</span>, <span class="number">0</span>&#125;,   <span class="comment">// LED任务，每1ms</span></span><br><span class="line">&#123;Key_Proc, <span class="number">10</span>, <span class="number">0</span>&#125;,   <span class="comment">// 按键任务，每10ms</span></span><br><span class="line">&#123;Seg_Proc, <span class="number">20</span>, <span class="number">0</span>&#125;,   <span class="comment">// 数码管任务，每20ms</span></span><br><span class="line">&#123;Get_Time, <span class="number">100</span>, <span class="number">0</span>&#125;,   <span class="comment">// 获取时间任务，每100ms</span></span><br><span class="line">&#123;Get_Temperature, <span class="number">300</span>, <span class="number">0</span>&#125;, <span class="comment">// 获取温度任务，每300ms</span></span><br><span class="line">&#123;AD_DA, <span class="number">150</span>, <span class="number">0</span>&#125;,   <span class="comment">// AD/DA任务，每150ms</span></span><br><span class="line">&#123;Get_Distance, <span class="number">120</span>, <span class="number">0</span>&#125;,   <span class="comment">// 获取距离任务，每120ms</span></span><br><span class="line">&#123;Uart_Proc, <span class="number">10</span>, <span class="number">0</span>&#125;,   <span class="comment">// 串口处理任务，每10ms</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-初始化：自动算出有几个任务"><a href="#3-初始化：自动算出有几个任务" class="headerlink" title="3. 初始化：自动算出有几个任务"></a>3. 初始化：自动算出有几个任务</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">idata <span class="type">unsigned</span> <span class="type">char</span> task_num;   <span class="comment">// 任务数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduler_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    task_num = <span class="keyword">sizeof</span>(Scheduler_Task) / <span class="keyword">sizeof</span>(<span class="type">task_t</span>);  <span class="comment">// 总字节数 / 结构体字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-核心运行函数（每1ms调用一次就行）"><a href="#4-核心运行函数（每1ms调用一次就行）" class="headerlink" title="4. 核心运行函数（每1ms调用一次就行）"></a>4. 核心运行函数（每1ms调用一次就行）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Scheduler_Run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_time = uwTick;   <span class="comment">// 当前毫秒计数值（自己写个定时器维护）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; task_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前时间 - 上次执行时间 &gt;= 周期 → 该干活了</span></span><br><span class="line">        <span class="keyword">if</span>(now_time - Scheduler_Task[i].last_ms &gt;= Scheduler_Task[i].rate_ms)</span><br><span class="line">        &#123;</span><br><span class="line">            Scheduler_Task[i].last_ms = now_time;   <span class="comment">// 记住这次时间</span></span><br><span class="line">            Scheduler_Task[i].task_func();          <span class="comment">// 真正执行任务！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方法（超级简单）"><a href="#使用方法（超级简单）" class="headerlink" title="使用方法（超级简单）"></a>使用方法（超级简单）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 系统初始化...</span></span><br><span class="line">    Timer0_Init();         <span class="comment">// 1ms中断，里面维护 uwTick++    idata unsigned long int uwTick;</span></span><br><span class="line">    Scheduler_Init();      <span class="comment">// 计算任务数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Scheduler_Run();   <span class="comment">// 放在主循环里，或者1ms中断里都行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点口诀表"><a href="#重点口诀表" class="headerlink" title="重点口诀表"></a>重点口诀表</h3><table><thead><tr><th>项目</th><th>正确写法</th><th>错误写法</th><th>为什么</th></tr></thead><tbody><tr><td>取成员</td><td><code>Scheduler_Task[i].task_func()</code></td><td><code>Scheduler_Task[i]-&gt;task_func()</code></td><td>实物用 .   指针用 -&gt;</td></tr><tr><td>初始化</td><td><code>{ .task_func = xxx, .rate_ms = yyy }</code></td><td>乱序写</td><td>防止结构体改顺序后死机</td></tr><tr><td>调用函数</td><td><code>task_func()</code> 加括号</td><td>只写 <code>task_func</code></td><td>没括号等于没按遥控器</td></tr><tr><td>计算任务数量</td><td><code>sizeof(array)/sizeof(task_t)</code></td><td>手动写数字8</td><td>增删任务不用改代码</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th>类型</th><th>占用字节</th><th>能表示的范围（无符号）</th><th>典型用途</th><th>你代码里出现的例子</th></tr></thead><tbody><tr><td><code>unsigned char</code></td><td>1字节</td><td>0 ~ 255</td><td>普通标志位、端口、计数小数字</td><td><code>unsigned char i;</code> <code>P0 = 0x55;</code></td></tr><tr><td><code>unsigned int</code></td><td>2字节</td><td>0 ~ 65,535</td><td>一般计数、延时、ADC值</td><td><code>unsigned int delay;</code></td></tr><tr><td><code>unsigned long int</code></td><td>4字节</td><td>0 ~ 4,294,967,295（42亿）</td><td><strong>时间戳、长计时、大数值、毫秒计数</strong></td><td><code>uwTick</code> 系统毫秒计时 <code>last_ms</code>、<code>rate_ms</code></td></tr><tr><td><code>unsigned long</code></td><td>4字节</td><td>同上，和上面完全一样</td><td>很多人懒得写 int，就简写成这个</td><td>很多代码里你会看到 <code>unsigned long</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;任务调度器&quot;&gt;&lt;a href=&quot;#任务调度器&quot; class=&quot;headerlink&quot; title=&quot;任务调度器&quot;&gt;&lt;/a&gt;任务调度器&lt;/h1&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>7.NE555频率测量系统设计</title>
    <link href="https://rosslin.xyz/2025/11/24/7.NE555/"/>
    <id>https://rosslin.xyz/2025/11/24/7.NE555/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:19:18.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NE555频率测量系统设计"><a href="#NE555频率测量系统设计" class="headerlink" title="NE555频率测量系统设计"></a>NE555频率测量系统设计</h1><h2 id="📋-系统概述"><a href="#📋-系统概述" class="headerlink" title="📋 系统概述"></a>📋 系统概述</h2><p>基于NE555方波发生器和51单片机的频率测量系统，通过计数器模式精确测量外部脉冲频率。</p><hr><h2 id="🔧-硬件设计"><a href="#🔧-硬件设计" class="headerlink" title="🔧 硬件设计"></a>🔧 硬件设计</h2><h3 id="NE555原理图"><a href="#NE555原理图" class="headerlink" title="NE555原理图"></a>NE555原理图</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251121221438634.png" alt="NE555原理图"></p><h3 id="定时器数据手册"><a href="#定时器数据手册" class="headerlink" title="定时器数据手册"></a>定时器数据手册</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251121222129653.png" alt="定时器数据手册"></p><hr><h2 id="🏗️-系统整体框图"><a href="#🏗️-系统整体框图" class="headerlink" title="🏗️ 系统整体框图"></a>🏗️ 系统整体框图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+------------------+</span><br><span class="line">|  NE555方波发生器   |  ← 用来产生已知/可调频率的方波（相当于信号源）</span><br><span class="line">|  输出引脚3 (OUT)   |</span><br><span class="line">+--------+---------+</span><br><span class="line">         ↓ (一根信号线)</span><br><span class="line">   单片机 P3.4 (T0引脚)</span><br><span class="line">         ↓</span><br><span class="line">+--------v---------+</span><br><span class="line">|    51单片机内部    |</span><br><span class="line">|                   |</span><br><span class="line">|  T0：计数器模式    | ← 专门负责数外部脉冲个数（16位）</span><br><span class="line">|  T1：定时器模式    | ← 产生精确的1秒“闸门时间”</span><br><span class="line">|                   |</span><br><span class="line">|  每1秒读取一次T0   |</span><br><span class="line">|  计数值 → 频率值   |</span><br><span class="line">|  → 送数码管显示    |</span><br><span class="line">+-------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="💻-程序设计"><a href="#💻-程序设计" class="headerlink" title="💻 程序设计"></a>💻 程序设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief 定时器0初始化函数</span><br><span class="line"> * 配置为计数器模式，用于测量外部脉冲频率。</span><br><span class="line"> */</span><br><span class="line">void Timer0_Init(void) // 1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0x7F; // 定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0xF0; // 清除T0的模式位</span><br><span class="line">TMOD |= 0x05; // 设置为计数器模式(M1=0, M0=1, C/T=1)，外部引脚T0(P3.4)的下降沿计数</span><br><span class="line">TL0 = 0x00;  // 设置计数器初始值</span><br><span class="line">TH0 = 0x00;  // 设置计数器初始值</span><br><span class="line">TF0 = 0;  // 清除TF0溢出标志</span><br><span class="line">TR0 = 1;  // 定时器0开始工作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 定时器1初始化函数</span><br><span class="line"> * 配置为1ms中断的定时器，作为系统的心跳。</span><br><span class="line"> */</span><br><span class="line">void Timer1_Init(void) // 1毫秒@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">AUXR &amp;= 0xBF; // 定时器时钟12T模式</span><br><span class="line">TMOD &amp;= 0x0F; // 设置定时器模式 (清空T1的设置)</span><br><span class="line">TL1 = 0x18;  // 设置定时初始值 (65536-1000) -&gt; FC18H</span><br><span class="line">TH1 = 0xFC;  // 设置定时初始值</span><br><span class="line">TF1 = 0;  // 清除TF1溢出标志</span><br><span class="line">TR1 = 1;  // 定时器1开始计时</span><br><span class="line">ET1 = 1;  // 使能定时器1中断</span><br><span class="line">EA = 1;  // 开启总中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 定时器1中断服务函数</span><br><span class="line"> * 每1ms执行一次，处理需要定时执行的任务。</span><br><span class="line"> */</span><br><span class="line">void Timer1_Isr(void) interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">uwTick++; // 系统滴答计时器加1</span><br><span class="line"></span><br><span class="line">// 频率测量，每1000ms (1s) 计算一次</span><br><span class="line">if (++Time_1s == 1000)</span><br><span class="line">&#123;</span><br><span class="line">Time_1s = 0; // 计时器清零</span><br><span class="line">// 读取T0的计数值，即为过去1秒内的脉冲数(Hz)</span><br><span class="line">Freq = (TH0 &lt;&lt; 8) | TL0;</span><br><span class="line">TH0 = TL0 = 0; // 清空T0计数器，开始下一个周期的测量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NE555频率测量系统设计&quot;&gt;&lt;a href=&quot;#NE555频率测量系统设计&quot; class=&quot;headerlink&quot; title=&quot;NE555频率测量系统设计&quot;&gt;&lt;/a&gt;NE555频率测量系统设计&lt;/h1&gt;&lt;h2 id=&quot;📋-系统概述&quot;&gt;&lt;a href=&quot;#📋</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>9.串口通信 (UART) </title>
    <link href="https://rosslin.xyz/2025/11/24/9.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(UART)/"/>
    <id>https://rosslin.xyz/2025/11/24/9.%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%20(UART)/</id>
    <published>2025-11-24T02:00:00.000Z</published>
    <updated>2025-11-28T10:19:42.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📝-串口通信-UART"><a href="#📝-串口通信-UART" class="headerlink" title="📝 串口通信 (UART)"></a>📝 串口通信 (UART)</h1><h2 id="1-串口-UART-是什么？"><a href="#1-串口-UART-是什么？" class="headerlink" title="1. 串口 (UART) 是什么？"></a>1. 串口 (UART) 是什么？</h2><p>串口是一种用于点对点设备间通信的<strong>异步串行</strong>通信协议。</p><h3 id="🚀-串口与-I²C-的核心对比"><a href="#🚀-串口与-I²C-的核心对比" class="headerlink" title="🚀 串口与 I²C 的核心对比"></a>🚀 串口与 I²C 的核心对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>串口 (UART)</strong></th><th><strong>I²C (已学)</strong></th></tr></thead><tbody><tr><td><strong>传输类型</strong></td><td><strong>串行</strong> (一位一位)</td><td><strong>串行</strong> (一位一位)</td></tr><tr><td><strong>同步性</strong></td><td><strong>异步</strong> (无时钟线)</td><td><strong>同步</strong> (有 SCL 时钟线)</td></tr><tr><td><strong>时钟源</strong></td><td><strong>内部定时器</strong>生成波特率时钟</td><td><strong>主设备</strong>通过 SCL 线提供外部时钟</td></tr><tr><td><strong>拓扑结构</strong></td><td><strong>点对点</strong> (多数情况)</td><td><strong>总线型</strong> (多主多从)</td></tr><tr><td><strong>地址寻址</strong></td><td><strong>不需要</strong>地址</td><td><strong>需要</strong>地址 (7&#x2F;10 位地址)</td></tr><tr><td><strong>双工性</strong></td><td><strong>全双工</strong> (TX&#x2F;RX 分离，可同时收发)</td><td><strong>半双工</strong> (SDA 线，分时收发)</td></tr><tr><td><strong>信号线</strong></td><td>2 根：TXD (发送), RXD (接收)</td><td>2 根：SDA (数据), SCL (时钟)</td></tr><tr><td><strong>核心机制</strong></td><td>波特率、起始位、停止位</td><td>起始&#x2F;停止信号、ACK&#x2F;NACK</td></tr></tbody></table><h3 id="🔍-串口的核心概念"><a href="#🔍-串口的核心概念" class="headerlink" title="🔍 串口的核心概念"></a>🔍 串口的核心概念</h3><ul><li><strong>异步 (Asynchronous):</strong> 收发双方必须约定<strong>波特率</strong>，通过数据帧中的<strong>起始位</strong>实现同步。</li><li><strong>波特率 (Baud Rate):</strong> 每秒传输的位数 (bps)，收发双方必须一致。</li><li><strong>数据帧:</strong> 一帧数据包含：<code>起始位 (1位, 低电平)</code> + <code>数据位 (5~8位)</code> + <code>校验位 (可选)</code> + <code>停止位 (1~2位, 高电平)</code>。</li><li><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF.png"></li></ul><h2 id="2-串口数据收发与解析方式"><a href="#2-串口数据收发与解析方式" class="headerlink" title="2. 串口数据收发与解析方式"></a>2. 串口数据收发与解析方式</h2><p>串口通信的思路可以分为底层<strong>数据驱动</strong>和上层<strong>数据解析</strong>。</p><h3 id="A-驱动层思路：数据接收方式-CPU如何获取数据"><a href="#A-驱动层思路：数据接收方式-CPU如何获取数据" class="headerlink" title="A. 驱动层思路：数据接收方式 (CPU如何获取数据)"></a>A. 驱动层思路：数据接收方式 (CPU如何获取数据)</h3><table><thead><tr><th><strong>方式</strong></th><th><strong>描述</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td>1.<strong>轮询&#x2F;查询 (Polling)</strong></td><td>CPU 不断查询接收标志位 (<code>RI</code>)，直到其置 1 时读取数据。</td><td><strong>优点:</strong> 代码简单。 <strong>缺点:</strong> 效率极低，CPU 忙等浪费资源。</td></tr><tr><td>2.<strong>中断 (Interrupt)</strong></td><td>硬件接收完数据后，置位 <code>RI</code> 并触发中断。CPU 在中断服务函数 (<code>ISR</code>) 中处理数据。</td><td><strong>优点:</strong> <strong>效率高</strong>，CPU 可执行主程序。 <strong>缺点:</strong> 需配置中断。</td></tr><tr><td>3.<strong>DMA (直接存储器存取)</strong></td><td>(高级单片机) 数据直接从串口硬件搬运到内存，无需 CPU 参与。</td><td><strong>优点:</strong> <strong>最高效</strong>，几乎不占 CPU 资源。 <strong>缺点:</strong> 配置复杂，硬件要求高。</td></tr></tbody></table><h3 id="B-应用层思路：数据解析方式-如何判断一帧数据结束"><a href="#B-应用层思路：数据解析方式-如何判断一帧数据结束" class="headerlink" title="B. 应用层思路：数据解析方式 (如何判断一帧数据结束)"></a>B. 应用层思路：数据解析方式 (如何判断一帧数据结束)</h3><table><thead><tr><th><strong>方式</strong></th><th><strong>描述</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>1.<strong>字符流&#x2F;结束符</strong></td><td>以特定的字符（如 <code>\n</code>, <code>\r\n</code>）作为一帧数据的结束标志。</td><td>命令行交互、文本传输。</td></tr><tr><td>2.<strong>固定长度</strong></td><td>预先约定数据包长度。计数器达到约定长度后认为接收完成。</td><td>传感器数据流、固定格式协议。</td></tr><tr><td>3.<strong>帧头&#x2F;长度&#x2F;校验</strong></td><td>数据包包含：帧头、数据长度、有效数据、校验和、帧尾。</td><td><strong>最可靠</strong>，用于工业控制、复杂自定义协议。</td></tr><tr><td>4.<strong>超时 (Timeout)</strong></td><td>收到第一个字节后开始计时，如果在设定的时间阈值内没有收到后续字节，则认为当前数据接收完成。</td><td><strong>最灵活</strong>，适用于数据长度不固定、实时性要求不高的场景。</td></tr></tbody></table><h2 id="3-代码思路总结"><a href="#3-代码思路总结" class="headerlink" title="3.代码思路总结"></a>3.代码思路总结</h2><p>您的代码（基于 8051&#x2F;STC 单片机）采用了以下成熟的驱动和应用思路：</p><h3 id="A-数据发送思路：查询-忙等发送"><a href="#A-数据发送思路：查询-忙等发送" class="headerlink" title="A. 数据发送思路：查询&#x2F;忙等发送"></a>A. 数据发送思路：<strong>查询&#x2F;忙等发送</strong></h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123114733536.png" alt="串口配置"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;uart.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void Uart1_Init(void)//9600bps@12.000MHz</span><br><span class="line">&#123;</span><br><span class="line">SCON = 0x50;//8位数据,可变波特率</span><br><span class="line">AUXR |= 0x01;//串口1选择定时器2为波特率发生器</span><br><span class="line">AUXR &amp;= 0xFB;//定时器时钟12T模式</span><br><span class="line">T2L = 0xE6;//设置定时初始值</span><br><span class="line">T2H = 0xFF;//设置定时初始值</span><br><span class="line">AUXR |= 0x10;//定时器2开始计时</span><br><span class="line">ES = 1;//使能串口1中断</span><br><span class="line">EA = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extern char putchar (char ch)</span><br><span class="line">&#123;</span><br><span class="line">    SBUF = ch;</span><br><span class="line">    while(TI == 0)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    TI = 0;</span><br><span class="line">    return ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-数据接收思路：中断接收-超时解析"><a href="#B-数据接收思路：中断接收-超时解析" class="headerlink" title="B. 数据接收思路：中断接收 + 超时解析"></a>B. 数据接收思路：<strong>中断接收 + 超时解析</strong></h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123115349717.png" alt="中断号"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Uart1_Isr(void) interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">if (RI) // 判断是否是接收中断</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Flag = 1; // 设置接收标志</span><br><span class="line">Uart_Rx_Tick = 0; // 重置超时计时器</span><br><span class="line">Uart_Rx_Buf[Uart_Rx_Index++] = SBUF;</span><br><span class="line">RI = 0; // 手动清除接收中断请求位</span><br><span class="line">if (Uart_Rx_Index &gt; 10)</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Index = 0;</span><br><span class="line">memset(Uart_Rx_Buf, 0, 10); // 溢出则清空缓冲区</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Timer0Server() interrupt 1</span><br><span class="line">&#123;   </span><br><span class="line">    if(Uart_Rx_Flag == 1)</span><br><span class="line">        Uart_Recv_Tick ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="III-代码解析：8051-串口实现"><a href="#III-代码解析：8051-串口实现" class="headerlink" title="III. 代码解析：8051 串口实现"></a>III. 代码解析：8051 串口实现</h2><h3 id="1-核心寄存器：SBUF-Serial-Buffer-Register"><a href="#1-核心寄存器：SBUF-Serial-Buffer-Register" class="headerlink" title="1. 核心寄存器：SBUF (Serial Buffer Register)"></a>1. 核心寄存器：SBUF (Serial Buffer Register)</h3><ul><li><strong>功能：</strong> 串口数据交换的<strong>唯一通道</strong>（“信箱”）。</li><li><strong>发送：</strong> 写入 <code>SBUF = ch </code>立即启动发送。</li><li><strong>接收：</strong> 接收完成后，数据自动存入 $\text{SBUF}$，需读取 $\text{ch} &#x3D; \text{SBUF}$。</li></ul><h3 id="2-数据发送：查询-忙等-用于-printf-重定向"><a href="#2-数据发送：查询-忙等-用于-printf-重定向" class="headerlink" title="2. 数据发送：查询&#x2F;忙等 (用于 printf 重定向)"></a>2. 数据发送：查询&#x2F;忙等 (用于 <code>printf</code> 重定向)</h3><p>该代码利用了 <strong>C 语言 I&#x2F;O 重定向机制</strong>。</p><h4 id="机制：printf-重定向"><a href="#机制：printf-重定向" class="headerlink" title="机制：printf 重定向"></a>机制：<code>printf</code> 重定向</h4><table><thead><tr><th><strong>概念</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>目标</strong></td><td>将 <code>printf</code> 的输出目标从默认的“屏幕&#x2F;控制台”<strong>转移</strong>到“串口硬件”。</td></tr><tr><td><strong>原理</strong></td><td><code>printf</code> 函数在底层依赖于一个名为 <code>putchar(char ch)</code> 的函数来逐个输出字符。</td></tr><tr><td><strong>操作</strong></td><td>程序员通过<strong>自行实现</strong> <code>char putchar(char ch)</code> 函数，并在其内部直接操作串口发送寄存器 <code>SBUF</code>。链接器将自动用您的版本替换库中的默认版本。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251123120637083.png" alt="image-20251123120637083"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;string.h&quot; // 字符串处理函数</span><br><span class="line">#include &quot;stdio.h&quot;// 标准输入输出函数，如 printf 和 sscanf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 串口接收相关变量</span><br><span class="line">idata unsigned char Uart_Rx_Index;  // 串口接收缓冲区索引</span><br><span class="line">pdata unsigned char Uart_Rx_Buf[10] = &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;; // 串口接收缓冲区</span><br><span class="line">idata unsigned char Uart_Rx_Flag;  // 串口接收到数据的标志</span><br><span class="line">idata unsigned char Uart_Rx_Tick;  // 串口接收超时计时器</span><br><span class="line"></span><br><span class="line">void Uart_Proc() //超时解析</span><br><span class="line">&#123;</span><br><span class="line">// 如果没有接收到数据，直接返回</span><br><span class="line">if (Uart_Rx_Index == 0)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">// 如果距离上次接收到数据超过10ms（超时）</span><br><span class="line">if (Uart_Rx_Tick &gt;= 10)</span><br><span class="line">&#123;</span><br><span class="line">Uart_Rx_Flag = 0; // 清除接收标志</span><br><span class="line">Uart_Rx_Tick = 0; // 复位超时计时器</span><br><span class="line"></span><br><span class="line">//处理函数</span><br><span class="line"></span><br><span class="line">// 清空接收缓冲区，为下次接收做准备</span><br><span class="line">memset(Uart_Rx_Buf, 0, Uart_Rx_Index);</span><br><span class="line">Uart_Rx_Index = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📝-串口通信-UART&quot;&gt;&lt;a href=&quot;#📝-串口通信-UART&quot; class=&quot;headerlink&quot; title=&quot;📝 串口通信 (UART)&quot;&gt;&lt;/a&gt;📝 串口通信 (UART)&lt;/h1&gt;&lt;h2 id=&quot;1-串口-UART-是什么？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>0.单片机Keil工程模板搭建指南 (V4T)</title>
    <link href="https://rosslin.xyz/2025/11/22/0.Keil%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <id>https://rosslin.xyz/2025/11/22/0.Keil%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</id>
    <published>2025-11-22T02:00:00.000Z</published>
    <updated>2025-11-28T10:16:50.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单片机Keil工程模板搭建指南-V4T"><a href="#单片机Keil工程模板搭建指南-V4T" class="headerlink" title="单片机Keil工程模板搭建指南 (V4T)"></a>单片机Keil工程模板搭建指南 (V4T)</h1><blockquote><p><strong>核心原则：</strong> 物理文件夹与Keil逻辑Group保持镜像对应。</p></blockquote><hr><h3 id="Step-1-物理准备"><a href="#Step-1-物理准备" class="headerlink" title="Step 1: 物理准备"></a><strong>Step 1: 物理准备</strong></h3><ol><li><strong>建根目录</strong>：新建 <code>V4T</code> 文件夹。</li><li><strong>建子目录</strong>：进入 <code>V4T</code>，新建 <code>User</code> 和 <code>Driver</code> 两个文件夹。<blockquote><p><strong>一句话点醒</strong>：这是在硬盘上为代码分好“类”，为后续逻辑管理打基础。<br><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251115175154940.png" alt="image-20251115175154940"></p></blockquote></li></ol><hr><h3 id="Step-2-Keil工程初始化"><a href="#Step-2-Keil工程初始化" class="headerlink" title="Step 2: Keil工程初始化"></a><strong>Step 2: Keil工程初始化</strong></h3><ol><li><strong>新建工程</strong>：<code>Project -&gt; New µVision Project...</code></li><li><strong>保存位置</strong>：<strong>必须</strong>选择并进入 <code>User</code> 文件夹，工程名也起 <code>V4T</code>。</li><li><strong>选芯片</strong>：选择你的目标芯片，RTE窗口直接关掉。<blockquote><p><strong>一句话点醒</strong>：工程文件（蓝图）和核心代码放一起，方便管理。<br><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251115175609525.png" alt="image-20251115175609525"></p></blockquote></li></ol><hr><h3 id="Step-3-构建逻辑结构"><a href="#Step-3-构建逻辑结构" class="headerlink" title="Step 3: 构建逻辑结构"></a><strong>Step 3: 构建逻辑结构</strong></h3><ol><li><strong>改Target名</strong>：将 <code>Target 1</code> 改为 <code>V4T</code>。</li><li><strong>清空Groups</strong>：删除默认的 <code>Source Group 1</code>。</li><li><strong>新建Groups</strong>：添加 <code>User</code> 和 <code>Driver</code> 两个Group。<blockquote><p><strong>一句话点醒</strong>：Groups是Keil里的“虚拟文件夹”，让它和你的物理文件夹结构完全一样。<br><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251115175238712.png" alt="image-20251115175238712"></p></blockquote></li></ol><hr><h3 id="Step-4-添加源文件"><a href="#Step-4-添加源文件" class="headerlink" title="Step 4: 添加源文件"></a><strong>Step 4: 添加源文件</strong></h3><ol><li><strong>添加主文件</strong>：右键 <code>User</code> Group -&gt; <code>Add New Item...</code> -&gt; 创建 <code>main.c</code>。</li><li><strong>添加驱动文件</strong>：右键 <code>Driver</code> Group -&gt; <code>Add New Item...</code> -&gt; 创建 <code>led.c</code>、<code>led.h</code> 等。<ul><li><strong>关键</strong>：保存时，务必手动将 <code>led.c</code> 和 <code>led.h</code> 存到<strong>物理的 <code>Driver</code> 文件夹</strong>里！<blockquote><p><strong>一句话点醒</strong>：手动同步逻辑和物理，这是结构不混乱的关键！</p></blockquote></li></ul></li></ol><hr><h3 id="Step-5-工程配置"><a href="#Step-5-工程配置" class="headerlink" title="Step 5: 工程配置"></a><strong>Step 5: 工程配置</strong></h3><ol><li><strong>打开“魔术棒”</strong>：<code>Options for Target &#39;V4T&#39;</code>。</li><li><strong>添加头文件路径</strong>：<ul><li><code>C/C++</code> 选项卡 -&gt; <code>Include Paths</code> -&gt; 添加 <code>../Driver</code>。</li></ul></li><li><strong>生成Hex文件</strong>：<ul><li><code>Output</code> 选项卡 -&gt; 勾选 <code>Create HEX File</code>。<blockquote><p><strong>一句话点醒</strong>：告诉编译器去哪找头文件，并让它生成能烧录的文件。<br><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/image-20251115175720773.png" alt="image-20251115175720773"></p></blockquote></li></ul></li></ol><hr><h3 id="最终结构对照"><a href="#最终结构对照" class="headerlink" title="最终结构对照"></a><strong>最终结构对照</strong></h3><table><thead><tr><th align="left">物理文件系统</th><th align="left">Keil逻辑视图</th></tr></thead><tbody><tr><td align="left"><code>V4T/</code></td><td align="left"><code>Project: V4T</code></td></tr><tr><td align="left"><code>├── User/</code></td><td align="left"><code>└── Target: V4T</code></td></tr><tr><td align="left"><code>│   ├── main.c</code></td><td align="left"><code>    ├── User</code></td></tr><tr><td align="left"><code>│   └── V4T.uvprojx</code></td><td align="left"><code>    │   └── main.c</code></td></tr><tr><td align="left"><code>└── Driver/</code></td><td align="left"><code>    └── Driver</code></td></tr><tr><td align="left"><code>    ├── led.c</code></td><td align="left"><code>        ├── led.c</code></td></tr><tr><td align="left"><code>    └── led.h</code></td><td align="left"><code>        └── led.h</code></td></tr></tbody></table><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">V4T/</span><br><span class="line">├── User/</span><br><span class="line">│   ├── V4T.uvprojx      &lt;-- Keil工程文件</span><br><span class="line">│   ├── V4T.uvoptx       &lt;-- Keil工程选项文件</span><br><span class="line">│   ├── main.c           &lt;-- 主程序</span><br><span class="line">│   └── Objects/          &lt;-- 编译输出文件夹 (Keil自动生成)</span><br><span class="line">│       └── V4T.axf, V4T.hex ...</span><br><span class="line">└── Driver/</span><br><span class="line">    ├── led.c            &lt;-- LED驱动源文件 (待添加)</span><br><span class="line">    └── led.h            &lt;-- LED驱动头文件 (待添加)</span><br></pre></td></tr></table></figure><p><strong>搞定！</strong> 这份清单应该能让你在1分钟内回忆起所有关键步骤和注意事项。</p>]]></content>
    
    
    <summary type="html">这是一篇关于蓝桥杯的零基础入门教程，如何搭建工程模板。</summary>
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>1.蓝桥杯LED模块</title>
    <link href="https://rosslin.xyz/2025/11/22/1.LED%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81/"/>
    <id>https://rosslin.xyz/2025/11/22/1.LED%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81/</id>
    <published>2025-11-22T02:00:00.000Z</published>
    <updated>2025-11-28T10:16:57.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝桥杯单片机之LED灯"><a href="#蓝桥杯单片机之LED灯" class="headerlink" title="**蓝桥杯单片机之LED灯 **"></a>**蓝桥杯单片机之LED灯 **</h1><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/NotebookLM%20Mind%20Map.png" alt="NotebookLM Mind Map"></p><p>在使用单片机控制LED灯时，若通过<strong>74HC138译码器</strong>和<strong>M74HC573锁存器</strong>进行地址选通与信号保持，需按以下三个关键步骤操作：</p><blockquote><p>✅ <strong>点亮LED前的三个必要步骤：</strong><br><strong>1. 打开锁存器（使能） → 2. 选中Y4输出 → 3. 通过译码器配置地址</strong></p></blockquote><hr><h2 id="🔧-一、核心器件原理补充"><a href="#🔧-一、核心器件原理补充" class="headerlink" title="🔧 一、核心器件原理补充"></a>🔧 一、核心器件原理补充</h2><h3 id="1-74HC138-3-8译码器（Decoder）"><a href="#1-74HC138-3-8译码器（Decoder）" class="headerlink" title="1. 74HC138 3-8译码器（Decoder）"></a><strong>1. 74HC138 3-8译码器（Decoder）</strong></h3><ul><li><strong>功能</strong>：将3位二进制输入（A、B、C）译码为8个独立低电平有效输出（Y0～Y7），其余输出为高电平。</li><li>使能端：<ul><li><code>G1</code>：高电平有效</li><li><code>G2A</code>、<code>G2B</code>：低电平有效</li><li><strong>只有当 <code>G1=1</code> 且 <code>G2A=G2B=0</code> 时，译码器才工作</strong></li></ul></li><li><strong>输出特性</strong>：<strong>低电平有效</strong>，即选中通道输出为<code>0</code>，未选中为<code>1</code></li><li>本电路应用：<ul><li><code>A、B、C</code> 接 P2.0、P2.1、P2.2（或类似端口）</li><li>我们希望选中 <strong>Y4</strong>，即二进制 <code>100</code> → A&#x3D;0, B&#x3D;0, C&#x3D;1（注意顺序）</li><li>此时 Y4 输出为<strong>低电平</strong>，其余为高电平</li></ul></li></ul><blockquote><p>💡 <strong>关键点</strong>：Y4为低 → 经过或非门 → Y4C为高 → 锁存器使能</p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230032264.png"></p></blockquote><h3 id="2-M74HC573M1R-八D锁存器（Latch）"><a href="#2-M74HC573M1R-八D锁存器（Latch）" class="headerlink" title="2. M74HC573M1R 八D锁存器（Latch）"></a><strong>2. M74HC573M1R 八D锁存器（Latch）</strong></h3><ul><li><p><strong>功能</strong>：8位透明锁存器，当使能端（LE）为高电平时，输出跟随输入；当LE为低电平时，锁存当前输入值并保持。</p></li><li><p>引脚说明：</p><ul><li><code>D0～D7</code>：数据输入（接P0口）</li><li><code>Q0～Q7</code>：数据输出（接LED阴极）</li><li><code>LE</code>（Latch Enable）：锁存使能端，<strong>高电平有效</strong></li><li><code>OE</code>（Output Enable）：输出使能端，<strong>低电平有效</strong>（本电路常接地，始终使能）</li></ul></li><li><p>本电路应用：</p><ul><li><p><code>LE</code> 由 <strong>Y4C</strong> 控制</p></li><li><p><code>Y4C</code> 由 <code>Y4</code> 经<strong>或非门</strong>生成 → <strong>Y4为低时，Y4C为高</strong></p></li><li><p>所以：<strong>选中Y4 → Y4C&#x3D;高 → 锁存器打开 → P0口数据被锁存到LED</strong></p><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230233125.png"></p></li></ul></li></ul><blockquote><p>✅ <strong>总结逻辑链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单片机设置 P2.0~P2.2 = 001 → 74HC138 选中 Y4（输出=0）</span><br><span class="line">Y4=0 → 经或非门 → Y4C=1 → 锁存器LE=1 → 锁存器透明</span><br><span class="line">单片机设置 P0 = 某个值（如 0x01）→ 数据传入锁存器</span><br><span class="line">P2置低（LE=0）→ 锁存器锁定，保持LED状态，释放P0口</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="💡-二、系统初始化函数详解（带注释）"><a href="#💡-二、系统初始化函数详解（带注释）" class="headerlink" title="💡 二、系统初始化函数详解（带注释）"></a>💡 二、系统初始化函数详解（带注释）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 函数名：系统外设初始化函数</span><br><span class="line">// 入口参数：无</span><br><span class="line">// 返回值：无</span><br><span class="line">// 功能：初始化系统，关闭所有外设（LED、蜂鸣器、继电器），确保初始状态安全</span><br><span class="line"></span><br><span class="line">void system_init()</span><br><span class="line">&#123;</span><br><span class="line">    /* 第一步：关闭所有（LEDP0 = 11111111（LED低电平点亮，高电平熄灭）</span><br><span class="line">     第二步：配置P2口，使能锁存器（设置P2.7=1，P2.6~P2.5为0，用于后续选通）</span><br><span class="line">     P2 = P2 &amp; 0x1F | 0x80;  → 保留低5位，高3位中仅置P2.7=1</span><br><span class="line">     第三步：关闭锁存器（LE=0，锁定当前状态，防止误触发）</span><br><span class="line">     P2 &amp;= 0x1F; → 将P2.7清零，使锁存器进入保持模式 */</span><br><span class="line">    </span><br><span class="line">    P0 = 0xFF;</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0x80;</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">    /* 第四步：关闭蜂鸣器和继电器</span><br><span class="line">     第五步：再次配置P2，准备选通Y4（P2.2=1, P2.1=0, P2.0=0 → 选Y4）</span><br><span class="line">     0xA0 = 1010 0000 → 设置P2.7=1, P2.5=1，其余为0（此处仅用于配置译码器地址）</span><br><span class="line">     第六步：关闭锁存器（确保译码器选通后不会立即锁存）*/</span><br><span class="line">    </span><br><span class="line">    P0 = 0x00;</span><br><span class="line">    P2 = P2 &amp; 0x1F | 0xA0;</span><br><span class="line"></span><br><span class="line">    // 第六步：关闭锁存器（确保译码器选通后不会立即锁存）</span><br><span class="line">    P2 &amp;= 0x1F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔍 <strong>说明</strong>：此函数中两次配置P2是为了<strong>先清空锁存器，再配置译码器地址</strong>，避免在设置过程中误触发锁存。</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251110230305970.png"></p><h2 id="💡-三、LED显示控制函数详解（带注释）"><a href="#💡-三、LED显示控制函数详解（带注释）" class="headerlink" title="💡 三、LED显示控制函数详解（带注释）"></a>💡 三、LED显示控制函数详解（带注释）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 函数名：LED显示控制函数（通过锁存器与译码器控制）</span><br><span class="line">// 入口参数：</span><br><span class="line">//   addr：要点亮的LED编号（0~7，对应Q0~Q7）</span><br><span class="line">//   enable：使能标志，1=点亮，0=熄灭</span><br><span class="line">// 返回值：无</span><br><span class="line">// 功能：根据地址和使能信号，控制对应LED的亮灭，通过锁存器保持状态</span><br><span class="line"></span><br><span class="line">void led_disp(unsigned char addr, unsigned char enable)</span><br><span class="line">&#123;</span><br><span class="line">    static unsigned char temp = 0x00;      // 静态变量：存储当前锁存器应输出的值</span><br><span class="line">    static unsigned char temp_old = 0xFF;  // 静态变量：记录上一次锁存的值，用于判断是否变化</span><br><span class="line"></span><br><span class="line">    // 根据enable设置当前要输出的数据</span><br><span class="line">    // 若enable=1，则点亮指定LED（低电平有效，故先取反）</span><br><span class="line">    // 例如：addr=0 → 0x01&lt;&lt;0=0x01 → 取反=0xFE → Q0输出0 → LED点亮</span><br><span class="line">    if(enable)</span><br><span class="line">        temp = ~(0x01 &lt;&lt; addr);   // 点亮：对应位为0</span><br><span class="line">    else</span><br><span class="line">        temp = 0xFF;              // 熄灭：全为1</span><br><span class="line"></span><br><span class="line">    // ✅ 重要：仅当LED状态发生改变时才重新锁存，避免频繁操作</span><br><span class="line">    if(temp != temp_old)</span><br><span class="line">    &#123;</span><br><span class="line">        // 1. 将新数据写入P0口（数据总线）</span><br><span class="line">        P0 = temp;</span><br><span class="line"></span><br><span class="line">        // 2. 使能锁存器：P2.7=1（Y4C=1）</span><br><span class="line">        // P2 = P2 &amp; 0x1F | 0x80; → 保留低5位，P2.7置1</span><br><span class="line">        P2 = P2 &amp; 0x1F | 0x80;</span><br><span class="line"></span><br><span class="line">        // 3. 锁存数据：P2.7=0，关闭锁存器，保持数据</span><br><span class="line">        // P2 &amp;= 0x1F; → 清除P2.7</span><br><span class="line">        P2 &amp;= 0x1F;</span><br><span class="line"></span><br><span class="line">        // 4. 更新记录，避免重复操作</span><br><span class="line">        temp_old = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>✅ <strong>优化说明</strong>：</p><ul><li>使用 <code>static</code> 变量避免重复锁存，提高效率。</li><li><code>temp = ~(0x01 &lt;&lt; addr)</code> 是因为LED阴极接锁存器输出，<strong>低电平点亮</strong>。</li><li>锁存操作必须为“写数据 → 拉高LE → 拉低LE”三步，缺一不可。</li></ul></blockquote><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Beep(unsigned char flag)</span><br><span class="line">&#123;</span><br><span class="line">static unsigned char temp = 0x00;</span><br><span class="line">static unsigned char temp_old = 0xff;</span><br><span class="line">if(flag)</span><br><span class="line">temp |= 0x40;//看原理图！！！</span><br><span class="line">else</span><br><span class="line">temp &amp;= ~0x40;</span><br><span class="line">if(temp != temp_old)</span><br><span class="line">&#123;</span><br><span class="line">P0 = temp;</span><br><span class="line">P2 = P2 &amp; 0x1f | 0xa0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line">temp_old = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Relay(unsigned char flag)</span><br><span class="line">&#123;</span><br><span class="line">static unsigned char temp = 0x00;</span><br><span class="line">static unsigned char temp_old = 0xff;</span><br><span class="line">if(flag)</span><br><span class="line">temp |= 0x10;   //看原理图</span><br><span class="line">else</span><br><span class="line">temp &amp;= ~0x10;</span><br><span class="line">if(temp != temp_old)</span><br><span class="line">&#123;</span><br><span class="line">P0 = temp;</span><br><span class="line">P2 = P2 &amp; 0x1f | 0xa0;</span><br><span class="line">P2 &amp;= 0x1f;</span><br><span class="line">temp_old = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="📌-四、总结：点亮LED的完整流程"><a href="#📌-四、总结：点亮LED的完整流程" class="headerlink" title="📌 四、总结：点亮LED的完整流程"></a>📌 四、总结：点亮LED的完整流程</h2><blockquote><p><strong>“先设地址，再送数据，最后锁存”</strong></p></blockquote><ol><li><strong>选地址</strong>：设置P2.0~P2.2 &#x3D; 001（LED选Y4   蜂鸣器和继电器选Y5）</li><li><strong>送数据</strong>：P0 &#x3D; 要显示的LED数据（如 <code>0xFE</code> 表示点亮LED0）</li><li><strong>锁数据</strong>：P2 &#x3D; 0x80（使能LE）→ P2 &#x3D; 0x00（锁存）</li><li><strong>保持</strong>：锁存器保持输出，P0可释放用于其他操作</li></ol><h2 id="补充（V4T）"><a href="#补充（V4T）" class="headerlink" title="补充（V4T）"></a>补充（V4T）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">/// @brief Led扫描</span><br><span class="line">/// @param addr 需要控制的Led的地址（0-7）</span><br><span class="line">/// @param enable 控制该地址的Led是否点亮</span><br><span class="line">#include &lt;STC15F2K60S2.H&gt;</span><br><span class="line"></span><br><span class="line"> idata  unsigned char temp_1 = 0x00;</span><br><span class="line"> idata  unsigned char temp_old_1 = 0xff;</span><br><span class="line"></span><br><span class="line">void Led_Disp(unsigned char *ucLed)</span><br><span class="line">&#123;</span><br><span class="line">   unsigned char temp;</span><br><span class="line">   temp_1=0x00;</span><br><span class="line">   temp_1 = (ucLed[0] &lt;&lt; 0) | (ucLed[1] &lt;&lt; 1) | (ucLed[2] &lt;&lt; 2) | (ucLed[3] &lt;&lt; 3) |</span><br><span class="line">         (ucLed[4] &lt;&lt; 4) | (ucLed[5] &lt;&lt; 5) | (ucLed[6] &lt;&lt; 6) | (ucLed[7] &lt;&lt; 7);</span><br><span class="line">  if (temp_1 != temp_old_1)</span><br><span class="line">  &#123;</span><br><span class="line">    P0 = ~temp_1;</span><br><span class="line">    </span><br><span class="line">    // 操作P2锁存器</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    temp = temp | 0x80;  // 与0x80进行或操作</span><br><span class="line">    P2 = temp;           // 写入P2</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    P2 = temp;           // 写入P2，关闭锁存器</span><br><span class="line">    </span><br><span class="line">    temp_old_1 = temp_1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Led_Off()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char temp;</span><br><span class="line"></span><br><span class="line">    P0 = 0xff;</span><br><span class="line">    </span><br><span class="line">    // 操作P2锁存器</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    temp = temp | 0x80;  // 与0x80进行或操作</span><br><span class="line">    P2 = temp;           // 写入P2</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    P2 = temp;           // 写入P2，关闭锁存器</span><br><span class="line">    </span><br><span class="line">    temp_old_1=0x00;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idata unsigned char temp_0 = 0x00;</span><br><span class="line">idata unsigned char temp_old_0 = 0xff;</span><br><span class="line">/// @brief 蜂鸣器控制</span><br><span class="line">/// @param enable</span><br><span class="line">void Beep(bit enable)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char temp;</span><br><span class="line">  </span><br><span class="line">  if (enable)</span><br><span class="line">    temp_0 |= 0x40;</span><br><span class="line">  else</span><br><span class="line">    temp_0 &amp;= ~(0x40);</span><br><span class="line">  if (temp_0 != temp_old_0)</span><br><span class="line">  &#123;</span><br><span class="line">    P0 = temp_0;</span><br><span class="line">    </span><br><span class="line">    // 操作P2锁存器</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    temp = temp | 0xa0;  // 与0xa0进行或操作</span><br><span class="line">    P2 = temp;           // 写入P2</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    P2 = temp;           // 写入P2，关闭锁存器</span><br><span class="line">    </span><br><span class="line">    temp_old_0 = temp_0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// @brief 继电器控制</span><br><span class="line">/// @param enable</span><br><span class="line">void Relay(bit enable)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char temp;</span><br><span class="line">  </span><br><span class="line">  if (enable)</span><br><span class="line">    temp_0 |= 0x10;</span><br><span class="line">  else</span><br><span class="line">    temp_0 &amp;= ~(0x10);</span><br><span class="line">  if (temp_0 != temp_old_0)</span><br><span class="line">  &#123;</span><br><span class="line">    P0 = temp_0;</span><br><span class="line">    </span><br><span class="line">    // 操作P2锁存器</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    temp = temp | 0xa0;  // 与0xa0进行或操作</span><br><span class="line">    P2 = temp;           // 写入P2</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    P2 = temp;           // 写入P2，关闭锁存器</span><br><span class="line">    </span><br><span class="line">    temp_old_0 = temp_0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// @brief MOTOR控制</span><br><span class="line">/// @param enable</span><br><span class="line">void MOTOR(bit enable)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char temp;</span><br><span class="line">  </span><br><span class="line">  if (enable)</span><br><span class="line">    temp_0 |= 0x20;</span><br><span class="line">  else</span><br><span class="line">    temp_0 &amp;= ~(0x20);</span><br><span class="line">  if (temp_0 != temp_old_0)</span><br><span class="line">  &#123;</span><br><span class="line">    P0 = temp_0;</span><br><span class="line">    </span><br><span class="line">    // 操作P2锁存器</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    temp = temp | 0xa0;  // 与0xa0进行或操作</span><br><span class="line">    P2 = temp;           // 写入P2</span><br><span class="line">    temp = P2 &amp; 0x1f;    // 保留P2的低5位</span><br><span class="line">    P2 = temp;           // 写入P2，关闭锁存器</span><br><span class="line">    </span><br><span class="line">    temp_old_0 = temp_0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;蓝桥杯单片机之LED灯&quot;&gt;&lt;a href=&quot;#蓝桥杯单片机之LED灯&quot; class=&quot;headerlink&quot; title=&quot;**蓝桥杯单片机之LED灯 **&quot;&gt;&lt;/a&gt;**蓝桥杯单片机之LED灯 **&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.gi</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>5.I2C协议 (AT24C02 )）</title>
    <link href="https://rosslin.xyz/2025/11/22/5.I2C%E5%8D%8F%E8%AE%AE%20(AT24C02%20)/"/>
    <id>https://rosslin.xyz/2025/11/22/5.I2C%E5%8D%8F%E8%AE%AE%20(AT24C02%20)/</id>
    <published>2025-11-22T02:00:00.000Z</published>
    <updated>2025-11-28T10:18:55.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I2C-协议-AT24C02"><a href="#I2C-协议-AT24C02" class="headerlink" title="I2C 协议 (AT24C02 )"></a>I2C 协议 (AT24C02 )</h1><p>AT24C02 是一款 <strong>2Kbit (256 字节)</strong> 的串行电可擦除可编程只读存储器 (EEPROM)，它使用 I2C 协议进行数据读写。</p><h2 id="1-AT24C02-核心特点与-PCF8591-对比"><a href="#1-AT24C02-核心特点与-PCF8591-对比" class="headerlink" title="1. AT24C02 核心特点与 PCF8591 对比"></a>1. AT24C02 核心特点与 PCF8591 对比</h2><p>AT24C02 和 PCF8591 的主要区别在于<strong>应用功能</strong>。它们共享 <strong>I2C 通信层</strong>。</p><table><thead><tr><th align="left">特性</th><th align="left">PCF8591 (AD&#x2F;DA 转换器)</th><th align="left">AT24C02 (EEPROM 存储器)</th></tr></thead><tbody><tr><td align="left"><strong>核心功能</strong></td><td align="left">模拟信号的输入&#x2F;输出</td><td align="left"><strong>非易失性数据存储</strong>（掉电数据不丢失）</td></tr><tr><td align="left"><strong>I2C 读&#x2F;写地址</strong></td><td align="left">读&#x2F;写地址不同 (<code>0x90</code>&#x2F;<code>0x91</code>)</td><td align="left">读&#x2F;写地址不同 (<code>0xA0</code>&#x2F;<code>0xA1</code>)</td></tr><tr><td align="left"><strong>数据寻址</strong></td><td align="left">通过<strong>控制字节</strong>选择 AIN 通道</td><td align="left">通过<strong>内部地址指针</strong>定位存储单元</td></tr><tr><td align="left"><strong>数据传输</strong></td><td align="left">读操作时，返回 2 个字节（状态+数据）</td><td align="left">写操作通常是<strong>页写 (Page Write)</strong>；读操作可以是<strong>连续读 (Sequential Read)</strong>。</td></tr></tbody></table><hr><h2 id="2-I2C-应用层：AT24C02-寻址机制"><a href="#2-I2C-应用层：AT24C02-寻址机制" class="headerlink" title="2. I2C 应用层：AT24C02 寻址机制"></a>2. I2C 应用层：AT24C02 寻址机制</h2><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105554912.png"></p><h3 id="设备地址-Device-Address"><a href="#设备地址-Device-Address" class="headerlink" title="设备地址 (Device Address)"></a>设备地址 (Device Address)</h3><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/20251111105638244.png"></p><p>根据您的代码，AT24C02 的地址结构遵循 I2C 标准，地址位通常包含芯片类型、存储器块选择位，以及 R&#x2F;W 位。</p><table><thead><tr><th align="left">操作</th><th align="left">地址格式（假设 A0&#x2F;A1&#x2F;A2 均接地）</th><th align="left">写地址 (十六进制)</th><th align="left">读地址 (十六进制)</th></tr></thead><tbody><tr><td align="left"><strong>地址</strong></td><td align="left"><code>1010 000x</code></td><td align="left"><code>0xA0</code> (写)</td><td align="left"><code>0xA1</code> (读)</td></tr></tbody></table><p><strong>对比 PCF8591:</strong></p><ul><li>PCF8591 写地址：<code>0x90</code> (<code>1001 0000</code>)</li><li>AT24C02 写地址：<code>0xA0</code> (<code>1010 0000</code>)</li></ul><h3 id="内部存储器寻址-Memory-Addressing"><a href="#内部存储器寻址-Memory-Addressing" class="headerlink" title="内部存储器寻址 (Memory Addressing)"></a>内部存储器寻址 (Memory Addressing)</h3><p>AT24C02 共有 256 字节的存储空间（地址范围 00H00<em>H</em> 到 FFH<em>FF**H</em>）。与 PCF8591 的“控制字节”不同，EEPROM 使用**数据地址（Memory Address）**来定位要读写的位置。</p><ul><li>在您的代码中，<code>addr</code> 参数代表的就是这个<strong>内部数据地址</strong>（0 到 255）。</li><li><strong>注意:</strong> AT24C02 的地址是 8 位（1字节）。对于更大的 EEPROM（如 AT24C256），地址需要 2 个字节。</li></ul><hr><h2 id="3-AT24C02-函数分析与-I2C-时序对比"><a href="#3-AT24C02-函数分析与-I2C-时序对比" class="headerlink" title="3. AT24C02 函数分析与 I2C 时序对比"></a>3. AT24C02 函数分析与 I2C 时序对比</h2><p>您的函数完美展示了 I2C 读写的基本时序模板。</p><h3 id="3-1-EEPROM-Write-函数分析-写操作"><a href="#3-1-EEPROM-Write-函数分析-写操作" class="headerlink" title="3.1 EEPROM_Write 函数分析 (写操作)"></a>3.1 EEPROM_Write 函数分析 (写操作)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void EEPROM_Write(unsigned char* EEPROM_String, unsigned char addr, unsigned char num)</span><br><span class="line">&#123;</span><br><span class="line">IIC_Start();                   // 1. START信号 (通用)</span><br><span class="line">IIC_SendByte(0xA0);            // 2. 发送写地址 (EEPROM特有)</span><br><span class="line">IIC_WaitAck();                 // 3. 等待应答 (通用)</span><br><span class="line"></span><br><span class="line">IIC_SendByte(addr);            // 4. 写入数据地址 (EEPROM特有)</span><br><span class="line">IIC_WaitAck();                 // 5. 等待应答 (通用)</span><br><span class="line"></span><br><span class="line">while(num--)</span><br><span class="line">&#123;</span><br><span class="line">IIC_SendByte(*EEPROM_String++); // 6. 写入数据 (EEPROM特有)</span><br><span class="line">IIC_WaitAck();                 // 7. 等待应答 (通用)</span><br><span class="line">IIC_Delay(200);               // 8. 关键：写入后必须延迟（见下方说明）</span><br><span class="line">&#125;</span><br><span class="line">IIC_Stop();                    // 9. STOP信号 (通用)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 PCF8591 写入对比：</strong></p><table><thead><tr><th align="left">步骤</th><th align="left">PCF8591 写入 (例如 DA)</th><th align="left">AT24C02 写入</th></tr></thead><tbody><tr><td align="left">步骤 2&#x2F;3</td><td align="left">发送设备地址 + R&#x2F;W&#x3D;0</td><td align="left">发送设备地址 + R&#x2F;W&#x3D;0</td></tr><tr><td align="left"><strong>关键差异</strong></td><td align="left">发送 <strong>控制字节</strong> (指定通道&#x2F;功能)</td><td align="left">发送 <strong>数据地址</strong> (指定存储单元)</td></tr><tr><td align="left"><strong>数据负载</strong></td><td align="left">发送 <strong>DA 数据</strong></td><td align="left">循环发送 <strong>数据字节</strong></td></tr><tr><td align="left"><strong>延迟 (新)</strong></td><td align="left">无显式延迟（因其是瞬间操作）</td><td align="left"><strong>必须有延迟 (<code>IIC_Delay(200)</code>)</strong>，因为 EEPROM 擦写需要时间。</td></tr></tbody></table><h3 id="3-2-EEPROM-Read-函数分析-读操作"><a href="#3-2-EEPROM-Read-函数分析-读操作" class="headerlink" title="3.2 EEPROM_Read 函数分析 (读操作)"></a>3.2 EEPROM_Read 函数分析 (读操作)</h3><p>读取操作相对复杂，因为它需要<strong>两次 I2C 事务</strong>：一次是“寻址&#x2F;定位”，一次是“读取”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void EEPROM_Read(unsigned char* EEPROM_String, unsigned char addr, unsigned char num)</span><br><span class="line">&#123;</span><br><span class="line">// --- 第一次通信：定位/设置读取地址 ---</span><br><span class="line">IIC_Start();                      // 1. START信号</span><br><span class="line">IIC_SendByte(0xA0);               // 2. 发送写地址 (定位操作必须用写模式)</span><br><span class="line">IIC_WaitAck();</span><br><span class="line"></span><br><span class="line">IIC_SendByte(addr);               // 3. 写入要读取的数据地址</span><br><span class="line">IIC_WaitAck();                    // 4. 等待应答</span><br><span class="line"></span><br><span class="line">// --- 第二次通信：实际读取数据 ---</span><br><span class="line">IIC_Start();                      // 5. 第二次 START (重启)</span><br><span class="line">IIC_SendByte(0xA1);               // 6. 发送读地址 (确定读模式)</span><br><span class="line">IIC_WaitAck();</span><br><span class="line"></span><br><span class="line">while(num--)</span><br><span class="line">&#123;</span><br><span class="line">*EEPROM_String++ = IIC_RecByte();// 7. 接收数据</span><br><span class="line">if(num) IIC_SendAck(0);       // 8. 如果还有数据，发送 ACK (0)</span><br><span class="line">else IIC_SendAck(1);      // 9. 如果是最后一个字节，发送 NACK (1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IIC_Stop();                       // 10. STOP信号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 PCF8591 读取对比：</strong></p><table><thead><tr><th align="left">步骤</th><th align="left">PCF8591 读取 (AD)</th><th align="left">AT24C02 读取 (EEPROM)</th></tr></thead><tbody><tr><td align="left"><strong>定位&#x2F;寻址</strong></td><td align="left">发送控制字节（指定 AIN 通道）</td><td align="left">发送数据地址（指定存储单元）</td></tr><tr><td align="left"><strong>数据获取</strong></td><td align="left">第一次发送 R&#x2F;W&#x3D;1后，返回 <strong>2个字节</strong>（状态+数据）。</td><td align="left">必须<strong>重新发起一次 I2C 通信</strong>（第二次 START&#x2F;地址），才能开始接收数据。</td></tr><tr><td align="left"><strong>结束应答</strong></td><td align="left">主设备在最后一个字节后发送 NACK 结束传输。</td><td align="left">循环接收中，最后一个字节需要发送 NACK (1)，随后发送 STOP。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Roselin1217/roselin-images/main/images/i2c%E9%80%9F%E8%AE%B0.png"></p><h3 id="关键点总结：EEPROM-的-Page-Write-页写"><a href="#关键点总结：EEPROM-的-Page-Write-页写" class="headerlink" title="关键点总结：EEPROM 的 Page Write (页写)"></a>关键点总结：EEPROM 的 Page Write (页写)</h3><p>您的 <code>EEPROM_Write</code> 函数使用了 <code>while(num--)</code> 循环来写入多个字节，这被称为<strong>连续写入</strong>。</p><ul><li><strong>注意:</strong> AT24C02 支持<strong>页写</strong>（Page Write）。如果写入的地址未跨越页边界（AT24C02 的页大小通常是 8 字节），它可以一次性写入一页数据，速度比单字节写入快得多。</li><li>您的代码中显式添加的 <code>IIC_Delay(200)</code> 是为了等待 EEPROM 完成内部的<strong>数据擦写周期</strong>，这是存储器独有的步骤，PCF8591 (ADC&#x2F;DAC) 通常不需要如此长的写等待时间。</li></ul><h2 id="4-C-语言核心：指针与函数调用"><a href="#4-C-语言核心：指针与函数调用" class="headerlink" title="4  C 语言核心：指针与函数调用"></a>4  C 语言核心：指针与函数调用</h2><h3 id="4-1-为什么函数参数中要用-指针-？"><a href="#4-1-为什么函数参数中要用-指针-？" class="headerlink" title="4.1 为什么函数参数中要用 * (指针)？"></a>4.1 为什么函数参数中要用 <code>*</code> (指针)？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void EEPROM_Write(unsigned char* EEPROM_String, ...)</span><br></pre></td></tr></table></figure><ul><li><strong>原因</strong>：C 语言函数<strong>无法直接传递整个数组</strong>。传递数组名会退化为指向其首元素的指针。</li><li><strong>作用</strong>：<code>*</code> 号在参数声明中表示 <code>EEPROM_String</code> 是一个<strong>指针</strong>，它存储的是一个内存地址。函数通过这个地址可以访问和操作一整块连续的数据。</li></ul><h3 id="4-2-如何调用带指针参数的函数？"><a href="#4-2-如何调用带指针参数的函数？" class="headerlink" title="4.2 如何调用带指针参数的函数？"></a>4.2 如何调用带指针参数的函数？</h3><table><thead><tr><th align="left">数据类型</th><th align="left">如何传递给 <code>EEPROM_Write</code></th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong>字符串常量</strong></td><td align="left">直接传递字符串名（本身就是指针）</td><td align="left"><code>EEPROM_Write(&quot;Hello&quot;, 0, 5);</code></td></tr><tr><td align="left"><strong>数组</strong></td><td align="left">直接传递数组名（退化为指针）</td><td align="left"><code>unsigned char data[5]={...}; EEPROM_Write(data, 10, 5);</code></td></tr><tr><td align="left"><strong>单个变量</strong></td><td align="left">使用 <code>&amp;</code> 运算符获取其地址</td><td align="left"><code>unsigned char val=100; EEPROM_Write(&amp;val, 20, 1);</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;I2C-协议-AT24C02&quot;&gt;&lt;a href=&quot;#I2C-协议-AT24C02&quot; class=&quot;headerlink&quot; title=&quot;I2C 协议 (AT24C02 )&quot;&gt;&lt;/a&gt;I2C 协议 (AT24C02 )&lt;/h1&gt;&lt;p&gt;AT24C02 是一款 &lt;str</summary>
      
    
    
    
    <category term="嵌入式之旅" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/"/>
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B9%8B%E6%97%85/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    
    <category term="大学竞赛" scheme="https://rosslin.xyz/tags/%E5%A4%A7%E5%AD%A6%E7%AB%9E%E8%B5%9B/"/>
    
    <category term="学习笔记" scheme="https://rosslin.xyz/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="蓝桥杯" scheme="https://rosslin.xyz/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
</feed>
